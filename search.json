[{"title":"MySQL上课笔记整理","url":"/2024/10/04/MySQL%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/","content":"MySQL上课笔记整理\n范式\nx`➡️y\n存在：部分函数依赖\n不存在：完全\n传递函数：\nx➡️y\ny➡️z\nx➡️z\n反过来不成立\n第一范式：不存在可分割项\n第二范式：需先满足第一范式，找到候选码，再去掉部分函数依赖\n第三范式：每一个非主属性都不传递函数依赖\n6\n解决之道：分解\n\n文章作者: [Blue Eagle]\n文章链接: [https://yjh021.github.io/2024/10/04/MySQL笔记整理/]\n版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 [Blue Eagle]\n\n","categories":["数据库","MySQL"],"tags":["SQL","数据库管理","博客"]},{"title":"MySQL的安装和使用","url":"/2024/10/22/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/","content":"MySQL的安装和使用\n安装方式\nMySQL的安装有两种方式：\n\n解压配置方式\n\n\n\n步骤安装方式\n\n\n安装包下载-解压版\n下载地址：https://downloads.mysql.com/archives/community/\n\n解压软件包\n将MySQL软件包解压在没有中文和空格的目录下\n\n设置配置文件\n在解压目录创建my.ini文件并添加内容如下：\n\n\n[mysqld]# 设置3306端口port=3306# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8\n配置系统环境\n①在【我的电脑】或【此电脑】右键，选择【属性】\n②选择【高级系统设置】\n③选择【高级】-》【环境变量】\n\n④将MYSQL_HOME添加到PATH环境变量\n\n服务操作\n使用管理员权限进入DOS，在cmd中，进入解压目录下的bin目录依次执行以下命令：\n# ①对mysql进行初始化，请注意，这里会生产一个临时密码，后边要使用这个临时密码  mysqld --initialize --user=mysql --console# ②安装mysql服务    mysqld --install# ③启动mysql服务   net start mysql# ④登录mysql，这里需要使用之前生成的临时密码 mysql -uroot -p# ⑤修改root用户密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;# ⑤修改root用户权限create user &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;\n\n安装包下载-安装版\n下载地址：https://downloads.mysql.com/archives/installer/\n\n按照步骤安装\n第一步：\n\n第二步：此后按照流程安装即可，遇到Next（下一步）直接点击即可：\n\n第三步：点击Execute后需要等待几分钟。\n\n第四步：当所有的状态都变成Complete之后，点击 Next：\n\n第五步：\n\n第六步：\n\n第七步：\n\n第八步：此处输入密码务必记住，用于之后登陆数据库，建议将密码设置为：123456\n\n第九步：再按照  安装包下载-解压版  中的方法添加环境变量，步骤均为一样。\n\n以上两个安装方法，都可以在以管理员运行的 cmd 窗口中使用：mysql -uroot -p   来验证是否安装成功 。\n本篇文章的目的是为了方便查阅和学习。\n\n文章作者: [Blue Eagle]\n文章链接: [https://yjh021.github.io/2024/10/22/MySQL的安装和使用/]\n版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 [Blue Eagle]\n\n","categories":["数据库","MySQL"],"tags":["SQL","数据库管理","博客"]},{"title":"MySQL学习代码","url":"/2024/10/04/MySQL/","content":"MySQL学习代码\nSQL\n\n全称 Structured Query Language, 结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准。\n\nSQL通用语法\n\n在学习具体的SQL语句之前，先来了解一下SQL语言的通用语法。\n\nSQL语句可以单行或多行书写,以分号结尾。\nSQL语句可以使用空格/缩进来增强语句的可读性。\nMySQL数据库的SQL语句不区分大小写，关键字建议使用大写。\n注释:\n单行注释:-- 注释内容 或 # 注释内容\n多行注释:/** 注释内容*  */\n\n\nSQL分类\nSQL 语句，根据其功能，主要分为四类:DDL、DML、DQL、DCL 。\n\n\n\n分类\n全称\n说明\n\n\n\n\nDDL\nData Definition Language\n数据定义语言，用来定义数据库对象（数据库，表，字段)\n\n\nDML\nData Manipulation Language\n数据操作语言，用来对数据库表中的数据进行增删改\n\n\nDQL\nData Query Language\n数据查询语言，用来查询数据库中表的记录\n\n\nDCL\nData Control Language\n数据控制语言，用来创建数据库用户、控制数据库的访问权限\n\n\n\nMySQL数据库基本操作—DDL\n\nDDL：（Data Definition Language）,数据定义语言，该语言部分包括以下内容：\n\n\n对数据库的常用操作\n对表结构的常用操作\n修改表结构\n\n\n\n数据库操作\n-- 查看所有的数据库（结尾一定要加英文[;]，表示语句结束）show databases;-- 创建数据库（其中 [if not exists] 为可选参数,表示如果不存在再创建，存在不会创建；[charset=utf8] 为编码方式，可选）create database [if not exists] mydb1 [charset=utf8];-- 切换（选择要操作的）数据库(mydb1为数据库名)use mydb1;-- 删除数据库（[if exists] 表示如果有再删除，可选）drop database [if exists] mydb1;-- 修改数据库编码（不常用）alter database mydb1 character set utf8;\n表创建—格式\n\n创建表是构建一张空表，指定这个表的名字，这个表有几列，每一列叫什么名字，以及每一列存储的数据类型。\n\n-- 创建表格式create table [if not exists] 表名 (    字段名1 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;],    字段名2 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;],    字段名3 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;])[表的一些设置];-- 列如：-- 选择表（数据库）use mydb1;-- 创建表create table if not exists student (\tsid int,    name varchar(20),    gender varchar(10),    age int,    birth date,\taddress varchar(30),\t\t    score double);\n数据类型—数值类型(数字类型)\n\n1、数据类型\n\n数据类型是指在创建表的时候为表中字段指定数据类型，只有数据符合类型要求才能存储起来，使用数据类型的原则是够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间.\n\n\n\n数值类型\n\n\n\n\n\n数据类型—字符串类型\n\n数据类型—日期和时间类型\n\n还有 null 类型\n\n\n没有值，未知\n不要使用NULL值进行计算\n\n\n数据库的字段属性\n\nUnSigned\n\n\n没有值，未知\n不要使用NULL值进行计算\n\n\nZEROFILL\n\n\n0填充的\n不足位数的用0来填充 , 如int(3),5则为005\n\n\nAuto_InCrement\n\n\n通常理解为自增，自动在上一条记录的基础上默认+1\n通常用来设计唯一的主键，必须是整数类型\n可定义起始值和步长\n\n\n\n当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表\nSET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局)\n\n\n\n\n\n\nNULL 和 NOT NULL\n\n\n默认为NULL , 即没有插入该列的数值\n如果设置为NOT NULL , 则该列必须有值\n\n\nDEFAULT\n\n\n默认的\n用于设置默认值\n例如,性别字段,默认为&quot;男&quot; , 否则为 “女” ; 若无指定该列的值 , 则默认值为&quot;男&quot;的值\n\n\n\n-- 例子：执行 desc 表名; 后会出现以下结果CREATE TABLE IF NOT EXISTS `student`(\t`id` INT(4)\tNOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,\t`name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,\t`pwd` VARCHAR(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;,\t`sex` VARCHAR(2) NOT NULL DEFAULT &#x27;女&#x27; COMMENT &#x27;性别&#x27;,\t`birthday` DATETIME DEFAULT NULL COMMENT &#x27;出生日期&#x27;,\t`address` VARCHAR(100) DEFAULT NULL COMMENT &#x27;家庭住址&#x27;,\t`email` VARCHAR(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,\tPRIMARY KEY (`id`))ENGINE=INNODB DEFAULT CHARSET=utf8\n表的其他操作\n-- 查看当前数据库的所有表名称show tables;-- 查看指定某个表的创建语句show create table 表名;-- 查看表结构desc 表名;-- 删除表drop table 表名;\n修改表结构\n修改表添加列（字段）\n-- 为表添加新列（字段）alter table 表名 add 列名 类型(长度) [约束];-- 例子：为student表添加一个新的字段为：系别 dept 类型为 varchar(20)alter table student add dept varchar(20);\n修改列名和类型\n-- 语法格式alter table 表名 change 旧列名 新列名 类型(长度) [约束];-- 例子：为student表的 dept 字段更换为 department varchar(30)alter table student change dept department varchar(30);-- 修改列的数据类型alter table 表名 modify column 列名 新的列的类型-- 例子：为student表的department列的类型修改为char(20)alter table student modify column department char(20);\n修改表删除列\n-- 语法格式alter table 表名 drop 列名;-- 例如：删除student表中department这列alter table student drop department;\n修改表名\n-- 语法格式rename table 表名 to 新表名;-- 例子：将表student改名成sturename table student to stu;\nMySQL数据库基本操作—DML\nDML基本介绍\n\nDML是指数据操作语言，英文全称是Data Manipulation Language，用来对数据库中表的数据记录进行更新（增删改）。\n关键字：\n\n\n插入insert\n删除delete\n更新update\n\n\n\n数据插入\n-- 语法格式-- 向表中插入某些（列和值要相互对应）insert into 表(列名1，列名2，列名3...) values(值1，值2，值3...)；-- 向表中插入所有列insert into 表 values(值1，值2，值3...);-- 例子：insert into student(sid,name,gender,age,birth,address,score) values(1001,&#x27;张三&#x27;,&#x27;男&#x27;,18,&#x27;1996-12-23&#x27;,&#x27;北京&#x27;,83.5);insert into student values(1001,&#x27;张三&#x27;,&#x27;男&#x27;,18,&#x27;1996-12-23&#x27;,&#x27;北京&#x27;,83.5);-- 一次添加多行数据insert into student values(1001,&#x27;张三&#x27;,&#x27;男&#x27;,18,&#x27;1996-12-23&#x27;,&#x27;北京&#x27;,83.5),\t\t\t\t\t\t(1002,&#x27;李四&#x27;,&#x27;男&#x27;,19,&#x27;1997-12-23&#x27;,&#x27;北京&#x27;,85.5);\n数据修改\n-- 语法格式update 表名 set 字段名 = 值,字段名 = 值...;update 表名 set 字段名 = 值,字段名 = 值... where 条件;-- 例子：-- 将所有学生的地址修改为重庆update student set address = &#x27;重庆&#x27;;-- 将sid为1004的学生的地址修改为北京update student set address = &#x27;北京&#x27; where sid = 1004;-- 将sid大于1004的学生的地址修改为上海update student set address = &#x27;北京&#x27; where sid &gt; 1004;-- 将sid为1005的学生的地址修改为北京，成绩修改为100update student set address = &#x27;北京&#x27;,score = 100 where sid = 1005;\n数据删除\n-- 语法格式（delete 不加条件会清空该表所有数据）delete from 表名 [where 条件];truncate table 表名 或者 truncate 表名;-- 例子-- 1.删除sid为1004的学生数据delete from student where sid = 1004;-- 2.删除表所有数据delete from student;-- 3.清空表数据-- 方式一truncate table student;-- 方式二truncate student;-- 注意：delete 和 truncate 原理不同，delete 只删除内容，而 truncate 类似于 drop table，可以理解为是将整个表删除，然后再创建该表；\nMySQL约束\n简介\n概念：\n\n约束英文：constraint\n约束实际上就是表中数据的限制条件。\n\n作用\n\n表在设计的时候加入约束的目的就是为了保证表中的记录完整性和有效性，比如用户表有些列的值(手机号）不能为空，有些列的值（身份证号)不能重复。\n\n分类\n\n\n主键约束(primary key) PK\n自增长约束(auto_increment)\n非空约束(not null)\n唯一性约束(unique)\n默认约束(default)\n零填充约束(zerofill)\n外键约束(foreign key) FK\n检查约束(8.0.16版本之后) (check)\n\n\n主键约束*\n概念：\n\n\nMySQL主键约束是一个列或者多个列的组合，其值能唯一地标识表中的每一行,方便在RDBMS中尽快的找到某一行。\n主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。\n每个表最多只允许一个主键。\n主键约束的关键字是：primary key\n当创建主键的约束时，系统默认会在所在的列和列组合上建立对应的唯一索引。\n\n\n操作\n\n\n添加单列主键\n\n创建单列主键有两种方式，一种是在定义字段的同时指定主键，一种是定义完字段之后指定主键。\n\n-- 方式1——语法：\t-- 在 create table 语句中，通过 primary key 关键字来指定主键。\t-- 在定义字段的同时指定主键，语法格式如下：create table 表名 (\t...    &lt;字段名&gt; &lt;数据类型&gt; primary key,    ...);-- 方式1——实现：create table emp1 (\teid int primay key,    name varchar(20),    deptId int,    salary double);-- 方式2——语法：\t-- 在定义字段的同时指定主键，语法格式如下：create table 表名 (\t...    [constraint &lt;约束名&gt;] primary key [字段名]);-- 方式2——实现：create table emp2 (\teid int,    name varchar(20),    deptId int,    salary double,    constraint pk1 primary key(eid));\n\n\n添加多列联合主键\n\n所谓的联合主键，就是这个主键是由一张表中多个字段组成的。\n注意：\n\t1. 当主键是由多个字段组成时，不能直接在字段名后面声明主键约束。\n\t2. 一张表只能有一个主键，联合主键也是一个主键。\n\t3. 联合主键各列不能为空。\n\n\n-- 语法：create table 表名 (\t...    primary key(字段1，字段2，...，字段n));-- 实现：create table emp3 (\tname varchar(20),    deptId int,    salary double,    primary key(name, deptId));\n\n\n\n通过修改表结构添加主键\n主键约束不仅可以在创建表的同时创建，也可以在修改表时添加。\n\n\n\n-- 语法：create table 表名 (\t...);alter table &lt;表名&gt; add primary key (字段列表)；-- 实现：-- 添加单列主键create table emp4 (\teid int,    name varchar(20),    deptId int,    salary double);alter table emp4 add primary key (eid);-- 添加多列主键(联合)create table emp5 (\teid int,    name varchar(20),    deptId int,    salary double);alter table emp5 add primary key (eid, deptId);\n\n\n删除主键约束\n\n一个表中不需要主键约束时，就需要从表中将其删除。删除主键约束的方法要比创建主键约束容易的多。\n\n-- 格式alter table &lt;数据库名&gt; drop primary key;-- 实现-- 删除单列主键alter table emp1 drop primary key;-- 删除联合主键alter table emp5 drop primary key;\n自增长约束(auto_increment)\n概念：\n\n在MySQL中，当主键定义为自增长后，这个主键的值就不再需要用户输入数据了，而由数据库系统根据定义自动赋值。每增加一条记录，主键会自动以相同的步长进行增长。\n通过给字段添加 auto_increment 属性来实现主键自增长。\n一般搭配主键使用，提高健壮性。\n\n-- 语法字段名 数据类型 auto_increment;-- 操作create table t_user1 (\tid int primary key auto_increment，    name varchar(20));\n\n\n\n特点：\n\n\n默认情况下，auto_increment的初始值是 1，每新增一条记录，字段值自动加 1。\n\n\n一个表中只能有一个字段使用 auto_increment约束，且该字段必须有唯一索引，以避免序号重复(即为主键或主键的一部分)。\n\n\nauto_increment约束的字段必须具备 NOT NULL 属性。\n\n\nauto_increment约束的字段只能是整数类型(TINYINT、SMALLINT、INT、BIGINT )等。\n\n\nauto_increment约束字段的最大值受该字段的数据类型约束，如果达到上限，auto_increment就会失效。\n\n\n\n\n\n指定自增字段初始值\n\n\n如果第一条记录设置了该字段的初始值，那么新增加的记录就从这个初始值开始自增。例如，如果表中插入的第一条记录的id值设置为5，那么再插入记录时，id值就会从5开始往上增加。\n\n\n-- 方式1，创建表时指定create table t_user2 (\tid int primary key auto_increment,    name varchar(20))auto_increment = 100;-- 方式2，创建表之后指定create table t_user2 (\tid int primary key auto_increment,    name varchar(20));alter table t_user2 auto_increment = 200;\n\n注意：delete 和 truncate 在删除后自增列的变化：\n\ndelete数据之后自动增长从断点开始\ntruncate数据之后自动增长从默认起始值开始\n\n\n-- 格式delete from &lt;表名&gt;;truncate &lt;表名&gt;;-- 实现delete from t_user1;truncate t_user2;\n非空约束(not null)\n概念\n\nMySQL非空约束（not null）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。\n\n-- 语法：-- 方式1：&lt;字段名&gt; &lt;数据类型&gt; not null;-- 方式2：alter table 表名 modify 字段 类型 not null;-- 添加非空约束——方式1-- 方式1，创建表时指定create table t_user6 (\tid int,    name varchar(20) not null,    address varchar(20) not null);-- 添加非空约束——方式2-- 方式2，创建表之后指定create table t_user7 (\tid int,    name varchar(20),    address varchar(20));alter table t_user7 modify name varchar(20) not null;alter table t_user7 modify address varchar(20) not null;-- 实例（插入数据）：insert into t_user6(id) values(1001);  -- 不可以（name，address不能为空）insert into t_user6(id,name,address) values(1001,NULL,NULL);  -- 不可以（同上）insert into t_user6(id,name,address) values(1001,&#x27;NULL&#x27;,&#x27;NULL&#x27;); -- 可以（字符串NULL）insert into t_user6(id,name,address) values(1001,&#x27;&#x27;,&#x27;&#x27;); -- 可以（空串）-- 删除非空约束(可以叫修改)-- alter table 表名 modify 字段 类型;alter table t_user7 modify name varchar(20);alter table t_user7 modify address varchar(20);\n唯一约束(unique)\n概念\n\n唯一约束(Unique)， 是指所有记录中字段的值不能重复出现。例如，为 id 字段加上唯一性约束后，每条记录的 id 值都是唯一的，不能出现重复的情况，但可以为NULL，并且可以有多个NULL。\n\n-- 语法：-- 方式1：&lt;字段名&gt; &lt;数据类型&gt; unique;-- 方式2：alter table 表名 add constraint 约束名 unique(列);-- 添加唯一约束——方式1：-- 创建表时指定create table t_user8 (\tid int,    name varchar(20),    phone_number varchar(20) unique  -- 指定唯一约束);-- 添加唯一约束——方式2：-- 方式2，创建表之后指定create table t_user9 (\tid int,    name varchar(20),    phone_number varchar(20)  -- 指定唯一约束);alter table t_user9 add constraint unique_pn unique(phone_number);-- 删除唯一约束alter table &lt;表名&gt; drop index &lt;唯一约束名&gt;;-- 实例：（如果通过方式1添加的唯一约束，则index后面加上所在列名就行）alter table t_user9 drop index unique_pn;\n默认约束(default)\n概念\n\nMySQL默认值约束用来指定某列的默认值。\n\n-- 语法：-- 方式1：&lt;字段名&gt; &lt;数据类型&gt; default &lt;默认值&gt;;-- 方式2：alter table 表名 modify 列名 类型 default 默认值;-- 添加默认约束——方式1：-- 创建表时指定create table t_user10 (\tid int,    name varchar(20),    address varchar(20) default &#x27;北京&#x27;  -- 指定默认约束);-- 插入数据（未给定地址时，它会默认是北京）insert into t_user10(id,name) values(1001,&#x27;张三&#x27;);insert into t_user10(id,name) values(1002,&#x27;李四&#x27;,&#x27;上海&#x27;);  -- 地址会成为上海insert into t_user10 values(1003,&#x27;王五&#x27;,NULL);   -- 地址会为 NULL-- 添加默认约束——方式2：-- 创建表之后指定create table t_user11 (\tid int,    name varchar(20),    address varchar(20));-- 格式：alter table 表名 modify 列名 类型 default 默认值;alter table t_user11 modify address varchar(20) default &#x27;北京&#x27;;-- 删除默认约束(删除默认约束就是把设置的默认值设置为null)-- alter table &lt;表名&gt; change column &lt;字段名&gt; &lt;类型&gt; default NULL;alter table t_user11 modify address varchar(20) default NULL;\n零填充约束(zerofill)\n概念\n\n插入数据时，当该字段的值的长度小于定义的长度时，会在该值的前面补上相应的0；\nzerofill 默认为 int(10)；\n当使用 zerofill 时，默认会自动加 unsigned（无符号）属性，使用 unsigned 属性后，数值范围时原值的2倍，例如，有符号为 -128~+127，无符号为 0~256.\n\n操作\n-- 语法&lt;字段名&gt; &lt;数据类型&gt; zerofill;create table t_user12 (\tid int zerofill,  -- 零填充约束    name varchar(20));insert into t_user12 values(123,&#x27;张三&#x27;); -- 固定10位，会在前面加7个0insert into t_user12 values(1,&#x27;李四&#x27;);  -- 固定10位，会在前面加9个0-- 删除-- 格式：alter table &lt;表名&gt; modify &lt;字段名&gt; &lt;数据类型&gt;;alter table t_user12 modify id int;\nMySQL数据库基本操作—DQL\n基本介绍\n概念\n\n\n数据库管理系统一个重要功能就是数据查询，数据查询不应只是简单返回数据库中存储的数据，还应该根据需要对数据进行筛选以及确定数据以什么样的格式显示。\nMySQL提供了功能强大、灵活的语句来实现这些操作。\nMySQL数据库使用select语句来查询数据。\n\n\n语法\n-- 格式select  [all|distinct]  &lt;目标列的表达式1&gt; [别名],  &lt;目标列的表达式2&gt; [别名]...from &lt;表名或视图名&gt; [别名], &lt;表名或视图名&gt; [别名]...[where&lt;条件表达式&gt;][group by &lt;列名&gt;[having &lt;条件表达式&gt;]][order by &lt;列名&gt; [asc|desc]][limit &lt;数字或者列表&gt;];-- 解释以上SELECT\t字段列表FROM\t表名列表WHERE\t条件列表GROUP BY\t分组字段列表HAVING\t分组后条件列表ORDER BY\t排序字段列表LIMIT\t分页参数-- 简化版语法select *| 列名 from 表 where 条件;\t\n\n我们在讲解这部分内容的时候，会将上面的完整语法进行拆分，分为以下几个部分：\n\n基本查询（不带任何条件）\n条件查询（WHERE）\n聚合函数（count、max、min、avg、sum）\n分组查询（group by）\n排序查询（order by）\n分页查询（limit）\n\n\n基本查询—数据准备\n以下是一个基础例子：\n\n\n创建数据库和表（商品表）：\n-- 创建数据库create database if not exists mydb2;use mydb2;-- 创建商品表：create table product (\tpid int primary key auto_increment,  -- 商品编号    pname varchar(20) not null,  -- 商品名称    price double,  -- 商品价格    category_id varchar(20)  -- 商品所属分类);\n\n\n添加数据：\n-- 电器类（c001）：insert into product values(null,&#x27;海尔洗衣机&#x27;,5000,&#x27;c001&#x27;);insert into product values(null,&#x27;美的冰箱&#x27;,3000,&#x27;c001&#x27;);insert into product values(null,&#x27;格力空调&#x27;,5000,&#x27;c001&#x27;);insert into product values(null,&#x27;九阳电饭煲&#x27;,5000,&#x27;c001&#x27;);-- 服装类（c002）：insert into product values(null,&#x27;啄木鸟衬衣&#x27;,300,&#x27;c002&#x27;);insert into product values(null,&#x27;恒源祥西裤&#x27;,800,&#x27;c002&#x27;);insert into product values(null,&#x27;花花公子夹克&#x27;,440,&#x27;c002&#x27;);insert into product values(null,&#x27;劲霸休闲裤&#x27;,266,&#x27;c002&#x27;);insert into product values(null,&#x27;海澜之家卫衣&#x27;,180,&#x27;c002&#x27;);insert into product values(null,&#x27;杰克琼斯运动裤&#x27;,430,&#x27;c002&#x27;);-- 护肤品类（c003）：insert into product values(null,&#x27;兰蔻面霜&#x27;,300,&#x27;c003&#x27;);insert into product values(null,&#x27;雅诗兰黛精华水&#x27;,200,&#x27;c003&#x27;);insert into product values(null,&#x27;香奈儿香水&#x27;,350,&#x27;c003&#x27;);insert into product values(null,&#x27;SK-II神仙水&#x27;,350,&#x27;c003&#x27;);insert into product values(null,&#x27;资生堂粉底液&#x27;,180,&#x27;c003&#x27;);-- 食品类（c004）：insert into product values(null,&#x27;老北京方便面&#x27;,56,&#x27;c004&#x27;);insert into product values(null,&#x27;良品铺子海带丝&#x27;,17,&#x27;c004&#x27;);insert into product values(null,&#x27;三只松鼠坚果&#x27;,88,&#x27;c004&#x27;);\n\n\n基本查询—简单查询\n-- 1.查询所有的商品select * from product;-- 2.查询商品名和商品价格select pname,price from product;-- 3.别名查询.使用的关键字是as（as可以省略的）-- 3.1表别名：select * from product as p;-- 别名在多表查询时可以起到简化作用，例如：select p.id,u.id from product as p, user1 as u;-- 3.2列别名（商品名）：select pname as pn from product;-- 4.去掉重复值（商品价格）select distinct price from product;-- 5.查询结果是表达式（运算查询）：将商品名和所有商品的价格+10元进行显示select pname,price+10 from product;\n基本查询—运算符\n简介\n数据库中的表结构确立后，表中的数据代表的意义就已经确定。通过MySQL运算符进行运算，就可以获取到表结构以外的另一种数据。\n例如，学生表中存在一个birth字段，这个字段表示学生的出 年份。 运 MySQL的算术运算符用当前的年份减学生出生的年份，那么得到的就是这个学生的实际年龄数据。\n\nMySQL支持4种运算符\n\n算术运算符\n比较运算符\n逻辑运算符\n位运算符\n\n\n算术运算符\n\n\n\n算术运算符\n说明\n\n\n\n\n+\n加法运算\n\n\n-\n减法运算\n\n\n*\n乘法运算\n\n\n/ 或 DIV\n除法运算，返回商\n\n\n% 或 MOD\n求余运算，返回余数\n\n\n\n比较运算符\n\n\n\n比较运算符\n说明\n\n\n\n\n=\n等于\n\n\n&lt; 和 &lt;=\n小于和小于等于\n\n\n&gt; 和 &gt;=\n大于和大于等于\n\n\n&lt;=&gt;\n完全的等于，两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0\n\n\n&lt;&gt; 或 !=\n不等于\n\n\nIS NULL 或 ISNULL\n判断一个值是否为NULL\n\n\nIS NOT NULL\n判断一个值是否不为NULL\n\n\nLEAST\n当有两个或多个参数时，返回最小值\n\n\nGREATEST\n当有两个或多个参数时，返回最大值\n\n\nBETWEEN AND\n判断一个值是否落在两个值之间\n\n\nIN\n判断一个值是IN列表中的任意一个值\n\n\nNOT IN\n判断一个值不是IN列表中的任意一个值\n\n\nLIKE\n通配符匹配(包括 % 和 _ ，%表示多个匹配，_ 表示单个匹配)\n\n\nREGEXP\n正则表达式匹配\n\n\n\n逻辑运算符\n\n\n\n逻辑运算符\n说明\n\n\n\n\nNOT 或者 !\n逻辑非\n\n\nAND 或者 &amp;&amp;\n逻辑与\n\n\nOR 或者 ||\n逻辑或\n\n\nXOR\n逻辑异或\n\n\n\n位运算符\n\n\n\n位运算符\n说明\n\n\n\n\n!\n按位或\n\n\n&amp;\n按位与\n\n\n^\n按位异或\n\n\n&lt;&lt;\n按位左移\n\n\n&gt;&gt;\n按位右移\n\n\n~\n按位取反，反转所有比特\n\n\n\n\n位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。\n\n运算符操作\n算术运算符\nuse mydb2;select 6 + 2;select 6 - 2;select 6 * 2;select 6 / 2;select 6 % 2;-- 将每件商品的价格加10select name,price + 10 as new_price from product;-- 将所有商品的价格上调10%select pname,price * 1.1 as new_price from product;\n比较运算符\n-- 更新pid为18的category_id为nullupdate product set category_id = null where pid = 18;-- 比较运算符——条件查询-- 查询商品名称为“海尔洗衣机”的商品所有信息：select * from product where pname = &#x27;海尔洗衣机&#x27;;-- 查询价格为800的商品select * from product where price = 800;-- 查询价格不是800的所有商品(三种方法)select * from product where price != 800;select * from product where price &lt;&gt; 800;select * from product where not(price = 800);-- 查询商品价格大于60元的所有商品信息select * from product where price &gt; 60;-- 查询商品价格在200到1000之间所有商品(三种方法)select * from product where price &gt;= 200 and price &lt;= 1000;select * from product where price &gt;= 200 &amp;&amp; price &lt;= 1000;select * from product where price between 200 and 1000;-- 查询商品价格是200或800的所有商品(三种方法)select * from product where price = 200 or price = 800;select * from product where price = 200 || price = 800;select * from product where price in(200, 800);-- 查询含有‘裤&#x27;字的所有商品select * from product where pname like &#x27;%裤%&#x27;;-- 查询以&#x27;海&#x27;开头的所有商品select * from product where pname like &#x27;海%&#x27;;-- 查询第二个字为&#x27;蔻&#x27;的所有商品select * from product where pname like &#x27;_蔻%&#x27;;-- 查询category_id为null的商品select * from product where category_id is null;-- 查询category_id不为null分类的商品select * from product where category_id is not null;-- 使用least求最小值(可以结合表来查询)select least(10, 20, 30) as small_number; -- 10select least(10, null , 30); -- null -- 使用greatest求最大值select greatest(10, 20, 30) as big_number;  -- 30select greatest(10, null, 30); -- null\n位运算符（了解）\n\n位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。\n\nselect 3 &amp; 5;  -- 位与select 3 | 5;  -- 位或select 3 ^ 5;  -- 位异或select 3 &gt;&gt; 1;  -- 位右移select 3 &lt;&lt; 1;  -- 位左移select ~ 3;   -- 位取反\n基本查询—排序查询\n介绍\n\n如果我们需要对读取的数据进行排序，我们就可以使用MySQL的 order by 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。\n\n-- 语法格式：select \t字段名1, 字段名2, ……from 表名order by 字段名1 [asc|desc], 字段名2[asc|desc] ……;\n特点\n\n\nasc代表升序，desc代表降序，如果不写默认升序；\norder by用于子句中可以支持单个字段，多个字段，表达式，函数，别名；\norder by子句，放在查询语句的最后面。LIMIT子句除外。\n\n\n操作\n-- 1.使用价格排序（降序）select * from product order by price desc;-- 2.在价格排序（降序）的基础上，以分类排序（降序）select * from product order by price desc, category_id desc;-- 3.显示商品的价格（去重复），并排序（降序）select distinct price from product order by price desc;\n基本查询—聚合查询\n简介\n\n之前我们做的查询都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，它是对一列的值进行计算，然后返回一个单一的值；另外聚合函数会忽略空值。\n\n\n\n\n聚合函数\n作用\n\n\n\n\ncount()\n统计指定列不为NULL的记录行数；\n\n\nsum()\n计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；\n\n\nmax()\n计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；\n\n\nmin()\n计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；\n\n\navg()\n计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0\n\n\n\n操作\n-- 1 查询商品的总条数select count(*) from product;-- 2 查询价格大于200商品的总条数select count(*) from product where price &gt; 200;-- 3 查询分类为&#x27;c001&#x27;的所有商品的总和select sum(price) from product where category_id = &#x27;c001&#x27;;-- 4 查询商品的最大价格select max(price) from product;-- 5 查询商品的最小价格select min(price) from product;-- 6 查询分类为&#x27;c002&#x27;所有商品的平均价格select avg(price) from product where category_id = &#x27;c002&#x27;;-- 7 查询商品的最大和最小价格,并分别命名为 max_price 和 min_price :select max(price) max_price, min(price) min_price from product;\nNULL值的处理\n介绍\n\n\n\ncount函数对null值的处理：\n如果count函数的参数为星号（*），则统计所有记录的个数。而如果参数为某字段，不统计含null值的记录个数。\n\n\nsum和avg函数对null值的处理：\n这两个函数忽略null值的存在，就好像该条记录不存在一样。\n\n\nmax和min函数对null值的处理：\nmax和min两个函数同样忽略null值的存在。\n\n\n\n操作\n-- 创建表create table test_null (\tc1 varchar(20),    c2 int);-- 插入数据insert into test_null values(&#x27;aaa&#x27;,3);insert into test_null values(&#x27;bbb&#x27;,3);insert into test_null values(&#x27;ccc&#x27;,null);insert into test_null values(&#x27;ddd&#x27;,6);-- 测试-- SELECT COUNT(*)和 SELECT COUNT(1)  是一个意思select count(*), count(1), count(c2) from test_null;select sum(c2),max(c2),min(c2),avg(c2) from test_null;\n基本查询—分组查询—group by\n简介\n\n分组查询是指使用group by字句对查询信息进行分组。\n\n-- 格式：select 字段1，字段2…… from 表名 group by 分组字段 having 分组条件;-- 操作-- 1、统计各个分类商品的个数(注意：分组之后select的后边只能写分组字段和聚合函数)select category_id,count(*) from product group by category_id;-- group by可以指定多个分组字段；假如有三个分组字段，则筛选时必须三个分组字段一致才会分到一起（不分先后）。-- 例如：学生表，有： 学号  名字  年龄  省  市  县；（分组字段可不分先后）select from product group by 市, 省, 县;  -- 筛查结果为同一个省市县的分到一起并统计个数\n\n如果要进行分组的话，则select子句之后，只能出现分组的字段和统计函数，其他的字段不能出现；\n\n分组之后的条件筛选—having\n\n\n分组之后对统计结果进行筛选的话必须使用having，不能使用where；\nwhere子句用来筛选FROM子句中指定的操作所产生的行；\ngroup by 子句用来分组where子句的输出；\nhaving 子句用来从分组的结果中筛选行。\n\n\n-- 格式select 字段1, 字段2… from 表名 group by 分组字段 having 分组条件;-- 操作-- 2.统计各个分类商品的个数，且只显示个数大于4的信息select category_id, count(*) from product group by category_id having count(*) &gt; 4;\n基本查询—分页查询—limit\n简介\n分页查询在项目开发中常见，由于数据量很大，显示屏长度有限，因此对数据需要采取分页显示方式。例如数据共有30条，每页显示5条，第一页显示1-5条，第二页显示6-10条。\n格式\n-- 方式1——显示前n条select 字段1, 字段2… from 表名 limit n;-- 方式2——分页显示select 字段1, 字段2… from 表名 limit m,n;m：整数，表示从第几条索引开始，计算方式（当前页-1）*每页显示条数n：整数，表示查询多少条数据\n操作\n-- 查询product表的前5条记录select * from product limit 5;-- 从第4条开始显示，显示5条select * from product limit 3,5;\n基本查询—INSERT INTO SELECT语句\n简介\n\n将一张表的数据导入到另一张表中，可以使用INSERT INTO SELECT语句 。\n\n格式\ninsert into Table2(field1, field2) select value1, value2,… from Table1;或者：insert into Table2 select * from Table1;注意：要求目标表Table2必须存在\n操作\n-- 实例-- 创建表名为product2的表(要与表1中的字段名一致)create table product2 (\tpname varchar(20),    price double);-- 从表1将数据插入到表2（pname，price）insert into product2(pname,price) select pname,price from product;-- 检查是否成功插入select * from product2;\nSELECT INTO FROM语句\n简介\n\n将一张表的数据导入到另一张表中，有两种选择 SELECT INTO 和 INSERT INTO SELECT 。\n\n格式\nselect value1, value2 into Table2 from Table1;\n\n注意： 要求目标表Table2不存在，因为在插入时会自动创建表Table2，并将Table1中指定字段数据复制到Table2中。\n\n操作\nselect pname,price into product3 from product;\n练习1\n-- 选择数据库use mydb2;-- 创建学生表create table student (\tid int,    name varchar(20),    gender varchar(20),    chinese int,    english int,    math int);-- 插入数据insert into student(id,name,gender,chinese,english,math) values(1,&#x27;张明&#x27;,&#x27;男&#x27;,89,78,90);insert into student(id,name,gender,chinese,english,math) values(2,&#x27;李进&#x27;,&#x27;男&#x27;,67,53,95);insert into student(id,name,gender,chinese,english,math) values(3,&#x27;王五&#x27;,&#x27;女&#x27;,87,78,77);insert into student(id,name,gender,chinese,english,math) values(4,&#x27;李一&#x27;,&#x27;女&#x27;,88,98,92);insert into student(id,name,gender,chinese,english,math) values(5,&#x27;李财&#x27;,&#x27;男&#x27;,82,84,67);insert into student(id,name,gender,chinese,english,math) values(6,&#x27;张宝&#x27;,&#x27;男&#x27;,55,85,45);insert into student(id,name,gender,chinese,english,math) values(7,&#x27;黄蓉&#x27;,&#x27;女&#x27;,75,65,30);insert into student(id,name,gender,chinese,english,math) values(7,&#x27;黄蓉&#x27;,&#x27;女&#x27;,75,65,30);-- 查询数据-- 1.查询表中所有学生的信息。select * from student;-- 2.查询表中所有学生的姓名和对应的英语成绩。select name,english from student;-- 3.过滤表中重复数据。select distinct * from student;-- 4.统计每个学生的总分。select name,(chinese + english + math) as total_score from student;-- 5.在所有学生总分数上加10分特长分。select name,(chinese + english + math)+10 as total_score from student;-- 6.使用别名表示学生分数。select name,chinese &#x27;语文成绩&#x27;, english &#x27;英语成绩&#x27;, math &#x27;数学成绩&#x27; from student;-- 7.查询英语成绩大于90分的同学。select * from student where english &gt; 90;-- 8.查询总分大于200分的所有同学。select *,(chinese + english + math) as total_score from student where (chinese + english + math) &gt; 200;-- 9.查询英语分数在80-90之间的同学。(两种方法)select * from student where english between 80 and 90;select * from student where english &gt;= 80 and english &lt;= 90;-- 10.查询英语成绩不在80-90之间的同学。(四种方法)select * from student where not (english between 80 and 90);select * from student where english not between 80 and 90;select * from student where not (english &gt;= 80 and english &lt;= 90);select * from student where english &lt; 80 || english &gt; 90;-- 11.查询数学分数为89,90,91的同学。select * from student where math in(89,90,91);-- 12.查询数学分数不为89,90,91的同学。select * from student where math not in(89,90,91);select * from student where not math in(89,90,91);-- 13.查询所有姓李的学生英语成绩。select name,english from student where name like &#x27;李%&#x27;;-- 14.查询数学分80并且语文分80的同学。select * from student where math = 80 and chinese = 80;-- 15.查询英语80或者总分200的同学。select * from student where english = 80 or (chinese + english + math) = 200;-- 16.对数学成绩降序排序后输出。select * from student order by math desc;-- 17.对总分排序后输出，然后再按从高到低的顺序输出。select *,(chinese + english + math) as total_score from student order by (chinese + english + math) desc;-- 18.对姓李的学生总分成绩降序排序输出。select *,(chinese + english + math) as total_score from student where name like &#x27;李%&#x27; order by (chinese + english + math) desc;-- 19.查询男生和女生分别有多少人，并将人数降序排序输出。select gender,count(*) as total_count from student group by gender order by total_count desc;-- 20.查询男生和女生分别有多少人，并将人数降序排序输出,查询出人数大于等于4的性别人数信息。select gender,count(*) as total_count from student group by gender having total_count &gt;= 4 order by total_count desc;\n练习2\n-- 选择mydb2数据库use mydb2;-- 创建工资表create table emp (\tempno int,     -- 员工编号    ename varchar(50),  -- 员工名字    job varchar(50),  -- 工作名字    mgr int,     -- 上级领导编号    hiredate date,  -- 入职日期    sal int,       -- 薪资    comm int,      -- 奖金    deptno int     -- 部门编号);-- 插入数据insert into emp values(7369,&#x27;SMITH&#x27;,&#x27;CLERK&#x27;,7902,&#x27;1980-12-17&#x27;,800,NULL,20);insert into emp values(7499,&#x27;ALLEN&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-02-20&#x27;,1600,300,30);insert into emp values(7521,&#x27;WARD&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-02-22&#x27;,1250,500,30);insert into emp values(7566,&#x27;JONES&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-04-02&#x27;,2975,NULL,20);insert into emp values(7654,&#x27;MARTIN&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-09-28&#x27;,1250,1400,30);insert into emp values(7698,&#x27;BLAKE&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-05-01&#x27;,2850,NULL,30);insert into emp values(7782,&#x27;CLARK&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-06-09&#x27;,2450,NULL,10);insert into emp values(7788,&#x27;SCOTT&#x27;,&#x27;ANALYST&#x27;,7566,&#x27;1987-04-19&#x27;,3000,NULL,20);insert into emp values(7839,&#x27;KING&#x27;,&#x27;PRESIDENT&#x27;,NULL,&#x27;1981-11-17&#x27;,5000,NULL,10);insert into emp values(7844,&#x27;TURNER&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-09-08&#x27;,1500,0,30);insert into emp values(7876,&#x27;ADAMS&#x27;,&#x27;CLERK&#x27;,7788,&#x27;1987-05-23&#x27;,1100,NULL,20);insert into emp values(7900,&#x27;JAMES&#x27;,&#x27;CLERK&#x27;,7698,&#x27;1981-12-03&#x27;,950,NULL,30);insert into emp values(7902,&#x27;FORD&#x27;,&#x27;ANALYST&#x27;,7566,&#x27;1981-12-03&#x27;,3000,NULL,20);insert into emp values(7934,&#x27;MTLLER&#x27;,&#x27;CLERK&#x27;,7782,&#x27;1982-1-23&#x27;,1300,NULL,10);-- 查询数据-- 1、按员工编号升序排列不在10号部门工作的员工信息。（两种方法）select * from emp where deptno not in(10) order by empno;select * from emp where deptno != 10 order by empno;-- 2、查询姓名第二个字母不是“A”且薪水大于1000元的员工信息，按年薪降序排列。select *,(sal * 12 + ifnull(comm,0)) yearly from emp where ename not  like &#x27;_A%&#x27; and sal &gt; 1000 order by (sal * 12 + ifnull(comm,0)) desc;-- 3、求每个部门的平均薪水,并按平均薪水降序排序。select deptno,avg(sal) as avg_sal from emp group by deptno order by avg_sal desc;-- 4、求各个部门的最高薪水。select deptno,max(sal) as max_sal from emp group by deptno;-- 5、求每个部门每个岗位的最高薪水并按部门排序。select deptno,job,max(sal) from emp group by deptno,job order by deptno;-- 6、求平均薪水大于2000的部门编号。select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000;-- 7、将部门平均薪水大于1500的部门编号列出来，按部门平均薪水降序排列。select deptno,avg(sal) avg_sal from emp group by deptno having avg(sal) &gt; 1500 order by avg_sal desc;-- 8、选择公司中有奖金的员工姓名，工资。select ename,sal,comm from emp where comm is not null;-- 9、查询员工最高工资和最低工资的差距。select max(sal) - min(sal) &#x27;薪资差距&#x27; from emp;\n正则表达式\n介绍\n\n​\t正则表达式(regular expression)描述了一种字符串匹配的规则，正则表达式本身就是一个字符串，使用这个字符串来描述、用来定义匹配规则，匹配一系列符合某个句法规则的字符串。在开发中，正则表达式通常被用来检索、替换那些符合某个规则的文本。\n​\tMySQL通过REGEXP关键字支持正则表达式进行字符串匹配。\n\n格式\n\n\n\n模式\n描述\n\n\n\n\n^\n匹配输入字符串的开始位置。\n\n\n$\n匹配输入字符串的结束位置。\n\n\n.\n匹配除&quot;\\n&quot;之外的任何某个字符。\n\n\n[…]\n字符集合。匹配所包含的任意一个字符。例如，'[abc]‘可以匹配&quot;plain&quot;中的’a’。\n\n\n[^…]\n负值字符集合。匹配未包含的任意字符。例如，'[^abc]‘可以匹配&quot;plain&quot;中的’p’。\n\n\np1|p2|p3\n匹配p1或p2或p3。例如，‘z|food’能匹配&quot;z&quot;或&quot;food&quot;。’(z|f)ood’则匹配&quot;zood&quot;或&quot;food&quot;。\n\n\n*\n匹配前面的子表达式零次或多次。例如，&quot;zo*“能匹配&quot;z&quot;以及&quot;zoo”。 * 等价于{0,}。\n\n\n+\n匹配前面的子表达式一次或多次。例如，“zo+“能匹配&quot;zo&quot;以及&quot;zoo”，但不能匹配&quot;z”。+ 等价于 {1,}。\n\n\n{n}\nn 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。\n\n\n{n,m}\nm 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。\n\n\n\n正则表达式匹配查询\n操作上\n-- ^ 在字符串开始处进行匹配SELECT  &#x27;abc&#x27; REGEXP &#x27;^a&#x27;; -- $ 在字符串末尾开始匹配SELECT  &#x27;abc&#x27; REGEXP &#x27;a$&#x27;;SELECT  &#x27;abc&#x27; REGEXP &#x27;c$&#x27;;-- . 匹配任意字符SELECT  &#x27;abc&#x27; REGEXP &#x27;.b&#x27;;SELECT  &#x27;abc&#x27; REGEXP &#x27;.c&#x27;;SELECT  &#x27;abc&#x27; REGEXP &#x27;a.&#x27;; -- [...] 匹配括号内的任意单个字符SELECT  &#x27;abc&#x27; REGEXP &#x27;[xyz]&#x27;;SELECT  &#x27;abc&#x27; REGEXP &#x27;[xaz]&#x27;;-- [^...] 注意^符合只有在[]内才是取反的意思，在别的地方都是表示开始处匹配SELECT  &#x27;a&#x27; REGEXP &#x27;[^abc]&#x27;;SELECT  &#x27;x&#x27; REGEXP &#x27;[^abc]&#x27;;SELECT  &#x27;abc&#x27; REGEXP &#x27;[^a]&#x27;; -- a* 匹配0个或多个a,包括空字符串。 可以作为占位符使用.有没有指定字符都可以匹配到数据 SELECT &#x27;stab&#x27; REGEXP &#x27;.ta*b&#x27;;SELECT &#x27;stb&#x27; REGEXP &#x27;.ta*b&#x27;;SELECT &#x27;&#x27; REGEXP &#x27;a*&#x27;; -- a+  匹配1个或者多个a,但是不包括空字符SELECT &#x27;stab&#x27; REGEXP &#x27;.ta+b&#x27;;SELECT &#x27;stb&#x27; REGEXP &#x27;.ta+b&#x27;;\n操作下\n-- a?  匹配0个或者1个aSELECT &#x27;stb&#x27; REGEXP &#x27;.ta?b&#x27;;SELECT &#x27;stab&#x27; REGEXP &#x27;.ta?b&#x27;;SELECT &#x27;staab&#x27; REGEXP &#x27;.ta?b&#x27;; -- a1|a2  匹配a1或者a2，SELECT &#x27;a&#x27; REGEXP &#x27;a|b&#x27;;SELECT &#x27;b&#x27; REGEXP &#x27;a|b&#x27;;SELECT &#x27;b&#x27; REGEXP &#x27;^(a|b)&#x27;;SELECT &#x27;a&#x27; REGEXP &#x27;^(a|b)&#x27;;SELECT &#x27;c&#x27; REGEXP &#x27;^(a|b)&#x27;; -- a&#123;m&#125; 匹配m个aSELECT &#x27;auuuuc&#x27; REGEXP &#x27;au&#123;4&#125;c&#x27;;SELECT &#x27;auuuuc&#x27; REGEXP &#x27;au&#123;3&#125;c&#x27;; -- a&#123;m,n&#125; 匹配m到n个a,包含m和nSELECT &#x27;auuuuc&#x27; REGEXP &#x27;au&#123;3,5&#125;c&#x27;;SELECT &#x27;auuuuc&#x27; REGEXP &#x27;au&#123;4,5&#125;c&#x27;;SELECT &#x27;auuuuc&#x27; REGEXP &#x27;au&#123;5,10&#125;c&#x27;; -- (abc) abc作为一个序列匹配，不用括号括起来都是用单个字符去匹配，如果要把多个字符作为一个整体去匹配就需要用到括号，所以括号适合上面的所有情况。SELECT &#x27;xababy&#x27; REGEXP &#x27;x(abab)y&#x27;;SELECT &#x27;xababy&#x27; REGEXP &#x27;x(ab)*y&#x27;;SELECT &#x27;xababy&#x27; REGEXP &#x27;x(ab)&#123;1,2&#125;y&#x27;;\n多表操作\n介绍\n\n​\t实际开发中，一个项目通常需要很多张表才能完成。例如：一个商城项目就需要分类表(category)、商品表(products)、订单表(orders)等多张表。且这些表的数据之间存在一定的关系，接下来我们将在单表的基础上，一起学习多表方面的知识。\n\n多表关系\n\nMySQL多表之间的关系可以概括为：一对一、一对多/多对一关系，多对多\n\n一对一关系\n\n\n一个学生只有一张身份证；一张身份证只能对应一学生。\n在任一表中添加唯一外键，指向另一方主键，确保一对一关系。\n一般一对一关系很少见，遇到一对一关系的表最好是合并表。\n\n\n\n一对多/多对一关系\n\n\n部门和员工：\n分析：一个部门有多个员工，一个员工只能对应一个部门；\n实现原则：在多的一方建立外键，指向一的一方的主键。\n\n\n\n多对多关系\n\n\n学生和课程：\n分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择；\n原则：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，将多对多的关系，拆成一对多的关系，中间表至少要有两个外键，这两个外键分别指向原来的那两张表的主键。\n​\t注：多对多的关系需要一个中间表作为桥梁\n\n\n\n外键约束—概念\n介绍\n\nMySQL 外键约束（FOREIGN KEY）是表的一个特殊字段，经常与主键约束一起使用。对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）。\n外键用来建立主表与从表的关联关系，为两个表的数据建立连接，约束两个表中数据的一致性和完整性。比如，一个水果摊，只有苹果、桃子、李子、西瓜等 4 种水果，那么，你来到水果摊要买水果就只能选择苹果、桃子、李子和西瓜，其它的水果都是不能购买的。\n\n\n特点\n\n定义一个外键时，需要遵守下列规则：\n\n\n主表必须已经存在于数据库中，或者是当前正在创建的表。\n\n\n必须为主表定义主键。\n\n\n​    主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这 个外键的内容就是正确的。\n\n\n在主表的表名后面指定列名或列名的组合。这个列或列的组合必须是主表的主键或候选键。\n\n\n外键中列的数目必须和主表的主键中列的数目相同。\n\n\n外键中列的数据类型必须和主表主键中对应列的数据类型相同。\n\n\n\n外键约束—一对多关系\n操作-创建外键约束\n方式1-在创建表时设置外键约束\n在 create table 语句中，通过 foreign key 关键字来指定外键，具体的语法格式如下：\n[constraint &lt;外键名&gt;] foreign key 字段名 [，字段名2，…] references &lt;主表名&gt; 主键列1 [，主键列2，…];\n实现：\ncreate database mydb3; use mydb3;-- 创建部门表create table if not exists dept(  deptno varchar(20) primary key,  -- 部门号  name varchar(20) -- 部门名字);-- 创建员工表create table if not exists emp(  eid varchar(20) primary key , -- 员工编号  ename varchar(20), -- 员工名字  age int,  -- 员工年龄  dept_id varchar(20),  -- 员工所属部门  constraint emp_fk foreign key (dept_id) references dept (deptno)         -- 外键约束);\n\n方式2-在创建表时设置外键约束\n\n外键约束也可以在修改表时添加，但是添加外键约束的前提是：从表中外键列中的数据必须与主表中主键列中的数据一致或者是没有数据。\n\nalter table &lt;数据表名&gt; add constraint &lt;外键名&gt; foreign key(&lt;列名&gt;) references &lt;主表名&gt; (&lt;列名&gt;);\n实现：\n-- 创建部门表create table if not exists dept2(  deptno varchar(20) primary key ,  -- 部门号  name varchar(20) -- 部门名字);-- 创建员工表create table if not exists emp2(  eid varchar(20) primary key , -- 员工编号  ename varchar(20), -- 员工名字  age int,  -- 员工年龄  dept_id varchar(20)  -- 员工所属部门);-- 创建外键约束alter table emp2 add constraint dept_id_fk foreign key(dept_id) references dept2 (deptno);\n\n操作-在外键约束下的数据操作\n验证外键约束的作用\n1、数据插入\n-- 1、添加主表数据 -- 注意必须先给主表添加数据insert into dept values(&#x27;1001&#x27;,&#x27;研发部&#x27;);insert into dept values(&#x27;1002&#x27;,&#x27;销售部&#x27;);insert into dept values(&#x27;1003&#x27;,&#x27;财务部&#x27;);insert into dept values(&#x27;1004&#x27;,&#x27;人事部&#x27;);-- 2、添加从表数据  -- 注意给从表添加数据时，外键列的值不能随便写，必须依赖主表的主键列insert into emp values(&#x27;1&#x27;,&#x27;乔峰&#x27;,20, &#x27;1001&#x27;);insert into emp values(&#x27;2&#x27;,&#x27;段誉&#x27;,21, &#x27;1001&#x27;);insert into emp values(&#x27;3&#x27;,&#x27;虚竹&#x27;,23, &#x27;1001&#x27;);insert into emp values(&#x27;4&#x27;,&#x27;阿紫&#x27;,18, &#x27;1002&#x27;);insert into emp values(&#x27;5&#x27;,&#x27;扫地僧&#x27;,35, &#x27;1002&#x27;);insert into emp values(&#x27;6&#x27;,&#x27;李秋水&#x27;,33, &#x27;1003&#x27;);insert into emp values(&#x27;7&#x27;,&#x27;鸠摩智&#x27;,50, &#x27;1003&#x27;); insert into emp values(&#x27;8&#x27;,&#x27;天山童姥&#x27;,60, &#x27;1005&#x27;);  -- 不可以\n2、删除数据\n-- 3、删除数据 /*   注意：       1：主表的数据被从表依赖时，不能删除，否则可以删除       2: 从表的数据可以随便删除 */delete from dept where deptno = &#x27;1001&#x27;; -- 不可以删除delete from dept where deptno = &#x27;1004&#x27;; -- 可以删除delete from emp where eid = &#x27;7&#x27;; -- 可以删除\n操作-删除外键约束\n\n当一个表中不需要外键约束时，就需要从表中将其删除。外键一旦删除，就会解除主表和从表间的关联关系\n\n格式：\nalter table &lt;表名&gt; drop foreign key &lt;外键约束名&gt;;\n实现：\nalter table emp2 drop foreign key dept_id_fk;\n外键约束-多对多关系\n介绍\n\n在多对多关系中，A表的一行对应B的多行，B表的一行对应A表的多行，我们要新增加一个中间表，来建立多对多关系。\n\n\n操作\n-- 选择mydb3数据库use mydb3;-- 学生表和课程表(多对多)  -- 1 创建学生表student(左侧主表)   create table if not exists student(    sid int primary key auto_increment,    name varchar(20),    age int,    gender varchar(20)   );  -- 2 创建课程表course(右侧主表)  create table course(   cid  int primary key auto_increment,   cidname varchar(20)  );-- 3创建中间表student_course/score(从表)  create table score(    sid int,    cid int,    score double  );    -- 4建立外键约束(2次) alter table score add foreign key(sid) references student(sid);alter table score add foreign key(cid) references course(cid); -- 5给学生表添加数据insert into student values(1,&#x27;小龙女&#x27;,18,&#x27;女&#x27;),(2,&#x27;阿紫&#x27;,19,&#x27;女&#x27;),(3,&#x27;周芷若&#x27;,20,&#x27;男&#x27;);-- 6给课程表添加数据insert into course values(1,&#x27;语文&#x27;),(2,&#x27;数学&#x27;),(3,&#x27;英语&#x27;);-- 7给中间表添加数据insert into score values(1,1,78),(1,2,75),(2,1,88),(2,3,90),(3,2,80),(3,3,65);\n\n注意：修改和删除时，中间从表可以随便删除和修改，但是两边的主表受从表依赖的数据不能删除或者修改。\n\n多表联合查询\n介绍\n\n多表查询就是同时查询两个或两个以上的表，因为有的时候用户在查看数据的时候,需要显示的数据来自多张表。\n\n多表查询有以下分类：\n交叉连接查询 [产生笛卡尔积，了解]      语法：select * from A,B;  内连接查询(使用的关键字 inner join  -- inner可以省略)    隐式内连接（SQL92标准）：select * from A,B where 条件;    显示内连接（SQL99标准）：select * from A inner join B on 条件;外连接查询(使用的关键字 outer join -- outer可以省略)        左外连接：left outer join            select * from A left outer join B on 条件;        右外连接：right outer join            select * from A right outer join B on 条件;        满外连接: full outer join             select * from A full outer join B on 条件;子查询       select的嵌套表自关联：       将一张表当成多张表来用\n\n准备查询数据\n\n接下来准备多表查询需要数据，注意，外键约束对多表查询并无影响。\n\nuse mydb3;-- 创建部门表create table if not exists dept3(  deptno varchar(20) primary key ,  -- 部门号  name varchar(20) -- 部门名字); -- 创建员工表create table if not exists emp3(  eid varchar(20) primary key , -- 员工编号  ename varchar(20), -- 员工名字  age int,  -- 员工年龄  dept_id varchar(20)  -- 员工所属部门);-- 给dept3表添加数据insert into dept3 values(&#x27;1001&#x27;,&#x27;研发部&#x27;);insert into dept3 values(&#x27;1002&#x27;,&#x27;销售部&#x27;);insert into dept3 values(&#x27;1003&#x27;,&#x27;财务部&#x27;);insert into dept3 values(&#x27;1004&#x27;,&#x27;人事部&#x27;);-- 给emp表添加数据insert into emp3 values(&#x27;1&#x27;,&#x27;乔峰&#x27;,20, &#x27;1001&#x27;);insert into emp3 values(&#x27;2&#x27;,&#x27;段誉&#x27;,21, &#x27;1001&#x27;);insert into emp3 values(&#x27;3&#x27;,&#x27;虚竹&#x27;,23, &#x27;1001&#x27;);insert into emp3 values(&#x27;4&#x27;,&#x27;阿紫&#x27;,18, &#x27;1001&#x27;);insert into emp3 values(&#x27;5&#x27;,&#x27;扫地僧&#x27;,85, &#x27;1002&#x27;);insert into emp3 values(&#x27;6&#x27;,&#x27;李秋水&#x27;,33, &#x27;1002&#x27;);insert into emp3 values(&#x27;7&#x27;,&#x27;鸠摩智&#x27;,50, &#x27;1002&#x27;); insert into emp3 values(&#x27;8&#x27;,&#x27;天山童姥&#x27;,60, &#x27;1003&#x27;);insert into emp3 values(&#x27;9&#x27;,&#x27;慕容博&#x27;,58, &#x27;1003&#x27;);insert into emp3 values(&#x27;10&#x27;,&#x27;丁春秋&#x27;,71, &#x27;1005&#x27;);\n多表联合查询—交叉连接查询\n\n\n交叉连接查询返回被连接的两个表所有数据行的笛卡尔积\n笛卡尔积可以理解为一张表的每一行去和另外一张表的任意一行进行匹配\n假如A表有m行数据，B表有n行数据，则返回m*n行数据\n笛卡尔积会产生很多冗余的数据，后期的其他查询可以在该集合的基础上进行条件筛选\n\n\n格式：\nselect * from 表1,表2,表3….;\n实现：\n-- 交叉连接查询select * from dept3,emp3;\n结果：\n\n多表联合查询—内连接查询\n内连接查询求多张表的交集\n格式\n隐式内连接（SQL92标准）：select * from A,B where 条件; 显示内连接（SQL99标准）：select * from A inner join B on 条件;\n操作\n-- 查询每个部门的所属员工select * from dept3,emp3 where dept3.deptno = emp3.dept_id;select * from dept3 inner join emp3 on dept3.deptno = emp3.dept_id;-- 查询研发部和销售部的所属员工select * from dept3,emp3 where dept3.deptno = emp3.dept_id and name in( &#x27;研发部&#x27;,&#x27;销售部&#x27;);select * from dept3 join emp3 on dept3.deptno = emp3.dept_id and name in( &#x27;研发部&#x27;,&#x27;销售部&#x27;); -- 查询每个部门的员工数,并升序排序select deptno,count(1) as total_cnt from dept3,emp3 where dept3.deptno = emp3.dept_id group by deptno order by total_cnt; select deptno,count(1) as total_cnt from dept3 join emp3 on dept3.deptno = emp3.dept_id group by deptno order by total_cnt;-- 查询人数大于等于3的部门，并按照人数降序排序select deptno,count(1) as total_cnt from dept3,emp3 where dept3.deptno = emp3.dept_id group by deptno having total_cnt &gt;= 3 order by total_cnt desc; select deptno,count(1) as total_cnt from dept3 join emp3 on dept3.deptno = emp3.dept_id group by deptno having total_cnt &gt;= 3 order by total_cnt desc;\n外连接查询\n\n\n外连接分为左外连接（left outer join）、右外连接(right outer join)，满外连接(full outer join)。\n注意：oracle里面有full join,可是在mysql对full join支持的不好。我们可以使用union来达到目的。\n\n\n格式\n左外连接：left outer join            select * from A left outer join B on 条件;  右外连接：right outer join            select * from A right outer join B on 条件;  满外连接: full outer join             select * from A full outer join B on 条件;\n操作\n-- 外连接查询-- 查询哪些部门有员工，哪些部门没有员工use mydb3;select * from dept3 left outer join emp3 on dept3.deptno = emp3.dept_id; -- 查询哪些员工有对应的部门，哪些没有select * from dept3 right outer join emp3 on dept3.deptno = emp3.dept_id;  -- 使用union关键字实现左外连接和右外连接的并集（union后使用all代表不去重，不用代表去重）select * from dept3 left outer join emp3 on dept3.deptno = emp3.dept_idunion select * from dept3 right outer join emp3 on dept3.deptno = emp3.dept_id;\n子查询\n介绍\n\n子查询就是指的在一个完整的查询语句之中，嵌套若干个不同功能的小查询，从而一起完成复杂查询的一种编写形式，通俗一点就是包含select嵌套的查询。\n\n特点\n\n子查询可以返回的数据类型一共分为四种：\n\n单行单列：返回的是一个具体列的内容，可以理解为一个单值数据；\n单行多列：返回一行数据中多个列的内容；\n多行单列：返回多行记录之中同一列的内容，相当于给出了一个操作范围；\n多行多列：查询返回的结果是一张临时表\n\n\n操作\n-- 查询年龄最大的员工信息，显示信息包含员工号、员工名字，员工年龄-- 1：查询最大年龄：select max(age) from emp3;-- 2：让每一个员工的年龄和最大年龄进行比较，相等则满足条件(嵌套查询也称子查询)select eid,ename,age from emp3 where age = (select max(age) from emp3);  -- 单行单列，可以作为一个值来用 -- 查询年研发部和销售部的员工信息，包含员工号、员工名字-- 方式1-关联查询select * from dept3 a join emp3 b on a.deptno = b.dept_id and (name = &#x27;研发部&#x27; or name = &#x27;销售部&#x27;);-- 方式2-子查询-- 2.1 先查询研发部和销售部的部门号：deptno 1001 和 1002select deptno from dept3 where name = &#x27;研发部&#x27; or name = &#x27;销售部&#x27;;-- 2.2 查询哪个员工的部门号是1001 或者 1002select * from emp3 where dept_id in (select deptno from dept3 where name = &#x27;研发部&#x27; or name = &#x27;销售部&#x27;);  -- 多行单列，多个值 -- 查询研发部20岁以下的员工信息,包括员工号、员工名字，部门名字-- 方式1-关联查询select * from dept3 a join emp3 b on a.deptno = b.dept_id and (name = &#x27;研发部&#x27; and age &lt; 20);-- 方式2-子查询-- 2.1 在部门表中查询研发部信息select * from dept3 where name = &#x27;研发部&#x27;;  -- 单行多列-- 2.2 在员工表中查询年龄小于20岁的员工信息select * from emp3 where age &lt; 20;-- 2.3 将以上两个查询的结果进行关联查询select * from (select * from dept3 where name = &#x27;研发部&#x27;) t1 join (select * from emp3 where age &lt;20) t2 on t1.deptno = t2.dept_id;  -- 多行多列\n子查询关键字\n介绍\n\n在子查询中，有一些常用的逻辑关键字，这些关键字可以给我们提供更丰富的查询功能，主要关键字如下：\n\nALL关键字\nANY关键字\nSOME关键字\nIN关键字\nEXISTS关键字\n\n\n子查询关键字—ALL\n格式\nselect …from …where c &gt; all(查询语句)-- 等价于：select ...from ... where c &gt; result1 and c &gt; result2 and c &gt; result3\n特点\n\n\nALL: 与子查询返回的所有值比较为true则返回true\nALL可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的所有数据。\nALL表示指定列中的值必须要大于子查询集的每一个值，即必须要大于子查询集的最大值；如果是小于号即小于子查询集的最小值。同理可以推出其它的比较运算符的情况。\n\n\n操作\n-- 1.查询年龄大于‘1003’部门所有年龄的员工信息select * from emp3 where age &gt; all(select age from emp3 where dept_id = &#x27;1003&#x27;);-- 2.查询不属于任何一个部门的员工信息select * from emp3 where dept_id != all(select deptno from dept3);\n子查询关键字-ANY和SOME\n格式\nselect …from …where c &gt; any(查询语句)--等价于：select ...from ... where c &gt; result1 or c &gt; result2 or c &gt; result3\n特点\n\n\nANY:与子查询返回的任何值比较为true 则返回true\nANY可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的任何一个数据。\n表示制定列中的值要大于子查询中的任意一个值，即必须要大于子查询集中的最小值。同理可以推出其它的比较运算符的情况。\nSOME和ANY的作用一样，SOME可以理解为ANY的别名\n\n\n操作\n-- 查询年龄大于‘1003’部门任意一个员工年龄的员工信息select * from emp3 where age &gt; any(select age from emp3 where dept_id = &#x27;1003&#x27;);  -- 去掉自己后面加：and dept_id != &#x27;1003&#x27;  即可。-- 使用some(和any用处一样)select * from emp3 where age &gt; some(select age from emp3 where dept_id = &#x27;1003&#x27;) and dept_id != &#x27;1003&#x27;;\n子查询关键字-IN\n格式\nselect …from …where c in(查询语句)--等价于：select ...from ... where c = result1 or c = result2 or c = result3\n特点\n\n\nIN关键字，用于判断某个记录的值，是否在指定的集合中\n在IN关键字前边加上not可以将条件反过来\n\n\n操作\n-- 查询研发部和销售部的员工信息，包含员工号、员工名字select eid,ename from emp3 where dept_id in (select deptno from dept3 where name = &#x27;研发部&#x27; or name = &#x27;销售部&#x27;) ;\n子查询关键字-EXISTS\n格式\nselect …from …where exists(查询语句)\n特点\n\n\n该子查询如果“有数据结果”(至少返回一行数据)， 则该EXISTS() 的结果为“true”，外层查询执行\n该子查询如果“没有数据结果”（没有任何数据返回），则该EXISTS()的结果为“false”，外层查询不执行\nEXISTS后面的子查询不返回任何实际数据，只返回真或假，当返回真时 where条件成立\n注意，EXISTS关键字，比IN关键字的运算效率高，因此，在实际开发中，特别是大数据量时，推荐使用EXISTS关键字\n有exists的时候是从外向内查询（在exists中判断），而其他的都是从内向外查询\n\n\n操作\n-- 查询公司是否有大于60岁的员工，有则输出select * from emp3 a where exists(select * from emp3 b where a.age &gt; 60);-- 也可以使用 in 替换 select * from emp3 a where eid in(select eid from emp3 b where a.age &gt; 60);-- 查询有所属部门的员工信息select * from emp3 a where exists(select * from dept3 b where a.dept_id = b.deptno);-- 也可以使用 in 替换 select * from emp3 a where dept_id in(select deptno from dept3 b where a.dept_id = b.deptno);\n自关联查询\n概念\n\nMySQL有时在信息查询时需要进行对表自身进行关联查询，即一张表自己和自己关联，一张表当成多张表来用。注意自关联时表必须给表起别名。\n\n格式\nselect 字段列表 from 表1 a , 表1 b where 条件;或者 select 字段列表 from 表1 a [left] join 表1 b on 条件;\n操作\n-- 创建表,并建立自关联约束create table t_sanguo(    eid int primary key ,    ename varchar(20),    manager_id int, foreign key (manager_id) references t_sanguo (eid)  -- 添加自关联约束);-- 添加数据 insert into t_sanguo values(1,&#x27;刘协&#x27;,NULL);insert into t_sanguo values(2,&#x27;刘备&#x27;,1);insert into t_sanguo values(3,&#x27;关羽&#x27;,2);insert into t_sanguo values(4,&#x27;张飞&#x27;,2);insert into t_sanguo values(5,&#x27;曹操&#x27;,1);insert into t_sanguo values(6,&#x27;许褚&#x27;,5);insert into t_sanguo values(7,&#x27;典韦&#x27;,5);insert into t_sanguo values(8,&#x27;孙权&#x27;,1);insert into t_sanguo values(9,&#x27;周瑜&#x27;,8);insert into t_sanguo values(10,&#x27;鲁肃&#x27;,8); -- 进行关联查询-- 1.查询每个三国人物及他的上级信息，如:  关羽  刘备 select * from t_sanguo a, t_sanguo b where a.manager_id = b.eid;-- 也可以是（显示内连接查询）：select * from t_sanguo a join t_sanguo b on a.manager_id = b.eid;-- 2.查询所有人物及上级(左外连接➕自关联)select * from t_sanguo a left join t_sanguo b on a.manager_id = b.eid;-- 仅显示名字select a.ename,b.ename from t_sanguo a left join t_sanguo b on a.manager_id = b.eid;-- 3.查询所以人物、上级，上上级 比如：张飞  刘备  刘协select * from t_sanguo a left join t_sanguo b on a.manager_id = b.eid left join t_sanguo c on b.manager_id = c.eid;-- 仅显示名字select a.ename,b.ename,c.ename from t_sanguo a left join t_sanguo b on a.manager_id = b.eid left join t_sanguo c on b.manager_id = c.eid;\n练习\n-- 创建test1数据库create database test1;-- 选择使用test1数据库use test1;-- 创建部门表create table dept (\tdeptno int primary key,   -- 部门编号\tdname varchar(14),    -- 部门名称\tloc varchar(13)   -- 部门地址);-- 插入数据（部门表）insert into dept values (10,&#x27;accounting&#x27;,&#x27;new york&#x27;);insert into dept values (20,&#x27;research&#x27;,&#x27;dallas&#x27;);insert into dept values (30,&#x27;sales&#x27;,&#x27;chicago&#x27;);insert into dept values (40,&#x27;operations&#x27;,&#x27;boston&#x27;);-- 创建员工表create table emp (\tempno int primary key,  -- 员工编号\tename varchar(10),  -- 员工姓名\tjob varchar(9),  -- 员工工作\tmgr int,  -- 员工直属领导编号\thiredate date,  -- 入职时间\tsal double,  -- 工资\tcomm double,  -- 奖金\tdeptno int  -- 对应dept表的外键);-- 添加 部门 和 员工 之间的主外键关系alter table emp add constraint foreign key emp(deptno) references dept(deptno);-- 插入数据（员工表）insert into emp values(7369,&#x27;smith&#x27;,&#x27;clerk&#x27;,7902,&#x27;1980-12-17&#x27;,800,null,20);insert into emp values(7499,&#x27;allen&#x27;,&#x27;salesman&#x27;,7698,&#x27;1981-02-20&#x27;,1600,300,30);insert into emp values(7521,&#x27;ward&#x27;,&#x27;salesman&#x27;,7698,&#x27;1981-02-22&#x27;,1250,500,30);insert into emp values(7566,&#x27;jones&#x27;,&#x27;manager&#x27;,7839,&#x27;1981-04-02&#x27;,2975,null,20);insert into emp values(7654,&#x27;martin&#x27;,&#x27;salesman&#x27;,7698,&#x27;1981-09-28&#x27;,1250,1400,30);insert into emp values(7698,&#x27;blake&#x27;,&#x27;manager&#x27;,7839,&#x27;1981-05-01&#x27;,2850,null,30);insert into emp values(7782,&#x27;clark&#x27;,&#x27;manager&#x27;,7839,&#x27;1981-06-09&#x27;,2450,null,10);insert into emp values(7788,&#x27;scott&#x27;,&#x27;analyst&#x27;,7566,&#x27;1987-07-03&#x27;,3000,null,20);insert into emp values(7839,&#x27;king&#x27;,&#x27;president&#x27;,null,&#x27;1981-11-17&#x27;,5000,null,10);insert into emp values(7844,&#x27;turner&#x27;,&#x27;salesman&#x27;,7698,&#x27;1981-09-08&#x27;,1500,0,30);insert into emp values(7876,&#x27;adams&#x27;,&#x27;clerk&#x27;,7788,&#x27;1987-07-13&#x27;,1100,null,20);insert into emp values(7900,&#x27;james&#x27;,&#x27;clerk&#x27;,7698,&#x27;1981-12-03&#x27;,950,null,30);insert into emp values(7902,&#x27;ford&#x27;,&#x27;analyst&#x27;,7566,&#x27;1981-12-03&#x27;,3000,null,20);insert into emp values(7934,&#x27;miller&#x27;,&#x27;clerk&#x27;,7782,&#x27;1981-01-23&#x27;,1300,null,10);-- 创建工资等级表create table salgrade (\tgrade int,  -- 等级\tlosal double,  -- 最低工资\thisal double  -- 最高工资);-- 插入数据（工资等级表）insert into salgrade values (1,700,1200);insert into salgrade values (2,1201,1400);insert into salgrade values (3,1401,2000);insert into salgrade values (4,2001,3000);insert into salgrade values (5,3001,9999);-- 练习：-- 1、返回拥有员工的部门名、部门号。select distinct d.dname,d.deptno from dept d join emp e on d.deptno = e.deptno;-- 2、工资水平多于smith的员工信息。select * from emp where sal &gt; all(select sal from emp where ename = &#x27;smith&#x27;);-- 3、返回员工和所属经理的姓名。select a.ename,b.ename from emp a join emp b on a.mgr = b.empno;-- 4、返回雇员的雇佣日期早于其经理雇佣日期的员工及其经理姓名。select a.ename,a.hiredate,b.ename,b.hiredate from emp a join emp b on a.mgr = b.empno and a.hiredate &lt; b.hiredate;-- 5、返回员工姓名及其所在的部门名称。select a.ename,b.dname from emp a join dept b on a.deptno = b.deptno;-- 6、返回从事clerk工作的员工姓名和所在部门名称。select a.ename,b.dname,a.job from emp a join dept b on a.deptno = b.deptno and job = &#x27;clerk&#x27;;-- 7、返回部门号及其本部门的最低工资。select deptno,min(sal) from emp group by deptno;-- 8、返回销售部(sales)所有员工的姓名。select a.ename from emp a join dept b on a.deptno = b.deptno and b.dname = &#x27;sales&#x27;;-- 9、返回工资水平多于平均工资的员工。select * from emp where sal &gt; (select avg(sal) from emp);-- 10、返回与scott从事相同工作的员工。select * from emp where job = (select job from emp where ename = &#x27;scott&#x27;) and ename != &#x27;scott&#x27;;  -- and 以后是为了去掉自己-- 11、返回与30部门员工工资水平相同的员工姓名与工资。select * from emp where sal &gt; all(select sal from emp where deptno = 30);-- 12、返回员工工作及其从事此工作的最低工资。select job,min(sal) from emp group by job;-- 13、计算出员工的年薪，并且以年薪排序。select *,(sal * 12 + ifnull(comm,0)) year_sal from emp order by year_sal desc;-- 14、返回工资处于第四级别的员工的姓名。select * from emp where sal between (select losal from salgrade where grade = 4) and (select hisal from salgrade where grade = 4);-- 15、返回工资为二等级的职员名字、部门所在地。（select 后面可以按照题目写： c.grade,b.ename,a.loc）-- 显示内连接select * from dept a join emp b on a.deptno = b.deptno join salgrade c on c.grade = 2 and b.sal between c.losal and c.hisal;-- 隐式内连接select * from dept a,emp b,salgrade c where a.deptno = b.deptno and c.grade = 2 and b.sal between c.losal and c.hisal;\nMySQL函数\n基本介绍\n概述\n\n在MySQL中，为了提高代码重用性和隐藏实现细节，MySQL提供了很多函数。函数可以理解为别人封装好的模板代码。\n\n分类\n\n在MySQL中，函数非常多，主要可以分为以下几类:\n\n聚合函数\n数学函数\n字符串函数\n日期函数\n控制流函数\n窗口函数\n\n\n聚合函数\n概述\n\n在MySQL中，聚合函数主要由：count, sum, min, max, avg, 这些聚合函数我们之前都学过，不再重复。这里我们学习另外一个函数: group_concat(），该函数用户实现行的合并。\ngroup_concat()函数首先根据group by指定的列进行分组，并且用分隔符分隔，将同一个分组中的值连接起来，返回一个字符串结果。\n\n格式\ngroup_concat([distinct] 字段名 [order by 排序字段 asc/desc] [separator &#x27;分隔符&#x27;])\n\n说明：\n（1）使用distinct可以排除重复值；\n（2）如果需要对结果中的值进行排序，可以使用order by子句；\n（3）separator是一个字符串值，默认为逗号。\n\n操作\n-- 创建并选择mydb4create database mydb4;use mydb4;  -- 建表empcreate table emp(    emp_id int primary key auto_increment comment &#x27;编号&#x27;,    emp_name char(20) not null default &#x27;&#x27; comment &#x27;姓名&#x27;,    salary decimal(10,2) not null default 0 comment &#x27;工资&#x27;,    department char(20) not null default &#x27;&#x27; comment &#x27;部门&#x27;);  -- 插入数据insert into emp(emp_name,salary,department) values(&#x27;张晶晶&#x27;,5000,&#x27;财务部&#x27;),(&#x27;王飞飞&#x27;,5800,&#x27;财务部&#x27;),(&#x27;赵刚&#x27;,6200,&#x27;财务部&#x27;),(&#x27;刘小贝&#x27;,5700,&#x27;人事部&#x27;),(&#x27;王大鹏&#x27;,6700,&#x27;人事部&#x27;),(&#x27;张小斐&#x27;,5200,&#x27;人事部&#x27;),(&#x27;刘云云&#x27;,7500,&#x27;销售部&#x27;),(&#x27;刘云鹏&#x27;,7200,&#x27;销售部&#x27;),(&#x27;刘云鹏&#x27;,7800,&#x27;销售部&#x27;);\n-- 将所有员工的名字合并成一行 select group_concat(emp_name) from emp;\n\n-- 指定分隔符合并 select department,group_concat(emp_name separator &#x27;;&#x27; ) from emp group by department; \n\n-- 指定排序方式和分隔符 select department,group_concat(emp_name order by salary desc separator &#x27;;&#x27; ) from emp group by department;\n\n数学函数\n函数名\n由于表格行数有限，也为了方便查看，以下分为三张表来展示(加粗代表常用)：\n\n\n\n函数名\n描述\n实例\n\n\n\n\nABS(x)\n返回 x 的绝对值\n返回 -1 的绝对值：SELECT ABS(-1) – 返回1\n\n\nCEIL(x)\n返回大于或等于 x 的最小整数(向上取整)\nSELECT CEIL(1.5) – 返回2\n\n\nFLOOR(x)\n返回小于或等于 x 的最大整数(向下取整)\n小于或等于 1.5 的整数：SELECT FLOOR(1.5) – 返回1\n\n\nGREATEST(expr1, expr2, expr3, …)\n返回列表中的最大值\n返回以下数字列表中的最大值：SELECT GREATEST(3, 12, 34, 8, 25); – 34返回以下字符串列表中的最大值：SELECT GREATEST(“Google”, “Runoob”, “Apple”);   – Runoob\n\n\nLEAST(expr1, expr2, expr3, …)\n返回列表中的最小值\n返回以下数字列表中的最小值：SELECT LEAST(3, 12, 34, 8, 25); – 3返回以下字符串列表中的最小值：SELECT LEAST(“Google”, “Runoob”, “Apple”);   – Apple\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nMAX(expression)\n返回字段 expression 中的最大值\n返回数据表 Products 中字段 Price 的最大值：SELECT MAX(Price) AS LargestPrice FROM Products;\n\n\nMIN(expression)\n返回字段 expression 中的最小值\n返回数据表 Products 中字段 Price 的最小值：SELECT MIN(Price) AS MinPrice FROM Products;\n\n\nMOD(x,y)\n返回 x 除以 y 以后的余数\n5 除于 2 的余数：SELECT MOD(5,2) – 1\n\n\nPI()\n返回圆周率(3.141593）\nSELECT PI() --3.141593\n\n\nPOW(x,y)\n返回 x 的 y 次方\n2 的 3 次方：SELECT POW(2,3) – 8\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nRAND()\n返回 0 到 1 的随机数\nSELECT RAND() --0.93099315644334\n\n\nROUND(x)\n返回离 x 最近的整数（遵循四舍五入）\nSELECT ROUND(1.23456) --1\n\n\nROUND(x,y)\n返回指定位数的小数（遵循四舍五入）\nSELECT ROUND(1.23456,3) –1.235\n\n\nTRUNCATE(x,y)\n返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入）\nSELECT TRUNCATE(1.23456,3) – 1.234\n\n\n\n操作\n-- 案例：通过数据库的函数，生成一个六位数的随机验证码。select lpad(round(rand()*1000000,0),6,&#x27;0&#x27;);-- 四舍五入平均价格，保留两位小数。use mydb2;select category_id,round(avg(price),2) from product group by category_id;\n字符串函数\n字符串等的位置：从1开始；索引：从0开始。两者都是描述位置的，但是计数起点不同。\n函数名\n\n\n\n函数\n描述\n实例\n\n\n\n\nCHAR_LENGTH(s)\n返回字符串 s 的字符数\n返回字符串 RUNOOB 的字符数SELECT CHAR_LENGTH(“RUNOOB”) AS LengthOfString;\n\n\nLENGTH(s)\n返回字符串 s 的字节数\nSELECT LENGTH(“明天”) AS LengthOfString;   – 6（utf-8 一个汉字为3个字节）\n\n\nCHARACTER_LENGTH(s)\n返回字符串 s 的字符数\n返回字符串 RUNOOB 的字符数SELECT CHARACTER_LENGTH(“RUNOOB”) AS LengthOfString;\n\n\nCONCAT(s1,s2…sn)\n字符串 s1,s2 等多个字符串合并为一个字符串\n合并多个字符串SELECT CONCAT(&quot;SQL &quot;, &quot;Runoob &quot;, &quot;Gooogle &quot;, “Facebook”) AS ConcatenatedString;\n\n\nCONCAT_WS(x, s1,s2…sn)\n同 CONCAT(s1,s2,…) 函数，但是每个字符串之间要加上 x，x 可以是分隔符\n合并多个字符串，并添加分隔符：SELECT CONCAT_WS(“-”, “SQL”, “Tutorial”, “is”, “fun!”)AS ConcatenatedString;\n\n\nFIELD(s,s1,s2…)\n返回第一个字符串 s 在字符串列表(s1,s2…)中的位置\n返回字符串 c 在列表值中的位置：SELECT FIELD(“c”, “a”, “b”, “c”, “d”, “e”,“c”);  后面重复的’c’就不会输出位置，只能输出第一个查到的‘c’\n\n\n\n\n\n\n函数\n描述\n实例\n\n\n\n\nLTRIM(s)\n去掉字符串 s 开始处的空格\n去掉字符串 RUNOOB开始处的空格：SELECT LTRIM(&quot;    RUNOOB&quot;) AS LeftTrimmedString;-- RUNOOB\n\n\nRTRIM(s)\n去掉字符串 s 结尾处的空格\n去掉字符串 RUNOOB结尾处的空格：SELECT RTRIM(&quot;      RUNOOB    &quot;) AS LeftTrimmedString;-- RUNOOB\n\n\nMID(s,n,len)\n从字符串 s 的 n 位置截取长度为 len 的子字符串，同 SUBSTRING(s,n,len)\n从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：SELECT MID(“RUNOOB”, 2, 3) AS ExtractString; – UNO\n\n\nPOSITION(s1 IN s)\n从字符串 s 中获取 s1 的开始位置\n返回字符串 abc 中 b 的位置：SELECT POSITION(‘b’ in ‘abc’) – 2\n\n\nREPLACE(s,s1,s2)\n将字符串 s2 替代字符串 s 中的字符串 s1\n将字符串 abc 中的字符 a 替换为字符 x：SELECT REPLACE(‘abca’,‘a’,‘x’) --xbcx\n\n\nREVERSE(s)\n将字符串s的顺序反过来\n将字符串 abc 的顺序反过来：SELECT REVERSE(‘abc’) – cba\n\n\n\n\n\n\n函数\n描述\n实例\n\n\n\n\nLEFT(s,n)\n返回字符串 s 的前 n 个字符\n返回字符串 runoob 的前两个字符：SELECT left(‘runoob’,2) – ru\n\n\nRIGHT(s,n)\n返回字符串 s 的后 n 个字符\n返回字符串 runoob 的后两个字符：SELECT RIGHT(‘runoob’,2) – ob\n\n\nSTRCMP(s1,s2)\n比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1\n比较字符串：SELECT STRCMP(“runoob”, “runoob”);  – 0\n\n\nSUBSTR(s, start, length)\n从字符串 s 的 start 位置截取长度为 length 的子字符串\n从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：SELECT SUBSTR(“RUNOOB”, 2, 3) AS ExtractString; – UNO\n\n\nSUBSTRING(s, start, length)\n从字符串 s 的 start 位置截取长度为 length 的子字符串\n从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：SELECT SUBSTRING(“RUNOOB”, 2, 3) AS ExtractString; – UNO\n\n\n\n\n\n\n函数\n描述\n实例\n\n\n\n\nTRIM(s)\n去掉字符串 s 开始和结尾处的空格\n去掉字符串 RUNOOB 的首尾空格：SELECT TRIM(’    RUNOOB    ') AS TrimmedString;\n\n\nUCASE(s)\n将字符串转换为大写\n将字符串 runoob 转换为大写：SELECT UCASE(“runoob”); – RUNOOB\n\n\nUPPER(s)\n将字符串转换为大写\n将字符串 runoob 转换为大写：SELECT UPPER(“runoob”); – RUNOOB\n\n\nLCASE(s)\n将字符串 s 的所有字母变成小写字母\n字符串 RUNOOB 转换为小写：SELECT LCASE(‘RUNOOB’) – runoob\n\n\nLOWER(s)\n将字符串 s 的所有字母变成小写字母\n字符串 RUNOOB 转换为小写：SELECT LOWER(‘RUNOOB’) – runoob\n\n\nLPAD(str,n,pad)\n左填充，用字符串pad对str的左边进行填充，达到n个字符串长度\n左填充：select lpad(‘01’,5,‘-’);\n\n\nRPAD(str,n,pad)\n右填充，用字符串pad对str的右边进行填充，达到n个字符串长度\n右填充：select rpad(‘01’,5,‘-’);\n\n\n\n操作\n-- 案例：由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0，比如：1号员工的工号应该为00001update emp set workno = lpad(&#x27;1&#x27;,5,&#x27;0&#x27;);\n日期函数\n函数名\n\n\n\n函数名\n描述\n实例\n\n\n\n\nUNIX_TIMESTAMP()\n返回从1970-01-01 00:00:00到当前毫秒值(时间戳)\nselect UNIX_TIMESTAMP() -&gt; 1632729059\n\n\nUNIX_TIMESTAMP(DATE_STRING)\n将制定日期转为毫秒值时间戳\nSELECT UNIX_TIMESTAMP(‘2011-12-07 13:01:03’);\n\n\nFROM_UNIXTIME(BIGINT UNIXTIME[, STRING FORMAT])\n将毫秒值时间戳转为指定格式日期\nSELECT FROM_UNIXTIME(1598079966,‘%Y-%m-%d %H:%i:%s’); (1598079966,‘%Y-%m-%d %H:%i:%s’); -&gt; 2020-08-22 15-06-06\n\n\nCURDATE()\n返回当前日期\nSELECT CURDATE();-&gt; 2018-09-19\n\n\nCURRENT_DATE()\n返回当前日期\nSELECT CURRENT_DATE();-&gt; 2018-09-19\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nCURRENT_TIME\n返回当前时间\nSELECT CURRENT_TIME();-&gt; 19:59:02\n\n\nCURTIME()\n返回当前时间\nSELECT CURTIME();-&gt; 19:59:02\n\n\nCURRENT_TIMESTAMP()\n返回当前日期和时间\nSELECT CURRENT_TIMESTAMP()-&gt; 2018-09-19 20:57:43\n\n\nDATE()\n从日期或日期时间表达式中提取日期值\nSELECT DATE(“2017-06-15”);    -&gt; 2017-06-15\n\n\nDATEDIFF(d1,d2)\n计算日期 d1-&gt;d2 之间相隔的天数\nSELECT DATEDIFF(‘2001-01-01’,‘2001-02-02’)-&gt; -32\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nTIMEDIFF(time1, time2)\n计算时间差值\nSELECT TIMEDIFF(“13:10:11”, “13:10:10”);-&gt; 00:00:01\n\n\nDATE_FORMAT(d,f)\n按表达式 f的要求显示日期 d\nSELECT DATE_FORMAT(‘2011-11-11 11:11:11’,‘%Y-%m-%d %r’)-&gt; 2011-11-11 11:11:11 AM\n\n\nSTR_TO_DATE(string, format_mask)\n将字符串转变为日期\nSELECT STR_TO_DATE(“August 10 2017”, “%M %d %Y”);-&gt; 2017-08-10\n\n\nDATE_SUB(date,INTERVAL expr type)\n函数从日期减去指定的时间间隔。\nOrders 表中 OrderDate 字段减去 2 天：SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDate FROM Orders;\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nADDDATE/DATE_ADD(d，INTERVAL expr type)\n计算起始日期 d 加上一个时间段后的日期，type 值可以是：MICROSECONDSECONDMINUTEHOURDAYWEEKMONTHQUARTERYEARDAY_MINUTEDAY_HOURYEAR_MONTH\nSELECT DATE_ADD(“2017-06-15”, INTERVAL 10 DAY); -&gt; 2017-06-25SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL 15 MINUTE); -&gt; 2017-06-15 09:49:21SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 HOUR); -&gt;2017-06-15 06:34:21SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 HOUR); -&gt;2017-04-15\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nDATE_ADD(d，INTERVAL expr type)\n计算起始日期 d 加上一个时间段后的日期，type 值可以是：SECOND_MICROSECONDMINUTE_MICROSECONDMINUTE_SECONDHOUR_MICROSECONDHOUR_SECONDHOUR_MINUTEDAY_MICROSECONDDAY_SECONDDAY_MINUTEDAY_HOURYEAR_MONTH\nSELECT DATE_ADD(“2017-06-15”, INTERVAL 10 DAY);  -&gt; 2017-06-25SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL 15 MINUTE);  -&gt; 2017-06-15 09:49:21SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 HOUR);  -&gt;2017-06-15 06:34:21SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 HOUR);  -&gt;2017-04-15\n\n\n\n\n\n\n\n\n\n\n\n\n\nEXTRACT(type FROM d)\n从日期 d 中获取指定的值，type 指定返回的值。type可取值为：MICROSECONDSECONDMINUTEHOUR    ……\nSELECT EXTRACT(MINUTE FROM ‘2011-11-11 11:11:11’) -&gt; 11\n\n\nLAST_DAY(d)\n返回给给定日期的那一月份的最后一天\nSELECT LAST_DAY(“2017-06-20”);-&gt; 2017-06-30\n\n\nMAKEDATE(year, day-of-year)\n基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期\nSELECT MAKEDATE(2017, 3);-&gt; 2017-01-03\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nYEAR(d)\n返回年份\nSELECT YEAR(“2017-06-15”);-&gt; 2017\n\n\nMONTH(d)\n返回日期d中的月份值，1 到 12\nSELECT MONTH(‘2011-11-11 11:11:11’)-&gt;11\n\n\nDAY(d)\n返回日期值 d 的日期部分\nSELECT DAY(“2017-06-15”);  -&gt; 15\n\n\nHOUR(t)\n返回 t 中的小时值\nSELECT HOUR(‘1:2:3’)-&gt; 1\n\n\nMINUTE(t)\n返回 t 中的分钟值\nSELECT MINUTE(‘1:2:3’)-&gt; 2\n\n\nSECOND(t)\n返回 t 中的秒钟值\nSELECT SECOND(‘1:2:3’)-&gt; 3\n\n\nQUARTER(d)\n返回日期d是第几季节，返回 1 到 4\nSELECT QUARTER(‘2011-11-11 11:11:11’)-&gt; 4\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nMONTHNAME(d)\n返回日期当中的月份名称，如 November\nSELECT MONTHNAME(‘2011-11-11 11:11:11’)-&gt; November\n\n\nDAYNAME(d)\n返回日期 d 是星期几，如 Monday,Tuesday\nSELECT DAYNAME(‘2011-11-11 11:11:11’)-&gt;Friday\n\n\nDAYOFMONTH(d)\n计算日期 d 是本月的第几天\nSELECT DAYOFMONTH(‘2011-11-11 11:11:11’)-&gt;11\n\n\nDAYOFWEEK(d)\n日期 d 今天是星期几，1 星期日，2 星期一，以此类推\nSELECT DAYOFWEEK(‘2011-11-11 11:11:11’)-&gt;6\n\n\nDAYOFYEAR(d)\n计算日期 d 是本年的第几天\nSELECT DAYOFYEAR(‘2011-11-11 11:11:11’)-&gt;315\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nWEEK(d)\n计算日期 d 是本年的第几个星期，范围是 0 到 53\nSELECT WEEK(‘2011-11-11 11:11:11’)-&gt; 45\n\n\nWEEKDAY(d)\n日期 d 是星期几，0 表示星期一，1 表示星期二\nSELECT WEEKDAY(“2017-06-15”);-&gt; 3\n\n\nWEEKOFYEAR(d)\n计算日期 d 是本年的第几个星期，范围是 0 到 53\nSELECT WEEKOFYEAR(‘2011-11-11 11:11:11’)-&gt; 45\n\n\nYEARWEEK(date, mode)\n返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推\nSELECT YEARWEEK(“2017-06-15”);-&gt; 201724\n\n\nNOW()\n返回当前日期和时间\nSELECT NOW()-&gt; 2018-09-19 20:57:43\n\n\n\n操作\n-- 案例：查询所有员工的入职天数，并根据入职天数倒序排序。select ename, datediff(curdate(), hiredate) hiredays from emp order by hiredays desc;\n控制流函数\nif逻辑判断语句\n\n\n\n格式\n解释\n案例\n\n\n\n\nIF(expr,v1,v2)\n如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。\nSELECT IF(1 &gt; 0,‘正确’,‘错误’)    -&gt;正确\n\n\nIFNULL(v1,v2)\n如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。\nSELECT IFNULL(null,‘Hello Word’)  -&gt;Hello Word\n\n\nISNULL(expression)\n判断表达式是否为 NULL\nSELECT ISNULL(NULL);  -&gt;1\n\n\nNULLIF(expr1, expr2)\n比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1\nSELECT NULLIF(25, 25);  -&gt;null\n\n\n\ncase when语句\n\n\n\n格式\n解释\n操作\n\n\n\n\nCASE expression    WHEN condition1 THEN result1    WHEN condition2 THEN result2   …    WHEN conditionN THEN resultN    ELSE resultEND\nCASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。\nselect case 100 when 50 then ‘tom’ when 100 then ‘mary’else ‘tim’ end ;select case when 1=2 then ‘tom’ when 2=2 then ‘mary’ else’tim’ end ;\n\n\n\n案例\n-- 案例1：use mydb4;-- 创建订单表create table orders(\toid int primary key,  -- 订单id\tprice double,  -- 订单价格\tpayType int  -- 支付类型(1:微信支付 2:支付宝支付 3:银行卡支付 4:其他));-- 插入数据insert into orders values(1,1200,1);insert into orders values(2,1000,2);insert into orders values(3,200,3);insert into orders values(4,3000,1);insert into orders values(5,1500,2);-- 操作-- 方式1select \t*,\tcase payType \t\twhen 1 then &#x27;微信支付&#x27; \t\twhen 2 then &#x27;支付宝支付&#x27;\t\twhen 3 then &#x27;银行卡支付&#x27;\t\telse \t\t\t&#x27;其他支付方式&#x27; \tend as payTypeStrfrom orders;-- 方式2select \t*,\tcase  \t\twhen payType=1 then &#x27;微信支付&#x27; \t\twhen payType=2 then &#x27;支付宝支付&#x27;\t\twhen payType=3 then &#x27;银行卡支付&#x27;\t\telse \t\t\t&#x27;其他支付方式&#x27; \tend as payTypeStrfrom orders;-- 案例2：统计班级各个学员的成绩，展示的规则如下：-- &gt;= 85，展示优秀-- &gt;= 60，展示及格-- 否则，展示不及格use mydb4;-- 创建表并插入数据create table score(\tid int comment &#x27;ID&#x27;,\tname varchar(20) comment &#x27;姓名&#x27;,\tmath int comment &#x27;数学&#x27;,\tenglish int comment &#x27;英语&#x27;,\tchinese int comment &#x27;语文&#x27;) comment &#x27;学员成绩表&#x27;;insert into score(id,name,math,english,chinese) values(1,&#x27;Tom&#x27;,67,88,95),(2,&#x27;Rose&#x27;,23,66,90),(3,&#x27;Jack&#x27;,56,98,76);-- 操作select \tid,\tname,\tcase when math &gt;= 85 then &#x27;优秀&#x27; when math &gt;=60 then &#x27;及格&#x27; else &#x27;不及格&#x27; end &#x27;数学&#x27;,\tcase when english &gt;= 85 then &#x27;优秀&#x27; when english &gt;=60 then &#x27;及格&#x27; else &#x27;不及格&#x27; end &#x27;英语&#x27;,\tcase when chinese &gt;= 85 then &#x27;优秀&#x27; when chinese &gt;=60 then &#x27;及格&#x27; else &#x27;不及格&#x27; end &#x27;语文&#x27;from score;\n窗口函数\n介绍\n\n\nMySQL 8.0 新增窗口函数 ,窗口函数又被称为开窗函数，与Oracle 窗口函数类似，属于MySQL的一大特点。\n非聚合窗口函数是相对于聚函数来说的。聚合函数是对一组数据计算后返回单个值（即分组），非聚合函数一次只会处理一行数据。窗口聚合函数在行记录上计算某个字段的结果时，可将窗口范围内的数据输入到聚合函数中，并不改变行数。\n\n\n\n分类\n\n另外还有开窗聚合函数: SUM,AVG,MIN,MAX\n语法结构\nwindow_function ( expr ) OVER (   PARTITION BY ...   ORDER BY ...   frame_clause )\n\n其中，window_function 是窗口函数的名称；expr 是参数，有些函数不需要参数；OVER子句包含三个选项：\n\n\n分区（PARTITION BY）:\n\nPARTITION BY选项用于将数据行拆分成多个分区（组），它的作用类似于GROUP BY分组。如果省略了 PARTITION BY，所有的数据作为一个组进行计算\n\n排序（ORDER BY）:\n\nOVER 子句中的ORDER BY选项用于指定分区内的排序方式，与 ORDER BY 子句的作用类似\n\n以及窗口大小（frame_clause）:\n\nframe_clause选项用于在当前分区内指定一个计算窗口，也就是一个与当前行相关的数据子集。\n\n\n序号函数\n序号函数有三个：ROW_NUMBER()、RANK()、DENSE_RANK()，可以用来实现分组排序，并添加序号。\n格式\nrow_number()|rank()|dense_rank() over (   partition by ...   order by ... ) \n操作\nuse mydb4; create table employee(    dname varchar(20), -- 部门名    eid varchar(20),    ename varchar(20),    hiredate date, -- 入职日期    salary double -- 薪资); -- 插入数据insert into employee values(&#x27;研发部&#x27;,&#x27;1001&#x27;,&#x27;刘备&#x27;,&#x27;2021-11-01&#x27;,3000);insert into employee values(&#x27;研发部&#x27;,&#x27;1002&#x27;,&#x27;关羽&#x27;,&#x27;2021-11-02&#x27;,5000);insert into employee values(&#x27;研发部&#x27;,&#x27;1003&#x27;,&#x27;张飞&#x27;,&#x27;2021-11-03&#x27;,7000);insert into employee values(&#x27;研发部&#x27;,&#x27;1004&#x27;,&#x27;赵云&#x27;,&#x27;2021-11-04&#x27;,7000);insert into employee values(&#x27;研发部&#x27;,&#x27;1005&#x27;,&#x27;马超&#x27;,&#x27;2021-11-05&#x27;,4000);insert into employee values(&#x27;研发部&#x27;,&#x27;1006&#x27;,&#x27;黄忠&#x27;,&#x27;2021-11-06&#x27;,4000); insert into employee values(&#x27;销售部&#x27;,&#x27;1007&#x27;,&#x27;曹操&#x27;,&#x27;2021-11-01&#x27;,2000);insert into employee values(&#x27;销售部&#x27;,&#x27;1008&#x27;,&#x27;许褚&#x27;,&#x27;2021-11-02&#x27;,3000);insert into employee values(&#x27;销售部&#x27;,&#x27;1009&#x27;,&#x27;典韦&#x27;,&#x27;2021-11-03&#x27;,5000);insert into employee values(&#x27;销售部&#x27;,&#x27;1010&#x27;,&#x27;张辽&#x27;,&#x27;2021-11-04&#x27;,6000);insert into employee values(&#x27;销售部&#x27;,&#x27;1011&#x27;,&#x27;徐晃&#x27;,&#x27;2021-11-05&#x27;,9000);insert into employee values(&#x27;销售部&#x27;,&#x27;1012&#x27;,&#x27;曹洪&#x27;,&#x27;2021-11-06&#x27;,6000);\nrow_number()\n-- 对每个部门的员工按照薪资降序排序，并给出排名select dname,ename,salary,row_number() over(partition by dname order by salary desc) as rn from employee;\n\nrank()\n-- 对每个部门的员工按照薪资排序，并给出排名 rankselect dname,ename,salary,rank() over(partition by dname order by salary desc) as rn from employee;\n\ndense_rank()\n-- 对每个部门的员工按照薪资排序，并给出排名 dense-rankselect dname,ename,salary,dense_rank() over(partition by dname order by salary desc) as rn from employee;\n\n--求出每个部门薪资排在前三名的员工- 分组求TOPNselect * from (    select      dname,     ename,     salary,     dense_rank() over(partition by dname order by salary desc)  as rn    from employee)twhere t.rn &lt;= 3\n\n-- 对所有员工进行全局排序（不分组）-- 不加partition by表示全局排序select      dname,     ename,     salary,     dense_rank() over( order by salary desc)  as rnfrom employee;\n\n开窗聚合函数- SUM,AVG,MIN,MAX\n概念\n\n在窗口中每条记录动态地应用聚合函数（SUM()、AVG()、MAX()、MIN()、COUNT()），可以动态计算在指定的窗口内的各种聚合函数值。\n\n操作\n-- 开窗聚合函数select   dname, ename, salary, sum(salary) over(partition by dname order by hiredate) as pv1 from employee; select  dname, ename, salary, sum(salary) over(partition by dname) as pv3from employee;  -- 如果没有order  by排序语句  默认把分组内的所有数据进行sum操作select   dname, ename, salary, sum(salary) over(partition by dname order by hiredate  rows between unbounded preceding and current row) as c1 from employee;    -- rows代表行，between从哪里到哪里，unbounded preceding代表 从开头 开始 到当前行current row 结束 select   dname, ename, salary, sum(salary) over(partition by dname order by hiredate   rows between 3 preceding and current row) as c1 from employee;   -- rows代表行，between从哪里到哪里，3 preceding代表 从当前行向上三行 开始 到当前行current row 结束select   dname, ename, salary, sum(salary) over(partition by dname order by hiredate   rows between 3 preceding and 1 following) as c1 from employee; -- rows代表行，between从哪里到哪里，3 preceding代表 从当前行向上三行 开始 到当前行下一行 1 following 结束select   dname, ename, salary, sum(salary) over(partition by dname order by hiredate   rows between current row and unbounded following) as c1 from employee;    -- rows代表行，between从哪里到哪里，current row代表 从当前行 开始 到最后 unbounded following 结束 \n分布函数-(CUME_DIST)\n介绍\n\n\n用途：分组内小于、等于当前rank值的行数 / 分组内总行数\n应用场景：查询小于等于当前薪资（salary）的比例\n\n\n操作\nselect   dname, ename, salary, cume_dist() over(order by salary) as rn1, -- 没有partition语句 所有的数据位于一组 cume_dist() over(partition by dname order by salary) as rn2 from employee;/*rn1: 没有partition,所有数据均为1组，总行数为12，     第一行：小于等于3000的行数为3，因此，3/12=0.25     第二行：小于等于4000的行数为5，因此，5/12=0.4166666666666667rn2: 按照部门分组，dname=&#x27;研发部&#x27;的行数为6,     第一行：研发部小于等于3000的行数为1，因此，1/6=0.16666666666666666*/\n\n分布函数-(PERCENT_RANK)\n介绍\n\n\n用途：每行按照公式(rank-1) / (rows-1)进行计算。其中，rank为RANK()函数产生的序号，rows为当前窗口的记录总行数；\n应用场景：不常用。\n\n\n操作\nselect  dname, ename, salary, rank() over(partition by dname order by salary desc ) as rn, percent_rank() over(partition by dname order by salary desc ) as rn2from employee;/* rn2:  第一行: (1 - 1) / (6 - 1) = 0  第二行: (1 - 1) / (6 - 1) = 0  第三行: (3 - 1) / (6 - 1) = 0.4*/\n\n前后函数-LAG和LEAD\n介绍\n\n\n用途：返回位于当前行的前n行（LAG(expr,n)）或后n行（LEAD(expr,n)）的expr的值\n应用场景：查询前1名同学的成绩和当前同学成绩的差值\n\n\n操作\n-- lag的用法select  dname, ename, salary, hiredate, lag(hiredate,1,&#x27;2000-01-01&#x27;) over(partition by dname order by hiredate) as last_1_time, lag(hiredate,2) over(partition by dname order by hiredate) as last_2_time from employee;/*last_1_time: 指定了往上第1行的值，default为&#x27;2000-01-01&#x27;                           第一行，往上1行为null,因此取默认值 &#x27;2000-01-01&#x27;                         第二行，往上1行值为第一行值，2021-11-01                          第三行，往上1行值为第二行值，2021-11-02 last_2_time: 指定了往上第2行的值，为指定默认值                         第一行，往上2行为null                         第二行，往上2行为null                         第四行，往上2行为第二行值，2021-11-01                          第七行，往上2行为第五行值，2021-11-02 */-- lead的用法select  dname, ename, salary, hiredate, lead(hiredate,1,&#x27;2000-01-01&#x27;) over(partition by dname order by hiredate) as last_1_time, lead(hiredate,2) over(partition by dname order by hiredate) as last_2_time from employee;\nLAG(expr,n)：\n\nLEAD(expr,n)：\n\n头尾函数-FIRST_VALUE和LAST_VALUE\n介绍\n用途：返回第一个（FIRST_VALUE(expr)）或最后一个（LAST_VALUE(expr)）expr的值\n应用场景：截止到当前，按照日期排序查询第1个入职和最后1个入职员工的薪资\n操作\n-- 注意,  如果不指定ORDER BY，则进行排序混乱，会出现错误的结果select  dname,  ename,  hiredate,  salary,  first_value(salary) over(partition by dname order by hiredate) as first,  last_value(salary) over(partition by dname order by  hiredate) as last from  employee;\n\n其他函数-NTH_VALUE(expr, n)、NTILE(n)\n介绍-NTH_VALUE(expr,n)\n\n\n用途：返回窗口中第n个expr的值。expr可以是表达式，也可以是列名\n应用场景：截止到当前薪资，显示每个员工的薪资中排名第2或者第3的薪资\n\n\n操作\n-- 查询每个部门截止目前薪资排在第二和第三的员工信息select   dname,  ename,  hiredate,  salary,  nth_value(salary,2) over(partition by dname order by hiredate) as second_score,  nth_value(salary,3) over(partition by dname order by hiredate) as third_scorefrom employee;\n\n介绍-NTILE(n)\n\n\n用途：将分区中的有序数据分为n个等级，记录等级数\n应用场景：将每个部门员工按照入职日期分成3组\n\n\n操作\n-- 根据入职日期将每个部门的员工分成3组select   dname,  ename,  hiredate,  salary,ntile(3) over(partition by dname order by  hiredate  ) as rn from employee;\n\n练习\n-- 取出每个部门的第一组员工select*from(    SELECT         dname,        ename,        hiredate,        salary,    NTILE(3) OVER(PARTITION BY dname ORDER BY  hiredate  ) AS rn     FROM employee)twhere t.rn = 1;\n\nMySQL的视图\n介绍\n\n\n视图（view）是一个虚拟表，非真实存在，其本质是根据SQL语句获取动态的数据集，并为其命名，用户使用时只需使用视图名称即可获取结果集，并可以将其当作表来使用。(就是原表的一个映射)\n数据库中只存放了视图的定义，而并没有存放视图中的数据。这些数据存放在原来的表中。\n使用视图查询数据时，数据库系统会从原来的表中取出对应的数据。因此，视图中的数据是依赖于原来的表中的数据的。一旦表中的数据发生改变，显示在视图中的数据也会发生改变。\n\n\n作用\n\n\n简化代码，可以把重复使用的查询封装成视图重复使用，同时可以使复杂的查询易于理解和使用。\n安全原因，如果一张表中有很多数据，很多信息不希望让所有人看到，此时可以使用视图视，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，可以对不同的用户，设定不同的视图。\n\n\n视图的创建\n格式\n创建视图的语法为：\ncreate [or replace] [algorithm = &#123;undefined | merge | temptable&#125;] view view_name [(column_list)] as select_statement [with [cascaded | local] check option]参数说明：（1）algorithm：可选项，表示视图选择的算法。（2）view_name ：表示要创建的视图名称。（3）column_list：可选项，指定视图中各个属性的名词，默认情况下与SELECT语句中的查询的属性相同。（4）select_statement  ：表示一个完整的查询语句，将查询记录导入视图中。（5）[with [cascaded | local] check option] ：可选项，表示更新视图时要保证在该视图的权限范围之内。\n数据准备\n创建 数据库mydb6_view,然后在该数据库下执行sql脚本view_data.sql 导入数据\ncreate database mydb6_view;-- 创建部门表并插入数据create table dept(\tdeptno int primary key,  dname varchar(20),\tloc varchar(20));insert into dept values(10, &#x27;教研部&#x27;,&#x27;北京&#x27;),(20, &#x27;学工部&#x27;,&#x27;上海&#x27;),(30, &#x27;销售部&#x27;,&#x27;广州&#x27;),(40, &#x27;财务部&#x27;,&#x27;武汉&#x27;);-- 创建员工表并插入数据create table emp(\tempno int primary key,\tename varchar(20),\tjob varchar(20),\tmgr int,\thiredate date,\tsal numeric(8,2),\tcomm numeric(8, 2),\tdeptno int,-- \tFOREIGN KEY (mgr) REFERENCES emp(empno),\tFOREIGN KEY (deptno) REFERENCES dept(deptno) ON DELETE SET NULL ON UPDATE CASCADE);INSERT INTO emp VALUES(1001, &#x27;甘宁&#x27;, &#x27;文员&#x27;, 1013, &#x27;2000-12-17&#x27;, 8000.00, NULL, 20),(1002, &#x27;黛绮丝&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-02-20&#x27;, 16000.00, 3000.00, 30),(1003, &#x27;殷天正&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-02-22&#x27;, 12500.00, 5000.00, 30),(1004, &#x27;刘备&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-4-02&#x27;, 29750.00, NULL, 20),(1005, &#x27;谢逊&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-9-28&#x27;, 12500.00, 14000.00, 30),(1006, &#x27;关羽&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-05-01&#x27;, 28500.00, NULL, 30),(1007, &#x27;张飞&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-09-01&#x27;, 24500.00, NULL, 10),(1008, &#x27;诸葛亮&#x27;, &#x27;分析师&#x27;, 1004, &#x27;2007-04-19&#x27;, 30000.00, NULL, 20),(1009, &#x27;曾阿牛&#x27;, &#x27;董事长&#x27;, NULL, &#x27;2001-11-17&#x27;, 50000.00, NULL, 10),(1010, &#x27;韦一笑&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-09-08&#x27;, 15000.00, 0.00, 30),(1011, &#x27;周泰&#x27;, &#x27;文员&#x27;, 1008, &#x27;2007-05-23&#x27;, 11000.00, NULL, 20),(1012, &#x27;程普&#x27;, &#x27;文员&#x27;, 1006, &#x27;2001-12-03&#x27;, 9500.00, NULL, 30),(1013, &#x27;庞统&#x27;, &#x27;分析师&#x27;, 1004, &#x27;2001-12-03&#x27;, 30000.00, NULL, 20),(1014, &#x27;黄盖&#x27;, &#x27;文员&#x27;, 1007, &#x27;2002-01-23&#x27;, 13000.00, NULL, 10);-- 创建工资等级表并插入数据create table salgrade (\tgrade int,  -- 等级\tlosal double,  -- 最低工资\thisal double  -- 最高工资);-- 插入数据insert into salgrade values (1,7000,12000);insert into salgrade values (2,12010,14000);insert into salgrade values (3,14010,20000);insert into salgrade values (4,20010,30000);insert into salgrade values (5,30010,99990);\n操作\n-- 创建视图create or replace view view1_empas select ename,job from emp; -- 查看表和视图 show full tables;\n修改视图\n修改视图是指修改数据库中已存在的表的定义。当基本表的某些字段发生改变时，可以通过修改视图来保持视图和基本表之间一致。MySQL中通过CREATE OR REPLACE VIEW语句来创建视图和ALTER VIEW语句来修改视图。\n格式\nalter view 视图名 as select语句\n操作\nalter view view1_empas select a.deptno,a.dname,a.loc,b.ename,b.sal from dept a, emp b where a.deptno = b.deptno;\n更新视图\n介绍\n\n某些视图是可更新的。也就是说，可以在UPDATE、DELETE或INSERT等语句中使用它们，以更新基表的内容。对于可更新的视图，在视图中的行和基表中的行之间必须具有一对一的关系。如果视图包含下述结构中的任何一种，那么它就是不可更新的：\n\n\n聚合函数（SUM(), MIN(), MAX(), COUNT()等）\nDISTINCT\nGROUP BY\nORDER BY\nHAVING\nUNION或UNION ALL\n位于选择列表中的子查询\nJOIN\nFROM子句中的不可更新视图\nWHERE子句中的子查询，引用FROM子句中的表。\n仅引用文字值（在该情况下，没有要更新的基本表）\n\n\n\n视图中虽然可以更新数据，但是有很多的限制。一般情况下，最好将视图作为查询数据的虚拟表，而不要通过视图更新数据。因为，使用视图更新数据时，如果没有全面考虑在视图中更新数据的限制，就可能会造成数据更新失败。\n操作\n--  ---------更新视图-------create or replace view view1_empas select ename,job from emp; update view1_emp set ename = &#x27;周瑜&#x27; where ename = &#x27;鲁肃&#x27;;  -- 可以修改insert into view1_emp values(&#x27;孙权&#x27;,&#x27;文员&#x27;);  -- 不可以插入-- ----------视图包含聚合函数不可更新--------------create or replace view view2_empas select count(*) cnt from emp; insert into view2_emp values(100);update view2_emp set cnt = 100; -- ----------视图包含distinct不可更新---------create or replace view view3_empas select distinct job from emp; insert into view3_emp values(&#x27;财务&#x27;); -- ----------视图包含goup by 、having不可更新------------------ create or replace view view4_empas select deptno ,count(*) cnt from emp group by deptno having  cnt &gt; 2; insert into view4_emp values(30,100);-- ----------------视图包含union或者union all不可更新----------------create or replace view view5_empas select empno,ename from emp where empno &lt;= 1005union select empno,ename from emp where empno &gt; 1005; insert into view5_emp values(1015,&#x27;韦小宝&#x27;);-- -------------------视图包含子查询不可更新--------------------create or replace view view6_empas select empno,ename,sal from emp where sal = (select max(sal) from emp); insert into view6_emp values(1015,&#x27;韦小宝&#x27;,30000);-- ----------------------视图包含join不可更新-----------------create or replace view view7_empas select dname,ename,sal from emp a join  dept b  on a.deptno = b.deptno; insert into view7_emp(dname,ename,sal) values(&#x27;行政部&#x27;,&#x27;韦小宝&#x27;,30000); -- --------------------视图包含常量文字值不可更新-------------------create or replace view view8_empas select &#x27;行政部&#x27; dname,&#x27;杨过&#x27;  ename; insert into view8_emp values(&#x27;行政部&#x27;,&#x27;韦小宝&#x27;);\n其他操作\n重命名视图\n-- rename table 视图名 to 新视图名; rename table view1_emp to my_view1\n删除视图\n-- drop view 视图名[,视图名…];drop view if exists view_student;\n删除视图时，只能删除视图的定义，不会删除数据。\n练习\n-- 1：查询部门平均薪水最高的部门名称-- 方式一：视图create view avg_sal as select deptno,avg(sal) from emp group by deptno order by avg(sal) desc limit 1;select dname from dept  a ,avg_sal b where a.deptno = b.deptno;   -- 方式二：子查询select dname from dept  a ,(select deptno,avg(sal) from emp group by deptno order by avg(sal) desc limit 1) b where a.deptno = b.deptno;    -- 2：查询员工比所属领导薪资高的部门名、员工名、员工领导编号select * from dept x,(select a.ename aname ,a.sal asal,b.ename bname,b.sal bsal,a.deptnofrom emp a, emp b where a.mgr = b.empno and a.sal &gt; b.sal) ywhere x.deptno = y.deptno;-- 3：查询工资等级为4级，2000年以后入职的工作地点为北京的员工编号、姓名和工资，并查询出薪资在前三名的员工信息create view xxxas       SELECT e.empno,e.ename,e.sal,e.hiredateFROM emp e,dept d,salgrade sWHERE (e.sal BETWEEN  losal AND hisal) AND s.GRADE = 4AND year(e.hiredate) &gt; &#x27;2000&#x27;AND d.loc = &#x27;北京&#x27;; select * from (select  *, dense_rank() over(order by sal desc ) rnfrom xxx) twhere t.rn &lt;=3;\nMySQL的存储过程\n介绍\n\n\n什么是存储过程\n\n\nMySQL 5.0 版本开始支持存储过程。\n简单的说，存储过程就是一组SQL语句集，功能强大，可以实现一些比较复杂的逻辑功能，类似于JAVA语言中的方法；\n存储过就是数据库 SQL 语言层面的代码封装与重用。\n\n\n\n\n有哪些特性\n\n\n有输入输出参数，可以声明变量，有if/else, case,while等控制语句，通过编写存储过程，可以实现复杂的逻辑功能；\n函数的普遍特性：模块化，封装，代码复用；\n速度快，只有首次执行需经过编译和优化步骤，后续被调用可以直接执行，省去以上步骤；\n\n\n入门案例\n格式\ndelimiter 自定义结束符号create procedure 储存名([ in ,out ,inout ] 参数名 数据类形...)begin  sql语句end 自定义的结束符合delimiter ;\n操作-数据准备\n-- 1：创建数据库和表 create database mydb7_procedure; -- 选择mydb7_procedure数据库use mydb7_procedure;-- 创建部门表并插入数据create table dept(\tdeptno int primary key,  dname varchar(20),\tloc varchar(20));insert into dept values(10, &#x27;教研部&#x27;,&#x27;北京&#x27;),(20, &#x27;学工部&#x27;,&#x27;上海&#x27;),(30, &#x27;销售部&#x27;,&#x27;广州&#x27;),(40, &#x27;财务部&#x27;,&#x27;武汉&#x27;);-- 创建员工表并插入数据create table emp(\tempno int primary key,\tename varchar(20),\tjob varchar(20),\tmgr int,\thiredate date,\tsal numeric(8,2),\tcomm numeric(8, 2),\tdeptno int,-- \tFOREIGN KEY (mgr) REFERENCES emp(empno),\tFOREIGN KEY (deptno) REFERENCES dept(deptno) ON DELETE SET NULL ON UPDATE CASCADE);INSERT INTO emp VALUES(1001, &#x27;甘宁&#x27;, &#x27;文员&#x27;, 1013, &#x27;2000-12-17&#x27;, 8000.00, NULL, 20),(1002, &#x27;黛绮丝&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-02-20&#x27;, 16000.00, 3000.00, 30),(1003, &#x27;殷天正&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-02-22&#x27;, 12500.00, 5000.00, 30),(1004, &#x27;刘备&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-4-02&#x27;, 29750.00, NULL, 20),(1005, &#x27;谢逊&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-9-28&#x27;, 12500.00, 14000.00, 30),(1006, &#x27;关羽&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-05-01&#x27;, 28500.00, NULL, 30),(1007, &#x27;张飞&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-09-01&#x27;, 24500.00, NULL, 10),(1008, &#x27;诸葛亮&#x27;, &#x27;分析师&#x27;, 1004, &#x27;2007-04-19&#x27;, 30000.00, NULL, 20),(1009, &#x27;曾阿牛&#x27;, &#x27;董事长&#x27;, NULL, &#x27;2001-11-17&#x27;, 50000.00, NULL, 10),(1010, &#x27;韦一笑&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-09-08&#x27;, 15000.00, 0.00, 30),(1011, &#x27;周泰&#x27;, &#x27;文员&#x27;, 1008, &#x27;2007-05-23&#x27;, 11000.00, NULL, 20),(1012, &#x27;程普&#x27;, &#x27;文员&#x27;, 1006, &#x27;2001-12-03&#x27;, 9500.00, NULL, 30),(1013, &#x27;庞统&#x27;, &#x27;分析师&#x27;, 1004, &#x27;2001-12-03&#x27;, 30000.00, NULL, 20),(1014, &#x27;黄盖&#x27;, &#x27;文员&#x27;, 1007, &#x27;2002-01-23&#x27;, 13000.00, NULL, 10);-- 创建工资等级表并插入数据create table salgrade (\tgrade int,  -- 等级\tlosal double,  -- 最低工资\thisal double  -- 最高工资);-- 插入数据insert into salgrade values (1,7000,12000);insert into salgrade values (2,12010,14000);insert into salgrade values (3,14010,20000);insert into salgrade values (4,20010,30000);insert into salgrade values (5,30010,99990);-- 2：创建存储过程delimiter $$create procedure proc01()begin  select empno,ename from emp; end  $$delimiter ;-- 调用存储过程call proc01(); \nMySQL操作-变量定义\n局部变量\n格式\n\n用户自定义，在begin/end块中有效\n\n语法： 声明变量 declare var_name type [default var_value]; 举例：declare nickname varchar(32);\n操作\n-- 定义局部变量delimiter $$create procedure proc02()begin    declare var_name01 varchar(20) default &#x27;aaa&#x27;;  -- 定义局部变量    set var_name01 = &#x27;zhangsan&#x27;;   -- 给变量赋值    select var_name01;   -- 输出变量的值end $$delimiter ;-- 调用存储过程call proc02();\n\nMySQL 中还可以使用 SELECT…INTO 语句为变量赋值。其基本语法如下：\n\n-- 格式select col_name [...] into var_name[,...] from table_name wehre condition 其中：col_name 参数表示查询的字段名称；var_name 参数是变量的名称；table_name 参数指表的名称；condition 参数指查询条件。🌟注意：当将查询结果赋值给变量时，该查询语句的返回结果只能是单行单列。-- 例子delimiter $$create procedure proc03()begin  declare my_ename varchar(20) ;  select ename into my_ename from emp where empno=1001;  select my_ename;end $$delimiter ;-- 调用存储过程call proc03();\n用户变量\n格式\n\n用户自定义，当前会话（连接）有效。类比java的成员变量\n\n语法： @var_name不需要提前声明，使用即声明\n操作\ndelimiter $$create procedure proc04()begin    set @var_name01  = &#x27;ZS&#x27;;end $$delimiter;call proc04() ;select @var_name01  ;  --可以看到结果\n系统变量\n介绍\n\n\n系统变量又分为全局变量与会话变量。\n全局变量在MYSQL启动的时候由服务器自动将它们初始化为默认值，这些默认值可以通过更改my.ini这个文件来更改。\n会话变量在每次建立一个新的连接的时候，由MYSQL来初始化。MYSQL会将当前所有全局变量的值复制一份。来做为会话变量。\n也就是说，如果在建立会话以后，没有手动更改过会话变量与全局变量的值，那所有这些变量的值都是一样的。\n全局变量与会话变量的区别就在于，对全局变量的修改会影响到整个服务器，但是对会话变量的修改，只会影响到当前的会话（也就是当前的数据库连接）。\n有些系统变量的值是可以利用语句来动态进行更改的，但是有些系统变量的值却是只读的，对于那些可以更改的系统变量，我们可以利用set语句进行更改。\n\n\n系统变量-全局变量\n\n由系统提供，在整个数据库有效。\n\n格式\n语法：@@global.var_name\n操作\n-- 查看全局变量 show global variables; -- 查看某全局变量 select @@global.auto_increment_increment; -- 修改全局变量的值 set global sort_buffer_size = 40000; set @@global.sort_buffer_size = 40000;\n系统变量-会话变量\n\n由系统提供，当前会话（连接）有效\n\n格式\n语法：@@session.var_name\n操作\n-- 查看会话变量show session variables;-- 查看某会话变量 select @@session.auto_increment_increment;-- 修改会话变量的值set session sort_buffer_size = 50000; set @@session.sort_buffer_size = 50000 ;\n存储过程传参-in\n\nin 表示传入的参数， 可以传入数值或者变量，即使传入变量，并不会更改变量的值，可以内部更改，仅仅作用在函数范围内。\n\n-- 封装有参数的存储过程，传入员工编号，查找员工信息delimiter $$create procedure dec_param01(in param_empno varchar(20))begin        select * from emp where empno = param_empno;end $$ delimiter ;call dec_param01(&#x27;1001&#x27;);-- 案例-- 封装有参数的存储过程，可以通过传入部门名和薪资，查询指定部门，并且薪资大于指定值的员工信息delimiter $$create procedure dec_param0x(in dname varchar(50),in sal decimal(7,2))begin        select * from dept a, emp b where b.sal &gt; sal and a.dname = dname;end $$ delimiter ;call dec_param0x(&#x27;学工部&#x27;,20000);call dec_param0x(&#x27;教研部&#x27;,20000);\n存储过程传参-out\n\nout 表示从存储过程内部传值给调用者\n\n-- ---------传出参数：out---------------------------------use mydb7_procedure;-- 封装有参数的存储过程，传入员工编号，返回员工名字delimiter $$create procedure proc08(in empno int ,out out_ename varchar(50) )begin  select ename into out_ename from emp where emp.empno = empno;end $$ delimiter ; call proc08(1001, @o_ename);select @o_ename;-- 案例-- 封装有参数的存储过程，传入员工编号，返回员工名字和薪资delimiter $$create procedure proc09(in empno int ,out out_ename varchar(50) ,out out_sal decimal(7,2))begin  select ename,sal into out_ename,out_sal from emp where emp.empno = empno;end $$ delimiter ; call proc09(1001, @o_dname,@o_sal);select @o_dname;select @o_sal;\n存储过程传参-inout\n\ninout 表示从外部传入的参数经过修改后可以返回的变量，既可以使用传入变量的值也可以修改变量的值（即使函数执行完）\n\n-- 传入员工名，拼接部门号，传入薪资，求出年薪-- 关羽 ----&gt; 30_关羽delimiter $$create procedure proc10(inout inout_ename varchar(50),inout inout_sal int)begin  select  concat(deptno,&quot;_&quot;,inout_ename) into inout_ename from emp where ename = inout_ename;  set inout_sal = inout_sal * 12;  end $$delimiter ;set @inout_ename = &#x27;关羽&#x27;;set @inout_sal = 3000;call proc10(@inout_ename, @inout_sal) ;select @inout_ename ;select @inout_sal ;\n\n存储过程传参-in，out, inout\n总结\n\n\n\nin 输入参数，意思说你的参数要传到存过过程的过程里面去，在存储过程中修改该参数的值不能被返回\n\n\nout 输出参数:该值可在存储过程内部被改变，并向外输出\n\n\ninout 输入输出参数，既能输入一个值又能传出来一个值)\n\n\n\n流程控制-判断\n格式\n\nIF语句包含多个条件判断，根据结果为TRUE、FALSE执行语句，与编程语言中的if、else if、else语法类似，其语法格式如下：\n\n-- 语法if search_condition_1 then statement_list_1    [elseif search_condition_2 then statement_list_2] ...    [else statement_list_n]end if\n操作\n-- 输入学生的成绩，来判断成绩的级别：/*  score &lt; 60 :不及格  score &gt;= 60  , score &lt;80 :及格    score &gt;= 80 , score &lt; 90 :良好    score &gt;= 90 , score &lt;= 100 :优秀    score &gt; 100 :成绩错误*/delimiter  $$create procedure proc_12_if(in score int)begin  if score &lt; 60       then          select &#x27;不及格&#x27;;    elseif  score &lt; 80      then          select &#x27;及格&#x27; ;    elseif score &gt;= 80 and score &lt; 90       then            select &#x27;良好&#x27;;  elseif score &gt;= 90 and score &lt;= 100       then            select &#x27;优秀&#x27;;     else       select &#x27;成绩错误&#x27;;  end if;end $$delimiter  ;call proc_12_if(120)-- 输入员工的名字，判断工资的情况。delimiter $$create procedure proc12_if(in in_ename varchar(50))begin    declare result varchar(20);    declare var_sal decimal(7,2);        select sal into  var_sal from emp where ename = in_ename;    if var_sal &lt; 10000         then set result = &#x27;试用薪资&#x27;;    elseif var_sal &lt; 20000        then set result = &#x27;转正薪资&#x27;;    elseif var_sal &gt;= 20000        then set result = &#x27;元老薪资&#x27;;\t\telse \t\t\tset result = &#x27;查询名字不存在&#x27;;    end if;    select result;end$$delimiter ;call proc12_if(&#x27;庞统&#x27;);\n流程控制-case\n\nCASE是另一个条件判断的语句，类似于编程语言中的switch语法\n\n操作\n-- 语法一（类比java的switch）：case case_value    when when_value then statement_list    [when when_value then statement_list] ...    [else statement_list]end case-- 语法二：case    when search_condition then statement_list    [when search_condition then statement_list] ...    [else statement_list]end case-- 案例-- 语法一delimiter $$create procedure proc14_case(in pay_type int)begin  case pay_type        when  1           then               select &#x27;微信支付&#x27; ;        when  2 then select &#x27;支付宝支付&#x27; ;        when  3 then select &#x27;银行卡支付&#x27;;      else select &#x27;其他方式支付&#x27;;    end case ;end $$delimiter ; call proc14_case(2);call proc14_case(4);-- 语法二delimiter  $$create procedure proc_15_case(in score int)begin  case  when score &lt; 60       then          select &#x27;不及格&#x27;;    when  score &lt; 80      then          select &#x27;及格&#x27; ;    when score &gt;= 80 and score &lt; 90       then            select &#x27;良好&#x27;;  when score &gt;= 90 and score &lt;= 100       then            select &#x27;优秀&#x27;;     else       select &#x27;成绩错误&#x27;;  end case;end $$delimiter  ; call proc_15_case(88);\n流程控制-循环\n概述：\n\n\n循环是一段在程序中只出现一次,但可能会连续运行多次的代码。\n循环中的代码会运行特定的次数,或者是运行到特定条件成立时结束循环。\n\n\n循环分类：\n\n\nwhile\nrepeat\nloop\n\n\n循环控制：\n\n\nleave 类似于 break，跳出，结束当前所在的循环；\niterate类似于 continue，继续，结束本次循环，继续下一次。\n\n\n\n流程控制-循环-while\n格式\n【标签:】while 循环条件 do    循环体;end while【 标签】;\n操作\n-- 选择 mydb7_procedure 数据库use mydb7_procedure;-- 创建测试表create table user (    uid int primary key,    username varchar ( 50 ),    password varchar ( 50 ));-- 需求：向表中添加10条数据。-- -------存储过程-whiledelimiter $$create procedure proc16_while1(in insertcount int)begin    declare i int default 1;    label:while i&lt;=insertcount do        insert into user(uid,username,password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);        set i=i+1;    end while label;end $$delimiter ; call proc16_while1(10);-- -------存储过程-while + leavetruncate table user;delimiter $$create procedure proc16_while2(in insertcount int)begin    declare i int default 1;    label:while i&lt;=insertcount do        insert into user(uid,username,password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);        if i=5 then leave label;        end if;        set i=i+1;    end while label;end $$delimiter ; call proc16_while2(10);-- -------存储过程-while+iteratetruncate table user;delimiter $$create procedure proc16_while3(in insertcount int)begin    declare i int default 1;    label:while i&lt;=insertcount do        set i=i+1;        if i=5 then iterate label;        end if;        insert into user(uid,username,password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);    end while label;end $$delimiter ;call proc16_while3(10);\n流程控制-循环-repeat\n格式\n[标签:]repeat  循环体;until 条件表达式end repeat [标签];\n操作\n-- -------存储过程-循环控制-repeat use mydb7_procedure;truncate table user;  delimiter $$create procedure proc18_repeat(in insertCount int)begin     declare i int default 1;     label:repeat         insert into user(uid, username, password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);         set i = i + 1;         until  i  &gt; insertCount     end repeat label;     select &#x27;循环结束&#x27;;end $$delimiter ; call proc18_repeat(100);\n流程控制-循环-loop\n格式\n[标签:] loop  循环体;  if 条件表达式 then      leave [标签];   end if;end loop;\n操作\n-- -------存储过程-循环控制-looptruncate table user; delimiter $$create procedure proc19_loop(in insertCount int) begin     declare i int default 1;     label:loop         insert into user(uid, username, password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);         set i = i + 1;         if i &gt; 5           then            leave label;         end if;     end loop label;     select &#x27;循环结束&#x27;;end $$delimiter ; call proc19_loop(10);\nMySQL的索引\n介绍\n\n\n\n索引是通过某种算法，构建出一个数据模型，用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。\n\n\n索引类似一本书的目录，比如要查找’student’这个单词，可以先找到s开头的页然后向后查找，这个就类似索引。\n\n\n\n索引的分类(按照实现的方式类分)\n\n索引是存储引擎用来快速查找记录的一种数据结构，按照实现的方式类分，主要有Hash索引和B+Tree索引\n\nHash索引\nHash索引有时会产生Hash冲突，优化使用公式能降低冲突。\n\nB+Tree索引\n\n索引的分类(按照功能划分)\n\n按照功能划分，索引划为以下分类:\n\n\n索引的操作-创建索引-单列索引-普通索引\n介绍\n\n\n单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引;\n\n普通索引(NORMAL)：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。\n\n\n\n\n格式\ncreate database mydb5;use mydb5;-- 方式1-创建表的时候直接指定create  table student(    sid int primary key,    card_id varchar(20),    name varchar(20),    gender varchar(20),    age int,    birth date,     phone_num varchar(20),    score double,    index index_name(name) -- 给name列创建索引);-- 方式2-直接创建-- create index indexname on tablename(columnname); create index index_gender on student(gender); -- 方式3-修改表结构(添加索引)-- alter table tablename add index indexname(columnname)alter table student add index index_age(age);\n索引的操作-查看索引-单列索引-普通索引\n操作\n-- 1、查看数据库所有索引 -- select * from mysql.`innodb_index_stats` a where a.`database_name` = &#x27;数据库名’; select * from mysql.`innodb_index_stats` a where a.`database_name` = &#x27;mydb5&#x27;;-- 2、查看表中所有索引 -- select * from mysql.`innodb_index_stats` a where a.`database_name` = &#x27;数据库名&#x27; and a.table_name like &#x27;%表名%’; select * from mysql.`innodb_index_stats` a where a.`database_name` = &#x27;mydb5&#x27; and a.table_name like &#x27;%student%&#x27;;-- 3、查看表中所有索引 -- show index from table_name; show index from student;\n索引的操作-删除索引\n格式\ndrop index 索引名 on 表名; -- 或 alter table 表名 drop index 索引名;\n操作\ndrop index index_gender on student;-- 或 alter table student drop index index_name;\n索引的操作-创建索引-单列索引-唯一索引\n介绍\n\n唯一索引与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：\n\n操作-创建索引\n-- 方式1-创建表的时候直接指定create  table student2(    sid int primary key,    card_id varchar(20),    name varchar(20),    gender varchar(20),    age int,    birth date,     phone_num varchar(20),    score double,    unique index_card_id(card_id) -- 给card_id列创建索引);-- 方式2-直接创建-- create unique index 索引名 on 表名(列名) create unique index index_card_id on student2(card_id);-- 方式3-修改表结构(添加索引)-- alter table 表名 add unique [索引名] (列名)alter table student2 add unique index_phone_num(phone_num)\n操作-删除索引\ndrop index index_card_id on student2 -- 或 alter table student2 drop index index_phone_num\n\n文章作者: [Blue Eagle]\n文章链接: [https://yjh021.github.io/2024/10/04/MySQL/]\n版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 [Blue Eagle]\n\n","categories":["数据库","MySQL"],"tags":["SQL","数据库管理","学习笔记"]},{"title":"我的第一篇文章","url":"/2024/10/04/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","content":"欢迎阅读我的第一篇文章\n这是我的第一篇使用Hexo撰写的博客文章。在这里，我将分享一些关于如何使用Hexo创建和管理博客的经验。\n使用Hexo的好处\n\n简单易用：Hexo的安装和使用都非常简单，适合初学者。\n强大的生态系统：Hexo有丰富的主题和插件，可以满足各种需求。\n快速生成：Hexo可以非常快速地生成静态页面，适合大型博客。\n\n如何开始\n\n安装Node.js：确保您的计算机上安装了Node.js。\n安装Hexo：使用npm安装Hexo。\n创建站点：使用Hexo命令创建一个新的站点。\n编写文章：使用Markdown编写文章，并配置好元数据。\n生成和部署：生成静态页面并部署到服务器。\n\n希望这篇文章对您有所帮助！\n\n文章作者: [Blue Eagle]\n文章链接: [https://yjh021.github.io/2024/10/04/我的第一篇文章/]\n版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 [Blue Eagle]\n\n","categories":["技术","博客"],"tags":["Hexo","Markdown","写作"]},{"title":"Hello World","url":"/2024/10/08/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n\n文章作者: [Blue Eagle]\n文章链接: [https://yjh021.github.io/2024/10/08/hello-world/]\n版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 [Blue Eagle]\n\n"},{"title":"MySQL课程笔记","url":"/2024/12/08/MySQL%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/","content":"MySQL课程笔记\n数据库基础知识\n概念\n\n\n数据管理技术的发展阶段：人工管理阶段-〉文件系统阶段 -〉 数据库管理阶段\n所谓数据库(DataBase, DB)，是将数据按一定的数据模型组织、描述和存储，具有较小的冗余度，较高的数据独立性和易扩展性，并可为各种用户共享的数据集合。\n数据库系统(DataBase System, DBS)一般由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员和用户结构组成\n数据库管理系统（DataBase Management System, DBMS）对收集到的大量数据进行整理、加工、归并、分类、计算、存储等处理，产生新的数据，以便反映事物或现象的本质和特征及其内在联系。\n数据库应用系统(DataBase Application System, DBAS) 数据库应用系统是由数据库系统、应用程序系统、用户组成的，具体包括：数据库、数据库管理系统、数据库管理员、硬件平台、软件平台、应用软件、应用界面。\n\n\n结构化查询语言SQL\nSQL概念\n\n\n结构化查询语言SQL（Structured Query Language）,SQL语言是用于关系数据库查询的结构化语言，最早由Boyce和Chambedin在1974年提出，称为SEQUEL语言。1976年，IBM公司的San Jose研究所在研制关系数据库管理系统System R时修改为SEQUEL2，即目前的SQL语言。\nSQL-关系型数据库管理系统（RDBMS）：\n\n不同的角色（开发者，用户，数据库管理员）使用相同的语言。\n不同的RDBMS使用统一标准的语言。\nSQL使用一种高级的非结构化查询语言。\n坚持 ACID 准则 (原子性，一致性，隔离性，持久性)\n\n\nNoSQL- 非关系性数据库\n\n采用Key-value方式存储数据。采取最终一致性原则，更加适合互联网数据，但这也可能导致数据丢失。\n\n\nNewSQL-结合SQL和NoSQL\n\n将SQL的ACID保证与NoSQL的可扩展性和高性能相结合，目前大多数NewSQL数据库都是专有软件或仅适用于特定场景，这显然限制了新技术的普及和应用。\n\n\n\n主要特点包括：\n（1）综合统一\n（2）高度非过程化\n（3）面向集合的操作方式\n（4）以同一种语法结构提供两种使用方式\n（5）语言简洁，易学易用\n\n\nSQL分类\nSQL 语句，根据其功能，主要分为四类:DDL、DML、DQL、DCL 。\n\n\n\n分类\n全称\n说明\n\n\n\n\nDDL\nData Definition Language\n数据定义语言，用来定义数据库对象（数据库，表，字段)\n\n\nDML\nData Manipulation Language\n数据操作语言，用来对数据库表中的数据进行增删改\n\n\nDQL\nData Query Language\n数据查询语言，用来查询数据库中表的记录\n\n\nDCL\nData Control Language\n数据控制语言，用来创建数据库用户、控制数据库的访问权限\n\n\n\nSQL通用语法\n\n在学习具体的SQL语句之前，先来了解一下SQL语言的通用语法。\n\nSQL语句可以单行或多行书写,以分号结尾。\nSQL语句可以使用空格/缩进来增强语句的可读性。\nMySQL数据库的SQL语句不区分大小写，关键字建议使用大写。\n注释:\n单行注释:-- 注释内容 或 # 注释内容\n多行注释:/** 注释内容*  */\n\n\n注：MySQL下载安装教程详见MySQL的安装和使用。\n图形化软件\n\n本笔记所采用的图形化软件为 Navicat 。\n\n\n“Navicat”是一套可创建多个连接的数据库管理工具，用以方便管理 MySQL、Redis、Oracle、PostgreSQL、SQLite、[SQLServer](https://baike.baidu.com/item/SQL Server/245994?fromModule=lemma_inlink)、MariaDB 和 MongoDB 等不同类型的数据库，它与 GaussDB、OceanBase、PolarDB 以及 阿里云、腾讯云、华为云、Amazon RDS、Amazon Aurora、Amazon Redshift、Microsoft Azure、Oracle Cloud 和 MongoDB Atlas等云数据库兼容。它用于创建、管理和维护数据库。Navicat 的功能足以满足专业开发人员的所有需求，但是对数据库服务器初学者来说又简单易操作。Navicat 的用户界面 (GUI) 设计良好，以安全且简单的方法创建、组织、访问和共享信息。\n\nNavicat 下载\n\n\n\nNavicat 下载地址：https://www.navicat.com/en/download/navicat-premium\n\n\nNavicat 下载完成后，打开安装包，选择接受条款，一直点下一步即可。\n\n\n打开Navicat，连接到MySQL。\n\n\n\n数据库设计\n\n数据库设计就是将数据库中的数据对象以及这些数据对象之间关系进行规划和结构化的过程，当数据库比较复杂时我们需要设计数据库\n\n关系数据库设计\n数据的加工\n\n\n数据是描述事物的符号记录，模型是现实世界的抽象。\n数据模型是数据特征的抽象，包括数据的结构部分，操作部分和约束条件。\n每个事物的无穷特征如何数据化？事物之间错综复杂的关系如何数据化？现实世界直接数据化是不可行的，数据加工是一个逐步转换的过程，会经历现实世界、信息世界和数据世界三个不同层面。\n\n\n1.现实世界\n\n现实世界是存在于人们头脑之外的客观世界。现实世界存在各种事物，事物与事物之间存在联系，这种联系是由事物本身的性质决定的。\n例如，学校中有教师、学生、课程，教师为学生授课，学生选修课程并取得成绩；图书馆中有图书、管理员和读者，读者借阅图书，管理员对图书和读者进行管理等。\n\n2.信息世界\n\n\n信息世界是现实世界在人们头脑中的反映，人们把它用文字或符号记载下来，然后用规范化的数据库定义语言来定义描述而构成的一个抽象世界。信息世界实际上是对现实世界的一种抽象化描述。\n信息世界不是简单的对现实世界进行符号化，而是要通过筛选、归纳、总结、命名等抽象化过程形成概念模型，用以表示对现实世界的抽象和描述。\n\n\n3.数据世界\n\n数据世界又称机器世界，它是将信息世界的内容数据化后的产物，即将信息世界中的概念模型，进一步转换成数据模型所形成的便于计算机处理的数据表现形式。\n\n模型\n\n\n概念模型:把现实世界转换为信息世界的模型,E-R模型。\n数据模型:把信息世界转化为数据世界使用的模型,关系模型。\n\n\n\n规范化设计\n\n按照规范化设计的方法，考虑数据库及其应用系统开发的全过程，将数据库的设计分为以下6个设计阶段：\n\n\n\n需求分析、\n\n\n概念设计、\n\n\n逻辑设计、\n\n\n物理设计、\n\n\n数据库实施、\n\n\n数据库运行和维护。\n\n\n\n\n数据库设计步骤\n\n需求分析阶段\n\n需求分析就是根据用户的需求收集数据，是设计数据库的起点。需求分析的结果是否准确反映用户的实际需求，将直接影响到后面各个阶段的设计，并影响到设计结果是否合理和实用。\n需求分析的任务就是收集数据，要尽可能多地收集关于数据库要存储的数据以及将来如何使用这些数据的信息，确保收集到数据库需要存储的全部信息。\n\n\n需求分析的目标可以参考以下问题：\n（1）有多少数据，数据的来源在哪里，是否有已存在的数据资源？\n（2）必须保存哪些数据，数据是字符、数字或日期型？\n（3）谁使用数据，如何使用？\n（4）数据是否经常修改，如何修改和什么时候修改？\n（5）某个数据是否依赖于另一个数据或被其他数据引用？\n（6）某个信息是否要唯一？\n（7）哪些数据是组织内部的和哪些是外部数据？\n（8）哪些业务活动与数据有关，数据如何支持业务活动？\n（9）数据访问的频度和增长的幅度如何？\n（10）谁可以访问数据，如何保护数据。\n\n\n需求分析的方法，常用的调查方法：\n（1）跟班作业。通过亲身参加业务工作来了解业务活动的情况。通过这种方法可以比较准确地了解用户的需求，但比较耗费时间。\n（2）开调查会。通过与用户座谈来了解业务活动情况及用户需求。座谈时，参加者和用户之间可以相互启发。\n（3）请专人介绍。\n（4）询问。对某些调查中的问题，可以找专人询问。\n（5）问卷调查。设计调查表请用户填写。如果调查表设计得合理，这种方法是很有效的，也易于为用户所接受。\n（6）查阅记录。查阅与原系统有关的数据记录。\n\n概念设计阶段\n\n概念设计是整个数据库设计的关键，它通过对用户的需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型。\n设计人员完成了数据库设计的第一步，收集到了现实世界中的数据，下一步的工作是将收集到的数据进行分析，找出它们之间的联系，并用E-R图来表示。\n\n\n概念模型的相关概念：\n\n\n实体（Entity）：客观存在并且可以相互区别的事物称为实体。实体可以是具体的事物，也可以是抽象的事件。\n\n\n属性（Attribute）：描述实体的特性。一个实体可以用若干个属性来描述。\n\n\n主码（Key）：唯一标识实体的属性或属性的组合。\n\n\n域（Domain）：属性的取值范围称为该属性的域。\n\n\n实体集（Entity Set）：具有相同特征和性质的同一类实体的集合称为实体集。例如全体学生、一批图书等。\n\n\n联系（Relationship）：\n在现实世界中，事物内部以及事物之间是有联系的，这些联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。\n实体内部的联系通常是指组成实体的各属性之间的联系；\n实体之间的联系通常是指不同实体集之间的联系。\n\n\n\n\n两个实体之间的联系可以分为 3类。\n（1）一对一(1:1)联系（One-to-One Relationship）。\n例如，如果一个人只能有一个身份证，一个身份证只能对应一个人，则人和身份证之间具有一对一的联系。\n（2）一对多(1:n)联系（One-to-Many Relationship）。\n例如，一个人可以有多个移动电话号码，但一个电话号码只能卖给一个人。人与移动电话号码之间的联系就是一对多的联系。\n（3）多对多(m:n)联系（Many-to-Many Relationship）。\n例如，一门课程同时可以由若干学生选修，而一个学生同时也可以选修若干门课程，课程与学生之间的联系是多对多的联系。\n\n\n概念模型是对信息世界的建模，它应当能够全面、准确地描述信息世界，是信息世界的基本概念。\n概念模型用于建立信息世界的模型，它是独立于计算机系统的模型，强调其语义表达功能，要求概念简单、清晰，易于用户理解，它是现实世界的第1层抽象，是用户和数据库设计人员之间进行交流的工具。\n概念模型的表示方法很多，其中最为著名和使用最为广泛的是P.P.Chen于1976年提出的E-R（Entity-Relationship）模型。\n\n\nE-R图的组成要素及其画法\n\n\n概念结构设计的方法：\n（1）自顶向下。首先定义全局概念结构的框架，然后逐步细化。\n（2）自底向上。首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构。\n（3）逐步扩张。首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构。\n（4）混合策略。将自顶向下和自底向上的方法相结合，用自顶向下策略设计一个全局概念结构的框架，以它为框架自底向上设计各局部概念结构。\n最常采用的是混合策略，即自顶向下进行需求分析，然后自底向上设计概念结构。\n\n\n\n概念结构设计的步骤\n（1）进行数据抽象，设计局部E-R模型。\n（2）集成各局部E-R模型，形成全局E-R模型。\n\n\n\nE-R图设计步骤 ：\n对于复杂的系统，E-R图设计通常都应经过以下两个阶段：\n（1）针对每一用户画出该用户信息的局部E—R图，确定该用户视图的实体、属性和联系。需注意的是：能作为属性的就不要作为实体，这有利于E—R图的简化。\n（2）综合局部E—R图，生成总体E—R图。在综合过程中，同名实体只能出现一次，还要去掉不必要的联系，以便消除冗余。一般来说，从总体E—R图必须能导出原来的所有局部视图，包括实体、属性和联系。\n\n逻辑设计阶段\n\n概念设计阶段完成后，下一步进入逻辑设计阶段，即将概念模型转换成某个DBMS所支持的数据模型，并对其进行优化。\n\n数据模型\n\n数据模型：它是直接面向数据库的逻辑结构，是现实世界的第2层抽象。\n数据模型涉及计算机系统和数据库管理系统。数据模型有严格的形式化定义，以便于在计算机系统中实现。\n\n常见数据模型：\n1.层次模型：用“树”结构来表示数据之间的关系\n\n优点：\n简单，只需很少几条命令就能操纵数据库。\n性能优于关系模型和网状模型。\n提供良好的完整性支持。\n缺点：\n不支持多对多联系，只能通过冗余数据（易产生数据不一致性）或引入虚拟结点来解决。\n\n\n2.网状模型：用“图”结构来表示数据之间的关系\n\n优点：\n​\t能更直接地反映现实世界，效率高。\n缺点：\n​\t结构比较复杂，DDL和DML语言复杂。\n\n\n3.关系模型：用“表”结构（或称关系）来表示数据之间的关系。\n\n优点：\n​\t建立在严格的数学概念的基础上，概念单一，数据结构简单、清晰，用户易懂易用。\n​\t实体和各类联系都用关系来表示，对数据的检索结果也是关系。\n​\t关系模型的存取路径对用户透明，具有更高的数据独立性，更好的安全保密性。\n​\t简化了程序员的工作和数据库开发建立的工作，关系模型中的数据联系是靠数据冗余实现的。\n缺点：\n​\t存取路径对用户透明导致查询效率往往不如非关系数据模型。\n​\t为提高性能，必须对用户的查询请求进行优化从而增加了开发数据库管理系统的难度。\n\n\nE—R模型到关系模型的转换\n\n把E-R图转换为关系模型可遵循如下原则 ：\n1.对于E—R图中每个实体集，都应转换为一个关系，该关系应包括对应实体的全部属性，并应根据关系所表达的语义确定哪个属性或哪几个属性组作为“主关键字”，主关键字用来标识实体。\n2.对于E—R图中的联系，情况比较复杂，要根据实体联系方式的不同，采取不同的手段加以实现。\n\n\n转换规则：（必须牢记！！）\n规则1.1 实体类型的转换：将每个实体类型转换成一个关系模式，实体的属性即为关系的属性，实体的标识符即为关系模式的码。\n规则1.2 联系类型的转换：根据不同的联系类型做不同的处理。\n\n\n规则1.2.1 若实体间联系是1∶1，可以在两个实体类型转换成的两个关系模式中任意一个关系模式中加入另一个关系模式的码和联系类型的属性。\n\n【例】将下图所示的含有1∶1联系的E-R图根据上述规则转换为关系模式。\n\n方案1：“负责”与“职工”两关系模式合并。\n职工（职工号，姓名，年龄，产品号）\n产品（产品号，产品名，价格）\n​\t或者：\n方案2：“负责”与“产品”两关系模式合并。\n职工（职工号，姓名，年龄）\n产品（产品号，产品名，价格，职工号）\n\n\n\n规则1.2.2 若实体间的联系是1∶n，则在n端实体类型转换成的关系模式中加入1端实体类型的码和联系类型的属性。\n\n【例】将下图所示的含有1∶n联系的E-R图根据上述规则转换为关系模式。\n\n仓库（仓库号，地点，面积）\n产品（产品号，产品名，价格，仓库号，数量）\n\n\n\n规则1.2.3 若实体间联系是m∶n，则将联系类型也转换成关系模式，其属性为两端实体类型的码加上联系类型的属性，而码为两端实体码的组合。\n\n【例】将下图所示的含有m∶n联系的E-R图根据上述规则转换为关系模式。\n\n商店（店号，店名，店址，店经理）\n商品（商品号，商品名，单价，产地）\n经营（店号，商品号，月销售量）\n\n\n\n规则1.2.4  3个或3个以上的实体间的一个多元联系，不管联系类型是何种方法，总是将多元联系类型转换成一个关系模式，其属性为与该联系相连的各实体的码及联系本身的属性，其码为各实体码的组合。\n\n【例】将下图所示的多实体集间含有m∶n联系的E-R图根据上述规则转换为关系模式。\n\n供应商（供应商号，供应商名，地址）\n零件（零件号，零件名，单价）\n产品（产品号，产品名，型号）\n供应（供应商号，零件号，产品号，数量）\n\n\n数据库设计规范化\n\n仅有好的RDBMS并不足以避免数据冗余，必须在数据库的设计中创建好的表结构\n关系数据库范式理论是在数据库设计过程中将要依据的准则，数据库结构必须要满足这些准则，才能确保数据的准确性和可靠性。这些准则则被称为规范化形式，即范式。\nDr E.F.codd 最初定义了规范化的三个级别，范式是具有最小冗余的表结构。这些范式是：\n\n第一范式(1st NF －First Normal Fromate)\n第二范式(2nd NF－Second Normal Fromate)\n第三范式(3rd NF－ Third Normal Fromate)\n\n\n函数依赖\n\n实体之间，实体内部的各个特征之间的相互依赖和制约关系——自然反映到关系数据库中的各关系和关系内部的各属性之间。\n关系是由属性构成，函数依赖就是讲属性之间的依赖。\n\n定义1函数依赖：\n\n设有关系模式R(U )，X和Y均为U={A1，A2，…，An}的子集，若对于元素中X上的每个值都有Y上的一个惟一值与之相对应，则称X函数决定Y，或称Y函数依赖于X，记作X→Y，其中X叫做决定因素（Determinant），Y叫做依赖因素（Dependent）。\n\n\n练习：指出学生关系S中存在的函数依赖关系\nS（学号，姓名，班号，班级，课程号，教师，成绩）\n学号 →姓名（每个学号只能有一个学生姓名）\n学号 →班级（每个学号只能有一个班级）\n（学号，课程号）→成绩（每个学生每门课只有一个成绩）\n\n定义2：部分函数依赖 、完全函数依赖\n\n在关系模式R(U )中，X和Y为属性集U上的子集，若X→Y，并且对于X的任何一个真子集X¢，都有X¢ → Y，则称X部分函数决定Y或Y部分函数依赖X，记作X   Y。\n否则，若不存X的任何一个真子集X¢，使得X¢→Y，则称X完全函数决定Y或 Y完全函数依赖于X， 记作X   Y。\n\n\n练习：指出学生关系S中存在的函数依赖关系是部分依赖还是完全依赖\nS（学号，姓名，班号，班级，课程号，教师，成绩）\n学号 →姓名（完全函数依赖）\n学号 →班级（完全函数依赖）\n（学号，课程号）→成绩（完全函数依赖）\n（学号，课程号）→姓名（部分函数依赖）\n\n定义3：传递函数依赖\n\n在关系模式R(U )中，X、Y、Z是属性集U上的子集，如果X→Y ，**Y→Z，但Y不包含于X，Y不能函数决定X,则存在X → Z。\n\n\n练习：指出学生关系S中存在的函数依赖关系是否存在传递函数依赖\nS（学号，姓名，班号，班级，课程号，教师，成绩）\n学号 →班号   班号 →班级 （班号不属于学号，班号不决定学号）\n学号→班级\n所以班级传递依赖于学号\n\n\n属性间联系决定函数依赖\n① 1∶1联系：如果两属性集X、Y之间是1∶1联系，则存在函数依赖X  Y。\n② 1∶n联系：如果两属性集X、Y之间是n∶1联系，则存在函数依赖X→Y，即多方决定一方。\n③ m∶n联系：如果两属性集X、Y之间是m∶n联系，则不存在函数依赖。\n\n定义4：候选码\n\n在关系模式R(U )中，X是属性集U上的子集，如果X能够函数决定U中的每个属性*，*并且X的任何真子集都不能函数决定U中的每个属性，则称X为关系R上的一个候选码。\n在一个关系中可以有多个候选码，可能是某几个属性，也可能是某几个属性的组合。\n\n\n练习：指出学生关系S的候选码\nS（学号，姓名，班号，班级，课程号，教师，成绩）\n学号 →姓名，学号 →班号，班号→班级\n（学号，课程号）→成绩\n所以学生关系S的候选码是（学号，课程号）\n\n定义5：主码/主键 主属性\n\n一个关系包含多个候选码，可选取一个作为主码/主键。\n\n定义6：主属性\n\n主属性：包含在任一候选码中的属性称为主属性，其他为非主属性。\n\n关系数据库范式理论\n\n（1）第一范式：若关系模式R(U)的 每个分量都是不可分割的数据项，则R(U)∈1NF\n\n\n\n（2）第二范式：若R(U)∈1NF，且R(U)中的每一个非主属性都完全函数依赖于R(U)的任一候选码，则R(U)∈2NF\n\n\n\n\n学号\n姓名\n班号\n地址\n课程号\n课程名\n教师\n成绩\n\n\n\n\n01001\n王丽\n01\n河北省石家庄市裕华路\nC001\nC语言\n刘峰\n80\n\n\n01002\n张勇\n01\n河北省保定市裕华路\nC001\nC语言\n刘峰\n75\n\n\n01003\n李江\n01\n河北省邢台市新华路\nC001\nC语言\n刘峰\n86\n\n\n\n\n候选码：学号，课程号\n非主属性：姓名，班号，地址，课程名，教师，成绩\n函数依赖（学号，课程号）→姓名 是部分函数依赖\n\n\n\n\n学号\n姓名\n班号\n地址\n教师\n\n\n\n\n01001\n王丽\n01\n河北省石家庄市裕华路\n刘峰\n\n\n01002\n张勇\n01\n河北省保定市裕华路\n刘峰\n\n\n01003\n李江\n01\n河北省邢台市新华路\n刘峰\n\n\n\n\n第二范式还是存在数据冗余，操作异常情况\n\n\n（3）第三范式：如果关系R(U)中的每一个非主属性都不传递函数依赖于R(U)的任一候选码，则R(U)∈3NF\n\n\n\n\n学号\n姓名\n班号\n班级\n教师\n成绩\n\n\n\n\n01001\n王丽\n01\n21级计算机网络技术\n刘峰\n80\n\n\n01002\n张勇\n01\n21级计算机网络技术\n刘峰\n75\n\n\n01003\n李江\n01\n21级计算机网络技术\n刘峰\n86\n\n\n\n\n候选码：学号\n非主属性：姓名，班号，班号，教师，成绩\n学号→班号，班号→班级 所以 学号→班级 是传递函数依赖\n\n数据库规范化实例\n\n规范化理论\n​\t利用规范化力量来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。\n\n\n解决之道：分解、分解、再分解！\n让一个关系模式尽量只描述一个概念、一个实体或一种实体之间的联系，概念单一！\n\n例如：\n\n\n\n学号\n姓名\n性别\n年龄\n班级编号\n班级名称\n课程编号\n课程名\n成绩\n\n\n\n\n00101\n王丽\n女\n20\n001\n22级计算机班\nC001\nC语言\n80\n\n\n00201\n张勇\n男\n18\n002\n22级会计班\nC010\n经济法\n75\n\n\n00102\n李江\n男\n19\n001\n22级计算机班\nC002\n数据结构\n86\n\n\n\n\n候选码：（学号，课程编号）\n（学号，课程号）→姓名 是部分函数依赖\n学号→班级编号 班级编号→班级名称是传递函数依赖\n\n数据库规范化实例——关系分解\n1NF→2NF：去掉部分依赖分解过程\n\n\n\n学号\n姓名\n性别\n年龄\n班级编号\n班级名称\n课程编号\n课程名\n成绩\n\n\n\n\n00101\n王丽\n女\n20\n001\n22级计算机班\nC001\nC语言\n80\n\n\n00201\n张勇\n男\n18\n002\n22级会计班\nC010\n经济法\n75\n\n\n00102\n李江\n男\n19\n001\n22级计算机班\nC002\n数据结构\n86\n\n\n\n\n分解方法：候选码属性集合的每个子集，用它作为主键，将依赖于此主键的属性放置到此关系模式中，构成一个新关系模式\n\n\n候选码：（学号，课程编号）\n子集：学号，课程编号，（学号，课程编号）\n学生（学号，姓名，性别，年龄，班级编号，班级名称）\n课程（课程编号，课程名称）\n选课（学号，课程编号，成绩）\n\n\n\n学生（学号，姓名，性别，年龄，班级编号，班级名称）\n候选码：学号\n学号→班级编号 班级编号→班级名称是传递函数依赖\n\n\n分解方法：对于不是候选码的每个决定因子（班级编号），新建一个关系模式，将决定因子作为新关系模式的主键，在新关系模式中包含在原关系模式中所有依赖于该决定因子的属性（班级名称），从原关系模式中删去依赖于它的所有属性（班级名称）。\n\n\n学号→班级编号 班级编号→班级名称是传递函数依赖\n\n\n学生（学号，姓名，性别，年龄，班级编号，班级名称）\n学生（学号，姓名，性别，年龄）\n班级（班级编号，班级名称）\n\n2NF→3NF：去掉传递依赖分解过程\n\n\n学生（学号，姓名，性别，年龄）\n班级（班级编号，班级名称）\n课程（课程编号，课程名称）\n选课（学号，课程编号，成绩）\n\n规范化和性能的关系\n\n为满足某种商业目标，数据库性能比规范化数据库更重要\n\n\n\n通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间\n通过在给定的表中插入计算列（如成绩总分），以方便查询\n\n\n\n进行规范化的同时，还需要综合考虑数据库的性能。\n\n总结\n\n在需求分析阶段，设计数据库的一般步骤为：\n​\t收集信息\n​\t标识对象\n​\t标识每个对象的属性\n​\t标识对象之间的关系\n在概要设计阶段和详细设计阶段，设计数据库的步骤为：\n​\t绘制E-R图\n​\t将E-R图转换为表格\n​\t应用三大范式规范化表格\n为了设计结构良好的数据库，需要遵守一些专门的规则，称为数据库的设计范式。\n​\t第一范式（1NF）的目标：确保每列的原子性。\n​\t第二范式（2NF）的目标：确保表中的每列，都和主键相关 。\n​\t第三范式（3NF）的目标：确保每列都和主键列直接相关，而不是间接相关 。\n\n数据定义语言—DDL\nMySQL数据库文件介绍\n\n数据库管理的核心任务包括创建、操作和支持数据库。在MySQL中，每个数据库都对应存放在一个与数据库同名的文件夹中。\nMySQL数据库文件有“.frm”、“.MYD”和“.MYI”3种文件，其中“.frm”是描述表结构的文件，“.MYD”是表的数据文件，“.MYI”是表数据文件中的索引文件。它们都存放在与数据库同名的文件夹中。\n\nMySQL数据库模型\n\n\n在数据库服务器中可以存储多个数据库文件，所以建立数据库时要设定数据库的文件名，每个数据库有惟一的数据库文件名作为与其它数据库区别的标识。\n数据库文件： 数据库是由相关数据表组成，一个数据库包括多个数据表。数据库文件用于记录数据库中数据表构成的信息。\n数据库只能由得到授权的用户访问，这样保证了数据库的安全。\n\n\n数据库和表\n\n数据库可以看成是一个存储数据对象的容器，这些数据对象包括表、视图、触发器、存储过程等，其中，表是最基本的数据对象，用以存放数据库的数据。\n\n\n必须首先创建数据库，然后才能创建数据库的数据对象。\nMySQL可以采用两种方式：\n创建、操作数据库和数据对象\n（1）命令行方式\n（2）图形界面工具方式\n\n\nMySQL自动建立的数据库介绍\n​     MySQL安装完成之后，将会在其data目录下自动创建information_schema、mysql、performance_schema、sys四个系统数据库。\n​     可以使用SHOW DATABASES命令来查看当前所有存在的数据库。\n\n创建数据库\n\nMySQL安装后，系统自动地创建information_scema和MySQL数据库，MySQL把有关数据库的信息存储在这两个数据库中。如果删除了这些数据库，MySQL就不能正常工作。\n对于用户的数据，需要创建新的数据库来存放。\n\n-- 语法格式：CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] 数据库名        [ [DEFAULT] CHARACTER SET 字符集名 | [DEFAULT] COLLATE 校对规则名]-- 说明：语句中“[ ]”内为可选项。-- &#123;  |  &#125;表示二选一。-- 例如：Create database bookstore;\n\n在SQL语言创建数据库命令create database中，如果省略语句中“[ ]”中的所有可选项，其结构形式如下：\n\nCREATE DATABASE 数据库名;\n\nMySQL数据库命名规则：\n\n不能与其他数据库重名\n名称可以由任意阿拉伯数字、字母、下划线和“$”组成，可以使用以上任意字符头，但不能使用单独的数字，否则会与其他数字混淆\n名称最长64个字符\n不能使用MySQL关键字\n默认情况下，Windows对数据库大小写不敏感，而在Linux下对大小写是敏感的，为了数据库在不同平台下移植，建议使用小写数据库名。\n\n\n-- 【例3.1】 创建一个名为Bookstore的数据库。CREATE DATABASE Bookstore; \n显示数据库命令\n\n显示服务器中已建立的数据库，使用SHOW DATABASES;命令。\n\n-- 语法格式：SHOW DATABASES;\n\n此命令没有用户变量，执行“SHOW DATABASES;” 。\n注意：在MySQL中，每一条SQL语句都以“;”作为结束标志。\n\n打开数据库\n\n因为MySQL服务器中有多个数据库，可以使用USE命令可指定当前数据库。\n\n-- 语法格式：USE 数据库名;\n\n说明：这个语句也可以用来从一个数据库“跳转”到另一个数据库，在用CREATE DATABASE语句创建了数据库之后，该数据库不会自动成为当前数据库，需要用这条USE语句来指定。\n\n-- 【例】将数据库test1设置为当前数据库。Use test1;\n修改数据库\n\n数据库创建后，如果需要修改数据库的参数，可以使用ALTER DATABASE;命令。\n\n-- 语法格式：ALTER &#123;DATABASE | SCHEMA&#125; [数据库名]               [[DEFAULT] CHARACTER SET 字符集名 | [DEFAULT] COLLATE 校对规则名]-- 【例3.3】 修改数据库Pet的默认字符集为latin1，校对规则为latin1_swedish_ci。ALTER DATABASE PetDEFAULT CHARACTER SET latin1DEFAULT COLLATE  latin1_swedish_ci; \n删除数据库\n\n已经创建的数据库需要删除，使用DROP DATABASE命令。\n\n-- 语法格式：DROP DATABASE  [IF EXISTS] 数据库名;-- 例如，数据库test2命令如下：DROP DATABASE  test2;\nMySQL数据类型\n\n\n确定表中每列的数据类型是设计表的重要步骤。\n列的数据类型就是定义该列所能存放的数据的值的类型。\n\n\n\n\n\n字符串类型\n数值类型\n时间类型\n大数据类型\n\n\n\n\nChar(n)\nint\ndate\nblob\n\n\nVarchar(n)\nFloat(M,D)\ntime\ntext\n\n\n\n\ndatetime\n\n\n\n\n\nMySQL常用数据类型：\n\n整数类型\n浮点数类型和定点数类型\n字符串类型\n日期时间类型\n复合类型\n\n\n整数类型\n\n在int类型里，MySQL支持tinyint、smallint、mediumint、int、bigint 5种类型，这些类型都是用来存放整形数据的，只不过存储的值的大小范围不一样。\n\n\n浮点数类型和定点数类型\n\nMySQL支持float、double、decimal 3种类型，float是单精度浮点数值、double是双精度浮点数值、decimal是定点数值，如果确定数值总长度以及小数点位数，就可以用decimal定点数值来表示。\n\n\n\n**提示：**存储数值范围越小，精度越高；存储数值范围越大，精度就越不准确。对于既要求精度又固定小数点位数的数值存储，采用decimal（numeric），其优点在于可以自定义小数点位数，精度高。某些特殊情况，如数值范围巨大则只能用float（real）类型了，此类型一般不提倡使用。\n\n字符串类型\n\nMySQL数据库提供了几种基本字符串类型，它们用来存放一个字符、一个字符串、巨大的文本或者二进制字符串数据。\n\n\n日期时间类型\n\nMySQL数据库提供了5种不同的日期时间类型，用来存储和日期时间相关的数据，每个时间类型有一个有效值范围和一个“零”值，当指定不合法的MySQL不能表示的值时使用“零”值。\n\n\n\n**提示：**MySQL数据库用date日期类型和datetime日期时间类型来存储日期值，使用time时间类型来存储时间值，使用year来存放年份值，date 类型的值应该用连字号“-”分隔开，而 time 类型的值应该用冒号“:”分隔开。\n\n如何选取数据类型\n\n数据类型的选择会影响存储空间的开销和数据查询性能，所以在设计数据库的时候，应该为存储的数据选择正确的存储数据类型。\n\n\n可以遵循以下原则来选取数据类型：\n（1）大小合适就是最好的，如存放姓名的字段类型，设置合适长度的字符串就可以，而不应该设置得非常大（65 535），因为这样可以用更少的磁盘容量、CPU缓存，大大减少了I/O开销。\n（2）简单存放就好，如存放一个简单而又短小的字符串，可以选取varchar类型，而不应该选取text或者blob类型，简单的数据类型操作通常需要更少的CPU周期。\n（3）尽量避免使用NULL，NULL是列默认的属性，通常我们要指定为NOT NULL。有NULL的列值会使得索引、索引统计和值比较更加复杂。\n（4）数据类型的选择还应该考虑数据操作和应用处理的要求，如某些类型更适合于加快数据操作而不是其他方面。\n（5）如果想用不同的标准对一列中所有的值进行排序，那么我们需要选择一种能够有效执行这些功能并且带有最大限度灵活性的类型。对相应字段添加索引，能够加快检索速度。需要保证使用的数据类型支持比较运算，并且相互兼容。\n\nchar和varchar\n\n​\tchar是固定长度的，查询速度比varchar快得多。char的缺点是浪费存储空间。检索char列时，返回的结果会删除尾部空格，所以程序需要对空格进行处理。\n​\t如果列中要存储的数据的长度差不多是一致的，则应该考虑使用char，否则应该考虑使用varchar；如果列中最大数据的长度小于50Byte，则一般也考虑使用char(当然，如果这个列很少用，则基于节省空间和减少I/O的考虑，还是可以使用varchar)；一般不宜定义大于50Byte的char类型列。\n\ntext和blob\n\n​\t在保存大文本时，通常选择text或者blob。二者的差别是blob可以保存二进制数据，如照片。text和blob又包括text、mediumtext、longtext和blob、mediumblob、longblob，它们之间的区别是存储文本长度不同和存储字节不同。在不必要的时候避免检索大型的blob或text值。把blob或text列分离到单独的表中。\n\n浮点数和定点数\n\n​\t浮点数存在误差问题，因此对于货币等对精度敏感的数据，应该用定点数表示或存储。在编程中，如果用到浮点数，要特别注意误差问题，并尽量避免做浮点数比较；要注意一些特殊值的处理。\n​\tdecimal用于存储精确数据，而float只能用于存储非精确的数据，故精确数据最好使用decimal类型；由于float的存储空间的开销一般比decimal小（精确到7位小数只需要4个字节，而精确到15位小数只需要8个字节），故非精确数据类型建议使用float。\n\n日期类型的选择\n\n​\t根据实际需要选择能够满足应用的最小存储日期类型。如果记录年、月、日、时、分、秒，并且记录年份比较久远，则最好使用datetime，不要使用timestamp；如果记录的日期需要让不同时区的用户使用，则最好使用timestamp，因为日期类型中只有它能够和实际时区相对应。\n\n创建数据表\n\n为数据库创建数据表，可以使用SQL命令CREATE TABLE来完成\n\n-- 语法格式：CREATE TABLE [IF NOT EXISTS] tbl_name      （列名1  数据类型1  [NOT NULL | NULL] [DEFAULT 列默认值]…，         列名2  数据类型 2 [NOT NULL | NULL] [DEFAULT 列默认值]…       ）       ENGINE = 存储引擎；\n-- 【例】命令行SQL语句方式创建数据库表book\n\n\n\n字段名\n字段类型\n宽度\n是否为空\n默认值\n说明\n\n\n\n\n图书编号\nchar\n10\nx\n\n主键，采用10位字符编号\n\n\n类别\nchar\n8\nx\n计算机\n2-4个汉字\n\n\n书名\nvarchar\n40\nx\n\n不超过40个字符\n\n\n出版时间\ndate\n\nx\n\n\n\n\n单价\nFloat\n5,2\n√\n\n元为单位，精确到分\n\n\n数量\nint\n\n√\n\n\n\n\n\n-- 命令如下：CREATE TABLE  book (       图书编号  char(10)   NOT NULL,       类别  varchar(8)  NOT NULL  DEFAULT  &#x27;计算机&#x27;,       书名       varchar(40)  NOT  NULL ,       出版时间   date        NOT  NULL ,       单价      float(5,2)    NULL ,       数量      int   ); \n显示数据表文件名\n-- 语法格式： SHOW TABLES;-- 【例】显示Bookstore 数据库建立的数据表文件:USE Bookstore;  SHOW TABLES;\n显示数据表结构\n-- 语法格式(DESC是DESCRIBE的简写，二者用法相同。)：&#123;DESCRIBE | DESC&#125; 表名 [列名 | 通配符 ]-- 【例】 用DESCRIBE语句查看 Book 表的列的信息。USE Bookstore;DESCRIBE Book;-- 【例】 查看 Book 表图书编号列的信息。USE Bookstore;DESC Book 图书编号;\n修改表\n\n**ALTER TABLE**用于更改原有表的结构。例如，可以增加或删减列，创建或取消索引，更改原有列的类型，重新命名列或表，还可以更改表的评注和表的类型。\n\n-- 语法格式：ALTER TABLE 表名  ADD [COLUMN] 列定义  [FIRST | AFTER列名]                \t /*添加列*/\t  | ALTER [COLUMN] 列名 &#123;SET DEFAULT 默认值| DROP DEFAULT&#125; \t /*修改默认值*/  | CHANGE [COLUMN] 旧列名 列定义    [FIRST|AFTER列名]\t\t  /*对列重命名*/               | MODIFY [COLUMN] 列定义 [FIRST | AFTER 列名]\t\t \t    /*修改列类型*/  | DROP [COLUMN] 列名\t\t\t\t\t\t\t\t\t/*删除列*/  | RENAME [TO] 新表名\t     \t\t\t\t\t\t\t    /*重命名该表*/ \n增加列\n-- 语法格式ALTER TABLE  表名   ADD  列定义  [FIRST | AFTER  列名];-- 【例】在表book中增加一列“浏览次数”。ALTER TABLE book  ADD 浏览次数 int NULL;-- 【扩展】在表book中增加一列“浏览次数”，位置在单价列的后面。ALTER TABLE book  ADD 浏览次数 int NULL after 单价;\n删除列\n-- 语法格式ALTER TABLE  表名  DROP 列名-- 【例】删除book表中“浏览次数”列。ALTER TABLE book DROP 浏览次数;-- 【扩展】在表book中增加“浏览次数”列，删除“封面图片”列。ALTER TABLE book  ADD 浏览次数 int NULL, DROP 封面图片;\n更改列名\n-- 语法格式ALTER TABLE  表名  CHANGE  旧列名  列定义 -- 【例】将book表中“出版时间”列改为“出版日期”列。ALTER TABLE book  CHANGE 出版时间 出版日期 date not null;\n更改列类型\n-- 语法格式ALTER TABLE  表名  MODIFY 列定义-- 【例】将book表中“出版日期”列类型改为日期时间类型。ALTER TABLE book MODIFY 出版日期 datetime not null;\n总结\n\nALTER TABLE用于更改原有表的结构。可以增加或删减列，创建或取消索引，更改原有列的类型，重新命名列或表，还可以更改表完整性约束和表的类型等。\n\n增加列：ALTER TABLE  表名  ADD  列定义删除列：ALTER TABLE  表名  DROP 列名更改列名：ALTER TABLE  表名  CHANGE  旧列名  列定义 更改列类型：ALTER TABLE  表名  MODIFY 列定义\n复制表\n\n\n使用LIKE关键字创建一个与参照表相同结构的新表，但内容不会复制，因此创建的新表是一个空表。\n使用AS关键字可以复制表的内容，但索引和完整性约束是不会复制的。\n\n\n-- 语法格式如下：CREATE TABLE [IF NOT EXISTS] 新表名     [ LIKE 参照表名 ] | [AS (select语句)]\t-- 【例】 假设数据库BookStore中有一个表Book，创建Book表的一个名为book_copy1的拷贝。CREATE TABLE book_copy1 LIKE Book; \n删除表\n\n这个命令将表的描述、表的完整性约束、索引及和表相关的权限等都全部删除。\n\n-- 语法格式如下：DROP  TABLE [IF EXISTS] 表名1 [,表名2 ] ...-- 【例】 删除表test。USE XSCJ  DROP  TABLE  IF  EXISTS  test ;\n数据完整性\n\n数据完整性有以下几个方面：\n\n实体完整性\n域完整性\n参照完整性\n用户定义的完整性\n\n\n\n\n\n完整性类型\n约束类型\n描 述\n约束对象\n\n\n\n\n列完整性\nDefault\n当使用INSERT语句插入数据时，若已定义默认值的列没有提供指定值，则将该默认值插入记录中\n列\n\n\n列完整性\nCheck\n指定某一列可接受的值\n列\n\n\n实体完整性\nPrimary Key\n每行记录的惟一标识符，确保用户不能输入重复值，并自动创建索引，提高性能，该列不允许使用空值\n行\n\n\n实体完整性\nUnique\n在列集内强制执行值的惟一性，防止出现重复值，表中不允许有两行的同一列包含相同的非空值\n行\n\n\n参考完整性\nForeign Key\n定义一列或几列，其值于本表或其他表的主键或UNIQUE列相匹配\n表与表之间\n\n\n\n\n提示：\n使用SQL语句给数据表添加约束有两种方式：\n\n一是在创建数据表时，将约束语句添加在相应字段或数据表中。\n二是在已有的数据表中，使用ADD 语句将约束添加在相应的字段或数据表中。\n\n\n主键约束——primary key\n\n\n主键就是表中的一列或多个列的一组，其值能唯一地标志表中的每一行。\n通过定义PRIMARY KEY约束来创建主键，而且PRIMARY KEY约束中的列不能取空值。\n如果 PRIMARY KEY 约束是由多列组合定义的，则某一列的值可以重复，但 PRIMARY KEY 约束定义中所有列的组合值必须唯一。\n可以用两种方式定义主键：作为列或表的完整性约束。作为列的完整性约束时，只需在列定义的时候加上关键字PRIMARY KEY。作为表的完整性约束时，需要在语句最后加上一条PRIMARY KEY（col_name，…）语句。\n\n\n语法格式\n-- 1、创建数据表添加主键约束的语法格式为：CREATE  TABLE  tb_name    ( 列名  数据类型  NOT NULL PRIMARY KEY/*列级*/| PRIMARY KEY(列名1[,列名2]); /*表级*/-- 2、在已有数据表添加主键约束的语法格式为：ALTER  TABLE  tb_name ADD PRIMARY KEY(列名1[,列名2]);-- 3、删除主键约束的语法格式为：ALTER  TABLE  tb_name DROP PRIMARY KEY;\n案例\n-- （1）列的完整性约束：-- 【例】 创建表book2，将编号定义为主键。CREATE TABLE book2    (  编号 char(6)  NOT NULL PRIMARY KEY,       书名 char(10)  NOT  NULL,       数量 int );-- （2）表的完整性约束：-- 【例】在已有的cj表，将学号和课程号定义为复合主键。ALTER   TABLE cjADD PRIMARY  KEY (学号, 课程号);\n\n原则上，任何列或者列的组合都可以充当一个主键。但是主键列必须遵守一些规则。\n（1）每个表只能定义一个主键。\n（2）关系模型理论要求必须为每个表定义一个主键。\n（3）唯一性原则：表中的两个不同的行在主键上不能具有相同的值。\n（4）最小化规则：如果从一个复合主键中删除一列后，剩下的列构成主键仍然满足唯一性原则，那么，这个复合                   \t主键是不正确的，这条规则称为最小化规则。\nMySQL自动地为主键创建一个索引。通常，这个索引名为PRIMARY。然而，可以重新给这个索引起名。\n\n-- 【例】 删除Book表上的主键约束。ALTER TABLE Book;\tDROP PRIMARY KEY;\n唯一约束（替代键约束）——unique\n语法格式\n-- 1、创建数据表添加唯一约束的语法格式为：CREATE  TABLE  tb_name (列名  数据类型  [NULL|NOT NULL ] UNIQUE,……);-- 2、在已有数据表添加唯一约束的语法格式为：ALTER  TABLE  tb_name ADD UNIQUE(列名);-- 3、删除唯一约束的语法格式为：ALTER  TABLE  tb_name DROP INDEX 约束名;\n\n在关系模型中，唯一约束像主键一样，是表的一列或一组列，它们的值在任何时候都是唯一的。替代键是没有被选做主键的候选键。定义替代键的关键字是UNIQUE。\n\n-- 【例】 创建表book_copy1中将图书编号作为主键，书名列定义为唯一约束。CREATE TABLE book_copy1   (  图书编号 varchar(20) NOT NULL primary key,    书名     varchar(20) NOT NULL UNIQUE,    出版日期 date NULL  );-- 【例】假设已有Book表中主键未设定，给图书编号添加主键约束,给书名添加唯一性约束。ALTER TABLE Book\tADD PRIMARY KEY(图书编号), ADD UNIQUE u_idx (书名) ;\n\n\n这个例外键中，既包括主键约束, 也包括唯一性约束，说明MySQL可以同时创建多个约束。记住，使用PRIMARY KEY的列，必须是一个具有NOT NULL属性的列。\n如果想要查看表中创建的约束的情况，可以使用语句，\n例如：SHOW INDEX FROM book;\n\n\n-- 【例】 删除Book表上的唯一约束。ALTER TABLE Book DROP index u_idx ;\n\n在MySQL中替代键和主键的区别主要有以下几点。\n\n一个数据表只能创建一个主键。但一个表可以有若干个UNIQUE键，并且它们甚至可以重合，例如，在C1和C2列上定义了一个替代键，并且在C2和C3上定义了另一个替代键，这两个替代键在C2列上重合了，而MySQL允许这样。\n主键字段的值不允许为NULL，而UNIQUE字段的值可取NULL，但是必须使用NULL或NOT NULL声明。\n一般创建PRIMARY KEY约束时，系统会自动产生PRIMARY KEY索引。创建UNIQUE约束时，系统自动产生UNIQUE索引。\n\n\n外键约束——foreign key\n语法格式\n-- 1、创建表的同时创建外键CREATE TABLE 表名( 列名, ...        FOREIGN KEY (列名)  REFERENCES 表名 [(列名 [(长度)] [ASC | DESC],...)]       [ON DELETE  &#123;RESTRICT | CASCADE | SET NULL | NO ACTION&#125;]       [ON UPDATE  &#123;RESTRICT | CASCADE | SET NULL | NO ACTION&#125;] ）;-- 2、对已有表创建外键                ALTER TABLE 表名  ADD FOREIGN KEY (列名)  REFERENCES 表名 [(列名 [(长度)] [ASC | DESC],...)]       [ON DELETE  &#123;RESTRICT | CASCADE | SET NULL | NO ACTION&#125;]       [ON UPDATE  &#123;RESTRICT | CASCADE | SET NULL | NO ACTION&#125;]-- 3、删除外键约束                ALTER  TABLE  tb_name DROP FOREIGN KEY 约束名; \n\n参数解释：\n\nRESTRICT：当要删除或更新主键中被参照列上在外键中出现的值时， 拒绝对主键的删除或更新操作。如：要当要删除xs表中081102记录时，因为cj中还有081102记录，拒绝对xs表的删除操作。\nCASCADE：从主键删除或更新行时自动删除或更新外键表中匹配的行。如：从xs表更新081102学号为801102时自动更新cj表中学号为081102行为801102 。\nSET NULL：当从主键表删除或更新行时，设置外键表中与之对应的外键列为NULL。如：当从xs表删除081103行时，设置cj表中081103项为NULL。\nNO ACTION：NO ACTION意味着不采取动作，就是如果有一个相关的外键值在被参考的表里，删除或更新主键表中主要键值的企图不被允许，和RESTRICT一样。\nSET DEFAULT：作用和SET NULL一样，只不过SET DEFAULT是指定外键表中的外键列为默认值。\n如果没有指定动作，两个参照动作就会默认地使用RESTRICT。\n\n\n案例\n-- 【例】 创建带有参照动作CASCADE的book_ref1表。CREATE TABLE book_ref1   (       图书编号 　 varchar(20) NULL,     书名　　  　varchar(20) NOT NULL,     出版日期 　 date NULL,     PRIMARY KEY (书名),     FOREIGN KEY (图书编号)     REFERENCES Book (图书编号)     ON  UPDATE  CASCADE    )ENGINE=INNODB;-- 这个参照动作的作用是在主表更新时，外键表产生连锁更新动作，有些人称它为“级联”操作。举例说，如果book表中有一个图书编号为“TP.2525”的值修改为“TP.2525-1”，则book_ref1表中的“图书编号”列中的值“TP.2525”相应地改为“TP.2525-1”。-- 通过修改添加-- 【例】  在网络图书销售系统中，只有会员才能下订单。因此Sell表中的所有用户号也必须出现在Members表的用户号列中。定义参照完整性约束来实现这种约束。 ALTER TABLE sell  ADD FOREIGN KEY (用户号)  REFERENCES members (用户号)  ON DELETE CASCADE  ON UPDATE CASCADE;\n检查约束——check\n\n主键、替代键、外键都是常见的完整性约束的实例。但是，每个数据库都还有一些专用的完整性约束。\n例如，KC表中星期数要在1～7之间，XS表中出生日期必须大于1986年1月1日。这样的规则可以使用CHECK完整性约束来指定。\n\n\nCHECK完整性约束在创建表的时候定义。可以定义为列完整性约束，也可以定义为表完整性约束。\n\n语法格式\n-- 1、创建数据表添加检查约束的语法格式为：CREATE  TABLE  tb_name    ( 列名  数据类型  [NULL |NOT NULL]…… CHECK(expr),列级| CHECK(expr) );表级-- 2、在已有数据表添加检查约束的语法格式为：ALTER  TABLE  tb_name ADD CHECK(expr);-- 3、删除检查约束的语法格式为：ALTER  TABLE  tb_name DROP CHECK 约束名;\n\n说明：expr是一个表达式，指定需要检查的条件，在更新表数据的时候，MySQL会检查更新后的数据行是否满足CHECK的条件。\n\n案例\n-- 【例】 创建表student，只考虑学号和性别两列，性别只能包含男或女。CREATE  TABLE  student    (    学号 char(6) NOT NULL,    性别 char(2) NOT NULL CHECK(性别 IN (&#x27;男&#x27;, &#x27;女&#x27;))     );-- 这里CHECK完整性约束指定了性别允许哪个值，由于CHECK包含在列自身的定义中，所以CHECK完整性约束被定义为列完整性约束。-- 【例】创建student3表，有学号，最好成绩，平均成绩3列，要求最好成绩必须大于平均成绩。 CREATE  TABLE  student3    (    \t学号 char(6)    NOT NULL,    \t最好成绩 int NOT NULL,    \t平均成绩 int NOT NULL,    \tcheck(最好成绩&gt;平均成绩); -- 如果指定的完整性约束中要相互比较一个表或者两个或者多个列，那么该列的完整性约束必须定义为表完整性约束。-- CHECK约束可以同时定义多个，中间用逗号隔开。-- 【例】 修改book表，单价必须大于等于0，折扣在0.1-1之间。alter table book\tadd check(单价&gt;0),\tadd check(折扣&gt;=0.1 and 折扣&lt;=1);          \n默认约束——default\n\n默认约束的作用是给列设置一个默认值，在缺省录入的情况下，会自动填充默认值。\n\n语法格式\n-- 1、创建数据表添加默认约束的语法格式为：CREATE  TABLE  tb_name    ( 列名  数据类型  [NULL |NOT NULL]  default  ‘列默认值’,……);-- 2、在已有数据表添加和修改默认约束的语法格式为：（1）添加默认约束alter table 表名 modify 列名 数据类型 default ‘默认值’;（2）修改默认值alter table 表名 alter column 列名 set default ‘默认值’;-- 3、删除默认约束的语法格式为：alter table 表名 alter column 列名 drop default；\n案例\n-- 【例】book表中将折扣设置默认值为0.8折alter table bookmodify 折扣 decimal(2,1) default 0.8;-- 【例】book表中将折扣默认值修改为0.7折alter table bookalter column 折扣 set  default 0.7;-- 【例】删除book表折扣列的默认约束alter table bookalter column 折扣 drop default;\n查看表相关信息\n格式\nshow create table 表名;\n\n这个命令可以查看表的所有信息，包括一些字段类型，字段的约束，外键，主键，索引，字符编码等等\n\n删除完整性约束\n\n如果使用一条DROP TABLE语句删除一个表，所有的完整性约束都自动被删除了,被参照表的所有外键也都被删除了。\n使用ALTER TABLE语句，完整性可以独立地被删除，而不用去删除表本身。\n\n案例\n-- 【例】 删除表book的主键，删除sell表的外键，删除book表的单价check约束。ALTER TABLE book DROP PRIMARY KEY;ALTER TABLE sell DROP FOREIGN KEY sell_ibfk_1;ALTER TABLE book DROP check book_chk_1;\n归纳总结\n\n归纳总结：使用ALTER TABLE管理约束\n\n-- 1、显示表中的约束show keys from 表名;-- 2、主键约束（1）添加主键约束alter table 表名add primary key (列名)；（2）删除主键约束alter table  表名 drop primary key-- 3、唯一约束（1）添加唯一约束alter table  表名 add unique (列名)；（2）删除唯一约束alter table  表名 drop index 约束名；-- 4、外键约束（1）添加外键约束alter table 外键表 add foreign key (外键) references 主键表(主键);（2）删除外键约束alter table 外键表  drop foreign key  约束名;           -- 5、默认约束（1）添加默认约束alter table 表名 modify 列名 数据类型 default ‘默认值’;（2）修改默认值alter table 表名 alter column 列名 set default ‘默认值’;（3）删除默认约束alter table 表名 alter column 列名 drop default；-- 6、检查约束（1）添加检查约束alter table 表名 add check(约束表达式);（2）删除检查 约束alter table 表名 drop check 约束名\n练习\n-- 实训3-3 SQL语句修改数据表实训-- 使用SQL语句实现下列操作(P84)-- 1、创建schooldb数据库create database schooldb;-- 2、创建schooldb各表CREATE TABLE class  (  班级编号 char(6) NOT NULL PRIMARY KEY,  班级名称 varchar(20) NOT NULL,  院系 varchar(30)  NOT NULL,  年级 int NULL ,  人数 int NULL) ;CREATE TABLE course  (  课程号 char(6) NOT NULL PRIMARY KEY,  课程名 varchar(20) NOT NULL,  学分 int NOT NULL,  学时 int NOT NULL,  学期 char(2)  NULL ,  前置课 char(6) NULL  );CREATE TABLE score  (  学号 char(10)  NOT NULL,  课程号 char(6)  NOT NULL,  成绩 float(5,2) NULL,  PRIMARY KEY (学号, 课程号) );CREATE TABLE student  (  学号 char(10) NOT NULL PRIMARY KEY ,  姓名 varchar(20) NOT NULL,  性别 char(2)  NOT NULL,  出生日期 date NULL,  地区 varchar(20) NULL ,  民族 varchar(10)  NULL DEFAULT &#x27;汉&#x27;,  班级编号 char(6)  NULL );-- 3、查看schooldb中的表文件show tables;-- 4、查看course表结构desc course;-- 5、在score表中增加一列备注 char（50）alter table score add 备注 char(50);-- 6、将score表中的备注修改为varchar（50）alter table score modify 备注 varchar(50);-- 7、将备注名称修改为BZ alter table score change 备注 BZ varchar(50);-- 8、删除在score表BZ列alter table score drop BZ;-- 9、复制class表命名为classcopy，只复制表结构create table classcopy like class;-- 10、将classcopy表重命名为classcopy1rename table classcopy to classcopy1;-- 11、删除classcopy1表drop table classcopy1;\n-- 实训3-4 数据完整性实训-- /**/在各表中添加相应约束-- （1）class表班级编号设置为主键。alter table class add primary key(班级编号);/** （2）student表学号设置为主键；       姓名设置唯一约束       班级编号设置为外键；       民族设置默认约束，默认为‘汉’；       性别设置默认约束，默认为‘男’，设置检查约束只能输入‘男’或‘女’。**/alter table student add primary key(学号);alter table student add foreign key(班级编号) references class(班级编号);alter table student modify 民族 char(10) default &#x27;汉&#x27;;alter table student modify 性别 char(2) default &#x27;男&#x27;,add check(性别 in(&#x27;男&#x27;,&#x27;女&#x27;));-- （3）course表课程号设置为主键；--          前置课设置为外键。alter table course add primary key(课程号), ADD FOREIGN KEY (前置课) REFERENCES course (课程号);alter table course ADD FOREIGN KEY (前置课) REFERENCES course (课程号);-- （4）score表（学号，课程号）设置为主键；--          学号，课程号分别设置为外键；--         成绩设置检查约束有效成绩在0--100分。alter table score add primary key(学号,课程号);alter table score add foreign key(学号) references student(学号),add foreign key(课程号) references course(课程号);alter table score add check(成绩 between 0 and 100);\n数据操作语言—DML\n\nDML是指数据操作语言，英文全称是Data Manipulation Language，用来对数据库中表的数据记录进行更新（增删改）。\n关键字：\n\n\n插入insert\n删除delete\n更新update\n\n\n\n数据插入\n\n一旦创建了数据库和表，下一步就是向表里插入数据。通过INSERT或REPLACE语句可以向表中插入一行或多行数据。\n\n语法格式\nINSERT [IGNORE] [INTO] 表名[(列名,...)]             VALUES (&#123;表达式| DEFAULT&#125;,..),(...),...            | SET列名=&#123;表达式| DEFAULT&#125;, ...\n\n如果要给全部列插入数据，列名可以省略。如果只给表的部分列插入数据，需要指定这些列。对于没有指出的列，它们的值根据列默认值或有关属性来确定，MySQL处理的原则是：\n（1）具有IDENTITY属性的列，系统生成序号值来唯一标志列。\n（2）具有默认值的列，其值为默认值。\n（3）没有默认值的列，若允许为空值，则其值为空值；若不允许为空值，则出错。\n（4）类型为timestamp的列，系统自动赋值。\n\n\nVALUES子句：包含各列需要插入的数据清单，数据的顺序要与列的顺序相对应。若tb1_name后不给出列名，则在VALUES子句中要给出每一列（除IDENTITY和timestamp类型的列）的值，如果列值为空，则值必须置为NULL，否则会出错。VALUES子句中的值：\n（1）表达式：可以是一个常量、变量或一个表达式，也可以是空值NULL，其值的数据类型要与列的数据类型一致。例如，列的数据类型为int，插入的数据是‘aaa’就会出错。当数据为字符型时要用单引号括起。\n（2）DEFAULT：指定为该列的默认值。前提是该列原先已经指定了默认值。\n\n\n如果列清单和VALUES清单都为空，则INSERT会创建一行，每个列都设置成默认值。\n\n-- 插入语句最常用格式：INSERT INTO  表名(列名,...) VALUES (表达式, ...)\n案例\n-- 【例】 向Bookstore数据库中的表Book中插入如下的一行数据：USE Bookstore;INSERT INTO book VALUES (&#x27;TP.9501&#x27;, &#x27;计算机&#x27;, &#x27;Dreamwearer&#x27;, &#x27;鲍里嘉&#x27;,&#x27;高等教育出版社&#x27;,&#x27;2020-08-16&#x27;, 33.25,50,0.8, NULL );-- 【例】 若表Book中图书类别的默认值为“计算机”，数量默认值为NULL，插入上例那行数据。INSERT INTO book (图书编号,书名,作者,出版社,出版时间,单价,数量,折扣 )       VALUES ( &#x27;TP.9501&#x27;,  &#x27;Dreamwearer&#x27;,  &#x27;鲍里嘉&#x27;, &#x27;高等教育出版社&#x27;, &#x27;2020-08-16&#x27;, 33.25, 50, 0.8);-- 与上列命令效果相同： INSERT INTO book            SET 图书编号=&#x27;TP.9501&#x27;, 书名=&#x27;Dreamwearer&#x27;,            图书类别=DEFAULT, 作者= &#x27;鲍里嘉&#x27;,            出版社=&#x27;高等教育出版社&#x27;,            出版时间= &#x27;2020-08-16&#x27;, 单价=33.25,            数量=50, 折扣=0.8;\n\n如果例4.1正确执行，记录已经插入了，再执行例4.1的SQL代码，系统提示1062错误，这是因为两条记录的图书编号相同，而图书编号是Book表的主键，要求唯一。当插入第二条相同编号的记录时，系统提示错误，意为表中已有图书编号为6625的记录，第二条记录不能插入。\n可以使用REPLACE语句，用第二条记录替换第一条记录：\n\nREPLACE INTO book     VALUES ( &#x27;TP.9501&#x27;, &#x27;计算机&#x27;, &#x27;PHP网站制作’,           &#x27;林小红&#x27;, &#x27;高等教育出版社&#x27;, &#x27;2020-10-16’,           23.5, 30, 0.8, NULL);\n\n在一个单独的INSERT语句中使用多个VALUES（）子句一次插入多条记录。\n\nINSERT INTO members  VALUES    (&#x27;D0138&#x27;, &#x27;李小华&#x27;,&#x27;女&#x27;,&#x27;123456&#x27;,&#x27;13822551234&#x27; ,&#x27;2020-8-23&#x27;),   (&#x27;D0139&#x27;, &#x27;张明&#x27;,&#x27;男&#x27;, &#x27;123456&#x27;,&#x27;13822555432&#x27; ,&#x27;2020-9-23&#x27;);\n\n从上面的SQL代码可以看出，当一次插入多条记录时，每条记录的数据要用（）括起来，记录与记录之间用逗号分开。\n\n数据修改(更新)\n\n要修改表中的一行数据，可以使用UPDATE语句，UPDATE可以用来修改一个表，也可以修改多个表。\n\n格式\n-- 修改单个表，语法格式：UPDATE [IGNORE]  表名  SET 列名1=表达式1 [,列名2=表达式2 ...][WHERE 条件];-- 修改多个表，语法格式： UPDATE [IGNORE] 表名列表             SET 列名1=表达式1 [,列名2=表达式2 ...]             [WHERE 条件];\n\nSET子句：根据WHERE子句中指定的条件对符合条件的数据行进行修改。若语句中不设定WHERE子句，则更新所有行。\n可以同时修改所在数据行的多个列值，中间用逗号隔开。\n\n单表案例\n-- 【例】 将Bookstore数据库中Book表的所有书籍数量都增加10。将Members表中姓名为“张三”的员工的联系电话改为“13802551234”，密码改为“111111”。UPDATE Book    SET 数量 = 数量+10;UPDATE Members    SET联系电话 =&#x27;13802551234&#x27; , 密码 =&#x27;111111&#x27;  WHERE 姓名 = &#x27;张三&#x27;;\n多表案例\n-- 【例】订单号为6的客户因某种原因退回2本图书，请在sell表中修改订购册数，同时书退回后，book表中该图书的数量增加4。UPDATE  sell ,book                SET  sell.订购册数=订购册数-2 , book.数量=数量+2                WHERE sell.图书编号=book.图书编号 and sell.订单号=&#x27;6&#x27;;                \n数据删除\n使用DELETE语句删除数据\n格式\n-- 从单个表中删除，语法格式： DELETE [IGNORE] FROM 表名 [WHERE条件];\n\n如果省略WHERE子句则删除该表的所有行。\n\n案例\n-- 【例】 将Bookstore数据库的Members表中姓名为“张三”的员工的记录删除。USE Bookstore;DELETE FROM Members  WHERE 姓名=&#x27;张三&#x27;;-- 【例】 将Book表中数量小于5的所有行删除。USE Bookstore;DELETE FROM Book  WHERE 数量&lt;5; \n使用TRUNCATE TABLE语句删除表数据\n\n使用TRUNCATE TABLE语句将删除指定表中的所有数据，因此也称其为清除表数据语句。\n\n格式\n-- 语法格式：TRUNCATE TABLE 表名;\n\n说明：由于TRUNCATE TABLE语句将删除表中的所有数据，且无法恢复，因此使用时必须十分小心。\n\n\nTRUNCATE TABLE 在功能上与不带 WHERE子句的DELETE语句（如DELETE FROM XS）相同，二者均删除表中的全部行。但 TRUNCATE TABLE比DELETE速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。而TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。使用 TRUNCATE TABLE，AUTO_INCREMENT计数器被重新设置为该列的初始值。\n\n练习\n/** 数据操作实训：知识点提示：关系型数据库插入数据时以行为单位提交自动保存，有一个单元格不符合要求则整行记录都不能提交。插入记录要符合数据类型、长度、约束的要求，尤其是添加约束的表格要考虑数据的插入顺序，删除时也要考虑相应问题。**/-- 1.在schooldb各表中插入记录 -- （使用SQL语句在各表中至少插入一行记录，其他记录插入方法不限）-- Records of class-- ----------------------------INSERT INTO `class` VALUES (&#x27;AC1301&#x27;, &#x27;会计13-1班&#x27;, &#x27;会计学院&#x27;, 2013, 35);INSERT INTO `class` VALUES (&#x27;AC1302&#x27;, &#x27;会计13-2班&#x27;, &#x27;会计学院&#x27;, 2013, 35);INSERT INTO `class` VALUES (&#x27;CS1401&#x27;, &#x27;计算机14-1班&#x27;, &#x27;计算机学院&#x27;, 2014, 35);INSERT INTO `class` VALUES (&#x27;IS1301&#x27;, &#x27;信息系统13-1班&#x27;, &#x27;信息学院&#x27;, 2013, NULL);INSERT INTO `class` VALUES (&#x27;IS1401&#x27;, &#x27;信息系统14-1班&#x27;, &#x27;信息学院&#x27;, NULL, 30);-- ------------------------------ Records of course-- ----------------------------INSERT INTO `course` VALUES (&#x27;11003&#x27;, &#x27;管理学&#x27;, 2, 32, &#x27;2&#x27;, NULL);INSERT INTO `course` VALUES (&#x27;11005&#x27;, &#x27;会计学&#x27;, 3, 48, &#x27;2&#x27;, NULL);INSERT INTO `course` VALUES (&#x27;21001&#x27;, &#x27;计算机基础&#x27;, 3, 48, &#x27;1&#x27;, NULL);INSERT INTO `course` VALUES (&#x27;21002&#x27;, &#x27;OFFICE高级应用&#x27;, 3, 48, &#x27;2&#x27;, &#x27;21001&#x27;);INSERT INTO `course` VALUES (&#x27;21004&#x27;, &#x27;程序设计&#x27;, 4, 64, &#x27;2&#x27;, &#x27;21001&#x27;);INSERT INTO `course` VALUES (&#x27;21005&#x27;, &#x27;数据库&#x27;, 4, 64, &#x27;4&#x27;, &#x27;21004&#x27;);INSERT INTO `course` VALUES (&#x27;21006&#x27;, &#x27;操作系统&#x27;, 4, 64, &#x27;5&#x27;, &#x27;21001&#x27;);INSERT INTO `course` VALUES (&#x27;31001&#x27;, &#x27;管理信息系统&#x27;, 3, 48, &#x27;3&#x27;, &#x27;21004&#x27;);INSERT INTO `course` VALUES (&#x27;31002&#x27;, &#x27;信息系统_分析与设计&#x27;, 2, 32, &#x27;4&#x27;, &#x27;31001&#x27;);INSERT INTO `course` VALUES (&#x27;31005&#x27;, &#x27;项目管理&#x27;, 3, 48, &#x27;5&#x27;, &#x27;31001&#x27;);-- ------------------------------ Records of score-- ----------------------------INSERT INTO `score` VALUES (&#x27;2013110101&#x27;, &#x27;11003&#x27;, 90.00);INSERT INTO `score` VALUES (&#x27;2013110101&#x27;, &#x27;21001&#x27;, 86.00);INSERT INTO `score` VALUES (&#x27;2013110103&#x27;, &#x27;11003&#x27;, 89.00);INSERT INTO `score` VALUES (&#x27;2013110103&#x27;, &#x27;21001&#x27;, 86.00);INSERT INTO `score` VALUES (&#x27;2013110201&#x27;, &#x27;11003&#x27;, 78.00);INSERT INTO `score` VALUES (&#x27;2013110201&#x27;, &#x27;21001&#x27;, 92.00);INSERT INTO `score` VALUES (&#x27;2013110202&#x27;, &#x27;11003&#x27;, 82.00);INSERT INTO `score` VALUES (&#x27;2013110202&#x27;, &#x27;21001&#x27;, 85.00);INSERT INTO `score` VALUES (&#x27;2013310101&#x27;, &#x27;21004&#x27;, 83.00);INSERT INTO `score` VALUES (&#x27;2013310101&#x27;, &#x27;31002&#x27;, 68.00);INSERT INTO `score` VALUES (&#x27;2013310103&#x27;, &#x27;21004&#x27;, 80.00);INSERT INTO `score` VALUES (&#x27;2013310103&#x27;, &#x27;31002&#x27;, 76.00);INSERT INTO `score` VALUES (&#x27;2014210101&#x27;, &#x27;21002&#x27;, 93.00);INSERT INTO `score` VALUES (&#x27;2014210101&#x27;, &#x27;21004&#x27;, 89.00);INSERT INTO `score` VALUES (&#x27;2014210102&#x27;, &#x27;21002&#x27;, 95.00);INSERT INTO `score` VALUES (&#x27;2014210102&#x27;, &#x27;21004&#x27;, 88.00);INSERT INTO `score` VALUES (&#x27;2014310101&#x27;, &#x27;21001&#x27;, 79.00);INSERT INTO `score` VALUES (&#x27;2014310101&#x27;, &#x27;21004&#x27;, 80.00);INSERT INTO `score` VALUES (&#x27;2014310102&#x27;, &#x27;21001&#x27;, 91.00);INSERT INTO `score` VALUES (&#x27;2014310102&#x27;, &#x27;21004&#x27;, 87.00);-- ------------------------------ Records of student-- ----------------------------INSERT INTO `student` VALUES (&#x27;2013110101&#x27;, &#x27;张晓勇&#x27;, &#x27;男&#x27;, &#x27;1997-12-11&#x27;, &#x27;山西&#x27;, &#x27;汉&#x27;, &#x27;AC1301&#x27;);INSERT INTO `student` VALUES (&#x27;2013110103&#x27;, &#x27;王一敏&#x27;, &#x27;女&#x27;, &#x27;0000-00-00&#x27;, &#x27;河北&#x27;, &#x27;汉&#x27;, &#x27;AC1301&#x27;);INSERT INTO `student` VALUES (&#x27;2013110201&#x27;, &#x27;江山&#x27;, &#x27;女&#x27;, &#x27;1996-09-17&#x27;, &#x27;内蒙古&#x27;, &#x27;锡伯&#x27;, &#x27;AC1302&#x27;);INSERT INTO `student` VALUES (&#x27;2013110202&#x27;, &#x27;李明&#x27;, &#x27;男&#x27;, &#x27;1996-01-14&#x27;, &#x27;广西&#x27;, &#x27;壮&#x27;, &#x27;AC1302&#x27;);INSERT INTO `student` VALUES (&#x27;2013310101&#x27;, &#x27;黄菊&#x27;, &#x27;女&#x27;, &#x27;1995-09-30&#x27;, &#x27;北京&#x27;, &#x27;汉&#x27;, &#x27;IS1301&#x27;);INSERT INTO `student` VALUES (&#x27;2013310103&#x27;, &#x27;吴昊&#x27;, &#x27;男&#x27;, &#x27;1995-11-18&#x27;, &#x27;河北&#x27;, &#x27;汉&#x27;, &#x27;IS1301&#x27;);INSERT INTO `student` VALUES (&#x27;2014210101&#x27;, &#x27;刘涛&#x27;, &#x27;男&#x27;, &#x27;1997-04-03&#x27;, &#x27;湖南&#x27;, &#x27;侗&#x27;, &#x27;CS1401&#x27;);INSERT INTO `student` VALUES (&#x27;2014210102&#x27;, &#x27;郭志坚&#x27;, &#x27;男&#x27;, &#x27;1997-02-21&#x27;, &#x27;上海&#x27;, &#x27;汉&#x27;, &#x27;CS1401&#x27;);INSERT INTO `student` VALUES (&#x27;2014310101&#x27;, &#x27;王林&#x27;, &#x27;男&#x27;, &#x27;1996-10-09&#x27;, &#x27;河南&#x27;, &#x27;汉&#x27;, &#x27;IS1401&#x27;);INSERT INTO `student` VALUES (&#x27;2014310102&#x27;, &#x27;李怡然&#x27;, &#x27;女&#x27;, &#x27;1996-12-31&#x27;, &#x27;辽宁&#x27;, &#x27;汉&#x27;, &#x27;IS1401&#x27;);-- /*2.*/写出完成以下操作的SQL语句-- /*(1).*/向student表中添加数据“502001, 王晓林, 男, 2000-02-10, 广东, 汉,IS2020” insert into student values(&#x27;502001&#x27;, &#x27;王晓林&#x27;, &#x27;男&#x27;, &#x27;2000-02-10&#x27;, &#x27;广东&#x27; , &#x27;汉&#x27;,&#x27;IS2020&#x27;);-- /*(2).*/向student表插入一行数据“500102，林丽，女”insert into student(学号,姓名,性别) values(&#x27;500102&#x27;,&#x27;林丽&#x27;,&#x27;女&#x27;);-- /*(3)*/将student表中所有学生的地区字段内容在原来的数据后加上“省或市”3个字update student set 地区=CONCAT(地区,&#x27;（省或市）&#x27;);-- /*(4）*/将“王一敏”同学的出生日期改为“1998-02-10”，班级编号改为“AC1302”update student set 出生日期=&#x27;1998-02-10&#x27;,班级编号=&#x27;AC1302&#x27; where 姓名=&#x27;王一敏&#x27;;-- /*(5) */将student表中1997年以前出生的学生记录删除delete from student where year(出生日期)&lt;1997;\n数据查询语言—DQL\n单表查询\n\n使用数据库和表的主要目的是存储数据以便在需要时进行检索、统计或组织输出，通过SQL语句的查询可以从表或视图中迅速方便地检索数据。\n\nSELECT语句格式\nSELECT [ALL | DISTINCT]   输出列表达式, ...      [FROM  表名1 [ , 表名2] …]\t           \t /*FROM子句*/      [WHERE 条件]                                    /*WHERE子句*/      [GROUP BY &#123;列名 | 表达式 | 列编号&#125;                 [ASC | DESC], ...\t          \t /* GROUP BY  子句*/      [HAVING 条件]  \t\t          \t       /* HAVING 子句*/      [ORDER BY &#123;列名 | 表达式 | 列编号&#125;                 [ASC | DESC] , ...]                   /*ORDER BY子句*/       [LIMIT &#123;[偏移量,] 行数|行数OFFSET偏移量&#125;]\t   /*LIMIT子句*/\n\n顺序严格地排序。例如，一个HAVING子句必须位于GROUP BY子句之后，并位于ORDER BY子句之前。\n\n选择指定的列\n格式\n-- 使用SELECT语句选择一个表中的某些列的语法格式如下：SELECT 字段列表 FROM 表名;\n\n各列名之间要以逗号分隔。\n\n案例\n-- 【例】 查询Members表中各用户的姓名、联系电话和注册时间。USE Bookstore;SELECT 姓名,联系电话,注册时间 FROM Members;\n\n说明：当在SELECT语句指定列的位置上使用*号时，表示选择表的所有列，如要显示Members表中所有列，不必将所有字段名一一列出，使用 SELECT * FROM Members;\n\n定义列别名\n\n当希望查询结果中的某些列或所有列显示时且使用自己选择的列标题时，可以在列名之后使用AS子句来更改查询结果的列别名。\n\n格式\n语法格式为： SELECT 字段列表 [AS] 别名;\n案例\n-- 【例】 查询Book表中图书类别为计算机的图书书名、作者和出版社，结果中各列的标题分别指定为name、auther和publisher。SELECT 书名 AS name, 作者 AS auther, 出版社 AS publisher FROM Book WHERE 图书类别= &#x27;计算机&#x27;;-- 注意：当自定义的列标题中含有空格时，必须使用引号将标题括起来。SELECT 书名 AS &#x27; Name of  Book&#x27;, 作者 AS &#x27;Name  of  Auther&#x27;, 出版社 AS PublisherFROM book   WHERE 图书类别= &#x27;计算机&#x27;;\n替换查询结果中的数据\n\n在对表进行查询时，有时对所查询的某些列希望得到的是一种概念而不是具体的数据。例如查询XS表的总学分，所希望知道的是学习的总体情况，这时，就可以用等级来替换总学分的具体数字。\n要替换查询结果中的数据，则要使用查询中的CASE表达式。\n\n格式\n-- 语法格式CASE     WHEN 条件1 THEN 表达式1     WHEN 条件2 THEN 表达式2     ……     ELSE 表达式END\n案例\n-- 【例】 查询Book表中图书编号、书名和数量，对其库存数量按以下规则进行替换：若数量为空值，替换为“尚未进货”；若数量小于5，替换为“需进货”；若数量在5-50之间，替换为“库存正常”；若总学分大于50，替换为“库存积压”。列标题更改为“库存”。SELECT 图书编号, 书名,        CASE \tWHEN 数量 IS NULL THEN  &#x27;尚未进货&#x27;        \tWHEN 数量 &lt; 5 THEN  &#x27;需进货&#x27;        \tWHEN 数量 &gt;=5 and 数量&lt;=50 THEN  &#x27;库存正常&#x27;       \tELSE  &#x27;库存积压&#x27;         END  AS  库存FROM Book; \n计算列值\n\n使用SELECT对列进行查询时，在结果中可以输出对列值计算后的值，即SELECT子句可使用表达式作为结果。\n\n格式\n-- 语法格式SELECT 表达式1[ , 表达式2… ];\n案例\n-- 【例】 对Sell表已发货的记录计算订购金额（订购金额=订购册数*订购单价），并显示图书编号和订购金额。SELECT  图书编号, 订购册数*订购单价  AS 订购金额 FROM   Sell    WHERE 是否发货= &#x27;已发货&#x27;; \n消除结果集中的重复行\n\n对表只选择其某些列时，可能会出现重复行。例如，若对XSCJ数据库的XS表只选择专业名和总学分，则出现多行重复的情况。可以使用DISTINCT或DISTINCTROW关键字消除结果集中的重复行。\n\n格式\nSELECT DISTINCT 字段列表;\n\n其含义是对结果集中的重复行只选择一个，保证行的唯一性。\n\n案例\n-- 【例】 对Book表只选择图书类别和出版社，消除结果集中的重复行。SELECT DISTINCT 图书类别, 出版社  FROM Book; \n运算符\n操 作 符\n\n\n\n操 作 符\n描  述\n\n\n\n\n=\n等于\n\n\n&lt;&gt;\n不等于\n\n\n&gt;\n大于\n\n\n&lt;\n小于\n\n\n&gt;=\n大于等于\n\n\n&lt;=\n小于等于\n\n\nBETWEEN\n在某个范围内\n\n\nLIKE\n搜索某种模式\n\n\n\nWHERE子句\n\nWHERE子句必须紧跟FROM子句之后，在WHERE子句中，使用一个条件从FROM子句的中间结果中选取行。\n\n格式\nWHERE 列名 运算符 值;\n\n\nWHERE子句会根据条件对FROM子句的中间结果中的行一行一行地进行判断，当条件为TRUE的时候，一行就被包含到WHERE子句的中间结果中。\n在SQL中，返回逻辑值（TRUE或FALSE）的运算符或关键字都可称为谓词。\n判定运算包括比较运算、模式匹配、范围比较、空值比较。\n\n\n比较运算\n\n比较运算符用于比较（除TEXT和BLOB类型外) 两个表达式值，MySQL支持的比较运算符有：=（等于）、&lt;（小于）、&lt;=（小于等于）、&gt;（大于）、&gt;=（大于等于）、&lt;=&gt;（相等或都等于空）、&lt;&gt;（不等于）、!=（不等于）。\n当两个表达式值均不为空值（NULL）时，除了“&lt;=&gt;”运算符，其他比较运算返回逻辑值TRUE（真）或FALSE（假）；而当两个表达式值中有一个为空值或都为空值时，将返回UNKNOWN。\n\n-- 【例】 查询Bookstore数据库Book表中书名为“网页程序设计”的记录。SELECT  书名,单价   FROM  Book WHERE 书名=&#x27;网页程序设计&#x27;; -- 【例】 查询Book表中单价大于30的图书情况。SELECT *   FROM  Book WHERE 单价&gt;30; \n逻辑运算\n\n通过逻辑运算符（AND、OR、XOR和NOT）组成更为复杂的查询条件。逻辑运算操作的结果是“1”或“0”，分别表示“true”或“false”。\n\n类型\n\n\n\n符号1\n符号2\n说明\n示例\n说明\n\n\n\n\nnot\n!\n非运算\n!x\n如果x是&quot;true&quot;，那么示例的结果是&quot;false&quot;；  如果x是&quot;false&quot;，那么示例的结果是&quot;true&quot;。\n\n\nor\n||\n或运算\nx  || y\n如果x或y任一是&quot;true&quot;，那么示例的结果是&quot;true&quot;，否则示例的结果是&quot;false&quot;。\n\n\nand\n&amp;&amp;\n与运算\nx  &amp;&amp; y\n如果x和y都是&quot;True&quot;，那么示例结果是&quot;true&quot;，否则示例的结果是&quot;false&quot;。\n\n\nxor\n^\n异或运算\nx  ^y\n如果x和y不相同，那么示例结果是&quot;true&quot;，否则示例的结果是&quot;false&quot;。\n\n\n\n非： select not 0, not 1, not null;或： select (1 or 0), (0 or 0), (1 or null), (1 or 1), (null or null);与： select (1 and 1), (0 and 1), (3 and 1), (1 and null);异或： select (1 xor 1), (0 xor 0), (1 xor 0), (0 xor 1), (null xor 1);\n案例\n-- 【例】 查询Sell表中已收货且已结清的订单情况。SELECT 订单号,是否收货,是否结清 FROM SellWHERE  是否收货=&#x27;已收货&#x27;  AND 是否结清=&#x27;已结清&#x27;; -- 【例】查询Book表中清华大学出版社和北京大学出版社出版的价格大于25元的图书。SELECT 书名,出版社,单价 FROM  BookWHERE  (出版社=&#x27;清华大学出版社&#x27; OR 出版社=&#x27;北京大学出版社&#x27; )      AND 单价&gt;=25;或： SELECT书名,出版社,单价   FROM  BookWHERE  (出版社=&#x27;清华大学出版社&#x27;  AND 单价&gt;=25)       OR  (出版社=&#x27;北京大学出版社&#x27;  AND 单价&gt;=25); \n模式匹配（LIKE运算符）\n\nLIKE运算符用于指出一个字符串是否与指定的字符串相匹配，其运算对象可以是char、varchar、text、datetime等类型的数据，返回逻辑值TRUE或FALSE。\n使用LIKE进行模式匹配时，常使用特殊符号_和%，可进行模糊查询。“%”代表0个或多个字符，“_”代表单个字符。由于MySQL默认不区分大小写，要区分大小写时需要更换字符集的校对规则。\n\n案例\n-- 【例】 查询Members表中姓“张”的会员的身份证号、姓名及注册时间。SELECT 用户号,会员姓名, 注册时间    FROM Members  WHERE  会员姓名  LIKE  &#x27;张%&#x27;; -- 【例】查询book表中图书编号倒数第二位为6的图书的图书编号和书名。SELECT 图书编号, 书名   FROM  book  WHERE 图书编号 LIKE  &#x27;%6_&#x27;;-- 【例】查询Book表中书名中包含下画线的图书。SELECT 图书编号,书名   FROM   Book WHERE 书名 LIKE &#x27;%#_%&#x27;  ESCAPE  &#x27;#&#x27;; \n范围比较\n\n用于范围比较的关键字有两个：BETWEEN和IN。\n当要查询的条件是某个值的范围时，可以使用BETWEEN关键字。BETWEEN关键字指出查询范围。\n\n格式\n表达式 [ NOT ] BETWEEN  表达式1   AND  表达式2;\n\n\n当不使用NOT时，若表达式的值在表达式表达式1与表达式2之间（包括这两个值），则返回TRUE，否则返回FALSE；使用NOT时，返回值刚好相反。\n注意：表达式1的值不能大于表达式2的值。\n\n\n案例\n-- 【例】 查询Book表中2020年出版的图书的情况。SELECT  *    FROM Book    WHERE 出版时间  BETWEEN &#x27;2020-1-1&#x27;  AND &#x27;2020-12-31&#x27;; \n\n使用IN关键字可以指定一个值表，值表中列出所有可能的值，当与值表中的任一个匹配时，即返回TRUE，否则返回FALSE。\n\n-- 使用IN关键字指定值表的格式为：表达式 IN (表达式1 [,…n])\n-- 【例】查询Book表中“高等教育出版社”、“北京大学出版社”和“人民邮电出版社”出版的图书的情况。SELECT *  FROM Book   WHERE  出版社  IN ( &#x27;高等教育出版社&#x27;, &#x27;北京大学出版社&#x27;, &#x27;人民邮电出版社&#x27;); \n空值比较\n\n当需要判定一个表达式的值是否为空值时，使用 IS NULL关键字。格式为：\n\n表达式 IS [ NOT ] NULL;\n\n当不使用NOT时，若表达式expression的值为空值，返回TRUE，否则返回FALSE；当使用NOT时，结果刚好相反。\n\n-- 【例】 查询Sell表中尚未发货的订单记录。SELECT *   FROM   Sell   WHERE 是否发货 IS NULL;-- MySQL有一个特殊的等于运算符“&lt;=&gt;”，当两个表达式彼此相等或都等于空值时，它的值为TRUE，其中有一个空值或都是非空值但不相等，这个条件就是FALSE。-- 上面的语句也可以换成：SELECT * FROM  Sell   WHERE 是否收货&lt;=&gt;NULL; \n分类汇总与排序—聚合函数\n\nSELECT子句的表达式中还可以包含所谓的聚合函数。聚合函数常常用于对一组值进行计算，然后返回单个值。\n\n\n\n\n函 数 名\n说  明\n\n\n\n\nCOUNT\n求组中项数，返回int类型整数\n\n\nMAX\n求最大值\n\n\nMIN\n求最小值\n\n\nSUM\n返回表达式中所有值的和\n\n\nAVG\n求组中值的平均值\n\n\n\nCOUNT函数\n\n聚合函数中最经常使用的是COUNT()函数，用于统计组中满足条件的行数或总行数，返回SELECT语句检索到的行中非NULL值的数目，若找不到匹配的行，则返回0。\n\n格式\n-- 语法格式为COUNT ( &#123; [ ALL | DISTINCT ]表达式 &#125; | * )\n\n其中，表达式的数据类型是除BLOB或TEXT之外的任何类型。ALL表示对所有值进行运算，DISTINCT表示去除重复值，默认为ALL。使用COUNT(*)时将返回检索行的总数目，不论其是否包含 NULL值。\n\n案例\n-- 【例】求会员总人数。SELECT COUNT(*) AS  &#x27;会员数&#x27;  FROM Members; -- 【例】 统计已结清的订单数。SELECT COUNT(是否结清)  AS  &#x27;已结清的订单数&#x27;  FROM Sell;-- 注意：这里COUNT(是否结清)只统计是否结清列中不为NULL的行。-- 【例】 统计订购册数在5以上的订单数。 SELECT COUNT(订购册数)  AS  &#x27;订购册数在5以上的订单数&#x27; FROM Sell WHERE 订购册数&gt;5; \nMAX和MIN\n\nMAX和MIN分别用于求表达式中所有值项的最大值与最小值。\n\n格式\n-- 语法格式为：MAX / MIN ( [ ALL | DISTINCT ]表达式 )\n\n其中，表达式是常量、列、函数或表达式，其数据类型可以是数字、字符和时间日期 类型。\n\n案例\n-- 【例】 求订购了图书编号为TP.3035的订单的最高订购册数和最低订购册数。SELECT  MAX(订购册数), MIN(订购册数)             FROM Sell             WHERE  图书编号 = &#x27; TP.3035 &#x27;;\n\n注意：当给定列上只有空值或检索出的中间结果为空时，MAX和MIN函数的值也为空。\n\nSUM函数和AVG函数\n\nSUM和AVG分别用于求表达式中所有值项的总和与平均值。\n\n格式\n-- 语法格式为：SUM / AVG ( [ ALL | DISTINCT ]表达式 )\n\n其中，表达式是常量、列、函数或表达式，其数据类型只能是数值型。\n\n案例\n-- 【例】 求订购了图书编号为Ts.3035图书的订购总册数。SELECT SUM(订购册数)  AS  &#x27;订购总册数&#x27;  FROM Sell  WHERE  图书编号 = &#x27;Ts.3035 &#x27;; -- 【例】 求订购图书编号为Ts.3035图书的订单平均册数。SELECT AVG(订购册数)  AS  &#x27;每笔订单平均册数&#x27;  FROM Sell  WHERE  图书编号 = &#x27;Ts.3035 &#x27;; \n分类汇总与排序—GROUP BY子句\n\nGROUP BY子句主要用于根据字段对行分组。例如，根据学生所学的专业对XS表中的所有行分组，结果是每个专业的学生成为一组。\n\n格式\nGROUP BY &#123;列名 |表达式&#125; [ASC | DESC], ...                [WITH ROLLUP]\n\nGROUP BY子句后通常包含列名或表达式。MySQL对GROUP BY子句进行了扩展，可以在列的后面指定ASC（升序）或DESC（降序）。GROUP BY可以根据一个或多个列进行分组，也可以根据表达式进行分组，经常和聚合函数一起使用。\n\n案例\n-- 【例】 输出Book表中图书类别名。SELECT 图书类别   FROM Book  GROUP BY 图书类别; -- 【例】 按图书类别统计Book表中各类图书的库存数。SELECT 图书类别,COUNT(*)  AS  &#x27;库存数&#x27;            FROM Book            GROUP BY 图书类别; -- 【例】 按图书编号分类统计其订单数和订单的平均订购册数。SELECT 图书编号, AVG(订购册数) AS &#x27;订购册数&#x27; ,             COUNT(订单号) AS &#x27;订单数&#x27;             FROM Sell              GROUP BY 图书编号;              \n带ROLLUP的GROUP BY子句\n\n使用带ROLLUP操作符的GROUP BY子句，可指定在结果集内不仅包含由 GROUP BY 提供的正常行，还包含汇总行。\n\n-- 【例】按图书类别、出版社分类统计Book表中各类图书的库存数。SELECT 图书类别, 出版社, Sum(数量) AS &#x27;库存数&#x27;            FROM Book            GROUP BY 图书类别, 出版社               WITH  ROLLUP;            \nHAVING子句\n\n使用HAVING子句的目的与WHERE子句类似，不同的是WHERE子句是用来在FROM子句之后选择行，而HAVING子句用来在GROUP BY子句后选择行。\n\n格式\nGROUP BY &#123;列名 |表达式&#125;  HAVING 条件\n\n\n其中，条件的定义和WHERE子句中的条件类似，不过HAVING子句中的条件可以包含聚合函数，而WHERE子句中则不可以。\nSQL标准要求HAVING必须引用GROUP BY子句中的列或用于聚合函数中的列。不过，MySQL支持对此工作性质的扩展，并允许HAVING引用SELECT清单中的列和外部子查询中的列。\n\n\n案例\n-- 【例】 查找Sell表中每个会员平均订购册数在10本以上的会员的用户号和平均订购册数。SELECT 用户号, AVG(订购册数) AS &#x27;平均订购册数&#x27;            FROM Sell            GROUP BY 用户号            HAVING AVG(订购册数) &gt;10;             -- 【例】 查找Sell表中会员订单数在2笔以上且每笔订购册数都在5本以上的会员。SELECT 用户号, AVG(订购册数)             FROM Sell            WHERE 订购册数 &gt;5            GROUP BY 用户号            HAVING COUNT(*) &gt; 2;            \n分类汇总与排序—ORDER BY子句\n\n在一条SELECT语句中，如果不使用ORDER BY子句，结果中行的顺序是不可预料的。使用ORDER BY子句后可以保证结果中的行按一定顺序排列。\n\n格式\nORDER BY &#123;列名 | 表达式 | 列编号&#125; [ASC | DESC] , ...\n\n\n说明：ORDER BY子句后可以是一个列、一个表达式或一个正整数。正整数表示按结果表中该位置上的列排序。例如，使用ORDER BY 3表示对SELECT的列清单上的第3列进行排序。\n关键字ASC表示升序排列，DESC表示降序排列，系统默认值为ASC。\n\n\n案例\n-- 【例】 将Book表中记录按出版时间先后排序。SELECT * FROM Book ORDER BY 出版时间; -- 【例】 将Sell表中记录按订购册数从高到低排列。SELECT * FROM Sell ORDER BY 订购册数 DESC; \n分类汇总与排序—LIMIT子句\n\nLIMIT子句是SELECT语句的最后一个子句，主要用于限制被SELECT语句返回的行数。\n\n格式\nLIMIT &#123;[偏移量,] 行数 |行数  OFFSET 偏移量&#125;\n\n语法格式中的偏移量和行数都必须是非负的整数常数，偏移量指定返回的第一行的偏移量，行数是返回的行数。例如，“LIMIT 5”表示返回SELECT语句的结果集中最前面5行，而“LIMIT 3，5”则表示从第4行开始返回5行。值得注意的是初始行的偏移量为0而不是1。\n\n案例\n-- 【例】 查找Members表中注册时间最靠前的5位会员的信息。SELECT  *  FROM Members ORDER BY 注册时间 LIMIT 5; -- 【例】 查找Book表中从第4条记录开始的5条记录。SELECT  *  FROM Book ORDER BY 学号 LIMIT 3, 5; \n\n为了与PostgreSQL兼容，MySQL也支持LIMIT row_count OFFSET offset语法。所以将上面例子中的LIMIT子句换成“LIMIT 5 OFFSET 3”，结果一样。\n\n练习\n-- DQL——数据查询操作——单表查询-- /*（1）*/查询全体学生的姓名和年龄，要求分别用name和age表示列名。select  姓名 name,year(now())-year(出生日期) age from student;-- /*（2）*/查询成绩表，成绩列用优（&gt;=90）、良（75~90）、及格（60~75)、不及格（&lt;60)表示select *,\tcase \t\twhen 成绩&gt;=90 then &#x27;优&#x27;\t\twhen 成绩&gt;=75 and 成绩&lt;90 then &#x27;良&#x27;\t\twhen 成绩&gt;=60 and 成绩&lt;75 then &#x27;及格&#x27;\t\telse &#x27;不及格&#x27;\tend as 成绩档 from score;-- /*（3）*/查询学时大于等于48学时的课程名和学分select 课程名,学分,学时 from course where 学时&gt;=48;-- /*（4）*/查询前置课为空的课程名和学期select 课程名,学期 from course where 前置课 is null;-- /*（5）*/查询姓王的且名字为3个字的学生记录select * from student where 姓名 like &#x27;王__&#x27;;-- /*（6）*/ 查询生源地不是山西省的学生信息。select * from student where 地区 != &#x27;山西（省或市）&#x27;;-- /*（7）*/查询‘数据库’的课程号和前置课select 课程号,前置课 from course;-- /*（8）*/查询成绩为79分、89分或99分的记录。select * from score where 成绩 in (79,89,99);-- /*（9）*/查询每个班级人数增加80后的班级名称和新人数。select 班级名称,人数+80 新人数 from class;-- /*（10）*/查询不是1995年出生的所有女生信息。select * from student where year(出生日期) != 1995 and 性别=&#x27;女&#x27;;-- -- ---------------分隔线------------------ -- 数据查询实训二：分组与排序-- /*（1）*/按性别统计学生人数select 性别,count(*) 人数 from student group by 性别;-- /*（2）*/统计每个学生的选课门数，平均分和最高分select 学号,count(课程号),avg(成绩),max(成绩) from score group by 学号;SELECT     学号,    COUNT(课程号) AS 选课门数,    AVG(成绩) AS 平均分,    MAX(成绩) AS 最高分FROM    scoreGROUP BY    学号;-- /*（3）*/查询平均分在80分以上的每个学生的选课门数，总分和最低分select avg(成绩) 平均分,count(课程号) 选课门数,sum(成绩) 总分,min(成绩) 最低分 from score group by 学号 having 平均分&gt;80;-- /*（4）*/先按性别再按民族统计学生人数，并按人数从多到少排列select 性别,民族,count(*) as 人数 from student group by 性别,民族 order by 人数 desc;SELECT 性别,民族,COUNT(*) AS 人数 FROM student GROUP BY 性别,民族 ORDER BY 人数 DESC;-- /*（5）*/查询选修两门课程的学生学号。select 学号,count(*) 选课数 from score group by 学号 having 选课数=2;-- /*（6）*/ 统计每个学期的学分总数select *,sum(学分) 总学分 from course group by 学期;-- /*（7）*/统计至少有2个男生的班级编号select 班级编号 from student where 性别=&#x27;男&#x27; group by 班级编号 having count(*) &gt;= 2;-- /*（8）*/返回学生表的从第3行开始的4行记录。select * from student limit 2,4;-- /*（9）*/统计2014级各系学生人数。select left(班级编号,2) 系别,count(*) 人数 from student where left(学号,4) = 2014 group by left(班级编号,2);-- /*（10）*/按照性别、民族统计人数，并显示分类小计。select 性别,民族,count(*) 人数 from student group by 性别,民族 WITH ROLLUP;    \n多表查询\n\n前面介绍了使用SELECT子句选择列，本小节讨论SELECT查询的对象（即数据源）的构成形式。SELECT的查询对象由FROM子句指定。\n\n语法格式\nFROM  表名1 [ [AS] 别名1 ] [ , 表名2[ [AS] 别名2]] …      /*查询表*/            | JOIN子句\t\t\t                      /*连接表*/\n引用一个表\n\n可以用两种方式引用一个表，第一种方式是使用USE语句让一个数据库成为当前数据库，在这种情况下，如果在FROM子句中指定表名，则该表应该属于当前数据库。第二种方式是指定的时候在表名前带上表所属数据库的名字。例如，假设当前数据库是db1，现在要显示数据库db2里的表tb的内容，使用如下语句：\n\nSELECT  *  FROM  db2.tb;\n\n当然，在SELECT关键字后指定列名的时候也可以在列名前带上所属数据库和表的名字，但是一般来说，如果选择的字段在各表中是唯一的，就没有必要去特别指定。\n\n-- 【例】 从Members表中检索出所有客户的信息，并使用表别名Users。SELECT * FROM  Members AS Users; \n引用多个表\n\n如果要在不同表中查询数据，则必须在FROM子句中指定多个表。指定多个表时就要使用到连接。当不同列的数据组合到一个表中叫做表的连接。\n\n-- 【例】 查找Bookstore数据库中客户订购的图书书名，订购册数和订购时间。 SELECT  Book.书名, Sell.订购册数, Sell.订购时间        FROM  Book, Sell             WHERE Book.图书编号=Sell.图书编号; \n多表连接—全连接（交叉连接）\n概念\n\n当数据查询涉及到多张表格时，要将多张表格的数据连接起来组成一张表格，连接的方式有多种。\n\n\n交叉连接产生的新表是每个表的每行都与其他表中的每行交叉以产生所有可能的组合，列包含了所有表中出现的列，也就是笛卡儿积。全连接可能得到的行数为每个表中行数之积。\n如表A有3行，表B有2行，表A和B全连接后得到6行（3x2=6)的表。\n\n\n交叉连接的连接过程：\n例如，有一个学生1表和一个单科成绩表，结果集是两个表记录的交叉乘积，列是两个表列的集合。\n\n\n\n案例\n-- 【例】 交叉连接book表和sell表。   (1)SELECT     *     FROM  Book, Sell或   (2)SELECT     *     FROM  Book  join   Sell\n内连接（等值连接、自然连接）\n概念\n\nFROM子句各个表用逗号分隔，这样就指定了全连接。全连接潜在地产生数量非常大的行，因为可能得到的行数为每个表中行数之积。在这样的情形下，通常要使用WHERE子句设定条件来将结果集减少为易于管理的大小，这样的连接即为等值连接。\n若表A和B进行等值连接（T1=T3 ），则如下表所示，只有两行。\n\n\n\n\nT1\nT2\nT3\nT4\nT5\n\n\n\n\n1\nA\n1\n3\nM\n\n\n2\nB\n2\n0\nN\n\n\n\n\n使用JOIN关键字的连接，语法格式如下：\n\n表名1 INNER JOIN 表名2 ON 条件 | USING (列名)\n案例\n-- 【例】 查找Bookstore数据库中客户订购的图书书名，订购册数和订购时间。（1）SELECT  Book.书名, Sell.订购册数, Sell.订购时间         FROM  Book, Sell          WHERE Book.图书编号=Sell.图书编号; （2）SELECT  Book.书名, Sell.订购册数, Sell.订购时间        FROM  Book [inner] join Sell         ON Book.图书编号=Sell.图书编号; \nㅤㅤㅤㅤ\n\n\n内连接是系统默认的，可以省略INNER关键字。\n使用内连接后，FROM子句中ON条件主要用来连接表，其他并不属于连接表的条件可以使用WHERE子句来指定。\n\n\n-- 【例 】 用JOIN关键字表达下列查询：查找购买了“网页程序设计” 图书信息。SELECT 书名,订购册数        FROM Book JOIN Sell           ON Book.图书编号 = Sell. 图书编号             WHERE 书名 = &#x27;网页程序设计&#x27;; -- 【例】 用JOIN关键字表达下列查询：查找订购数量大于5本图书和会员姓名和订购册数。SELECT 会员姓名,订购册数    FROM  Sell  JOIN   Members            ON  Sell.用户号 = Members.用户号                  WHERE 订购册数&gt;5 ; \nㅤㅤㅤㅤ\n\n内连接还可以用于多个表的连接。\n\n-- 【例】 用JOIN关键字表达下列查询：查找购买了“网页程序设计”且订购数量大于5本的图书和会员姓名和订购册数。SELECT Book.图书编号, 会员姓名, 书名, 订购册数    FROM  Sell  JOIN  Book  ON  Book. 图书编号= Sell.图书编号          JOIN   Members   ON  Sell.身份证号 = Members.身份证号                  WHERE 书名 = &#x27;网页程序设计&#x27;  AND 订购册数&gt;5 ; \nㅤㅤㅤㅤ\n自连接\n\n作为特例，可以将一个表与它自身进行连接，称为自连接。若要在一个表中查找具有相同列值的行，则可以使用自连接。使用自连接时需为表指定两个别名，且对所有列的引用均要用别名限定。\n\n-- 【例】 查找BookStore数据库中订单不同、图书编号相同的图书的订单号、图书编号和订购册数。SELECT  a.订单号,a.图书编号,a.订购册数              FROM  Sell  AS  a  JOIN  Sell  AS  b               ON  a. 图书编号=b. 图书编号              where a. 订单号!=b. 订单号;\nUsing子句\n\n如果要连接的表中有列名相同，并且连接的条件就是列名相等，那么ON条件也可以换成USING子句。USING（列名）子句用于为一系列的列进行命名。这些列必须同时在两个表中存在。其中列名为两表中相同的列名。\n\n-- 【例】 查找Members表中所有订购过图书的用户的姓名。 SELECT  Distinct 姓名 FROM Members  JOIN  Sell USING (用户号);\n外连接\n\n指定了OUTER关键字的连接为外连接。外连接包括：\n\n\n左外连接（LEFT OUTER JOIN）：\n结果表中除了匹配行外，还包括左表有的但右表中不匹配的行，对于这样的行，从右表被选择的列设置为NULL。\n\n\n\n右外连接（RIGHT OUTER JOIN）：\n结果表中除了匹配行外，还包括右表有的但左表中不匹配的行，对于这样的行，从左表被选择的列设置为NULL。\n\n\n\n-- 【例】 查找所有图书的图书编号、数量及订购了图书的会员身份证号，若从未订购过，也要包括其情况。SELECT Book.图书编号,Book.数量FROM Book LEFT OUTER JOIN SellON Book.图书编号= Sell.图书编号;-- 【例】 查找订购了图书的会员的订单号、图书编号和订购册数以及所有会员的会员姓名。 SELECT 订单号,图书编号,订购册数, Members.会员姓名FROM Sell RIGHT JOIN Members ON Members.用户号= Sell.用户号; \n\n练习\n-- 多表查询实训-- /*（1）*/查询所有学生的学号、姓名、课程号和成绩select a.学号,姓名,课程号,成绩 from student a join score b using(学号);-- /*（2）*/查询会计学院全体同学的学号、姓名和班级名称select a.学号,姓名,班级名称 from student a join class b using(班级编号) where 院系=&#x27;会计学院&#x27;;-- /*（3）*/查询成绩在90分以上的学生的学号、姓名和成绩select 学号,姓名,成绩 from student a join score b using(学号) where 成绩&gt;90;-- /*（4）*/使用左外连接查询所有课程的课程号、课程名称和选修了该课程的学生的学号、姓名和成绩，没有学生选修的课程也要包括。select a.课程号,课程名,b.学号,姓名,成绩 from course a left join score b using(课程号) left join student c using(学号);-- /*（5）*/查询“计算机14-1班”所有学生的学号和姓名select 学号,姓名 from class a join student b using(班级编号) where 班级名称=&#x27;计算机14-1班&#x27;;-- /*（6）*/查询“张晓勇”同学所选课程的课程名称和成绩。select 课程名,成绩 from course a join score b using(课程号) join student c using(学号) where 姓名=&#x27;张晓勇&#x27;;-- /*（7）*/查询至少选修2门课程的女学生姓名。select 姓名 from score a join student b using(学号) where 性别=&#x27;女&#x27; group by 学号 having count(*)&gt;=2;-- /*（8）*/查询姓“王”的学生所学的课程名称。select 姓名,课程名 from student a join score b using(学号) join course c using(课程号) where 姓名 like &#x27;王%&#x27;;-- /*（9）*/查询选修“管理学”课程且成绩在80～90分之间的学生学号姓名及成绩。select 学号,姓名,成绩 from course a join score b using(课程号) join student c using(学号) where 课程名=&#x27;管理学&#x27; and 成绩 between 80 and 90;-- /*（10）*/查询选修“计算机基础”课程的学生的平均年龄。select 课程名,avg(year(now())-year(出生日期)) 平均年龄 from course a join score b using(课程号) join student c using(学号) where 课程名=&#x27;计算机基础&#x27;;-- -- ---------------分隔线------------------ -- 子查询实训-- 1、查询“计算机14-1班”所有学生的学号和姓名select 学号,姓名 from student where 班级编号 in (select 班级编号 from class where 班级名称=&#x27;计算机14-1班&#x27;);-- 2、查询与“张晓勇”同一个系的同学姓名。select 班级编号,姓名 from student where left(班级编号,2) in (select left(班级编号,2) from student where 姓名=&#x27;张晓勇&#x27;);-- 3、查询成绩比该课程平均成绩高的学生的学号及成绩。select 学号,成绩 from score where 成绩 &gt; (select avg(成绩) from score);-- 4、查询没有选修“11003”课程的学生学号及姓名。select 学号,姓名 from student where 学号 in (select 学号 from score where 课程号 != &#x27;11003&#x27;);-- 5、查询年龄高于平均年龄的学生的学号，姓名和出生日期select 学号,姓名,出生日期 from student where year(now())-year(出生日期) &gt; (select avg(year(now())-year(出生日期)) from student);-- 6、查询选修了“计算机基础”课程的学生学号、姓名及班级编号。select 学号,姓名,班级编号 from student where 学号 in (select 学号 from score where 课程号 in (select 课程号 from course where 课程名=&#x27;计算机基础&#x27;));select 学号,姓名,班级编号 from student a join score b using(学号) where 课程号 in (select 课程号 from course where 课程名=&#x27;计算机基础&#x27;);-- 7、查询出生日期小于所有男同学出生日期的女同学的姓名及班级编号。select 姓名,班级编号 from student where 性别=&#x27;女&#x27; and 出生日期 &gt; all(select 出生日期 from student where 性别=&#x27;男&#x27;);-- 8、 查询学号比“李明”同学大，而出生日期比他小的学生姓名。select 姓名 from student where 学号 &gt; (select 学号 from student where 姓名=&#x27;李明&#x27;) and year(出生日期) &gt; some(select year(出生日期) from student);\n综合小测实训\n小测\n-- 综合小测实训-- 1、  查询雇员表中雇佣年限超过十年的员工雇员ID、姓名、雇用年限和薪水select 雇员ID,姓名,year(now())-year(雇佣日期) 雇用年限,薪水 from 雇员表 where year(now())-year(雇佣日期) &gt; 10;-- 2、  查询雇员表中所有特长为“计算机”、“钢琴”、“书法”的雇员的姓名、特长。select 姓名,特长 from 雇员表 where 特长 in(&#x27;计算机&#x27;,&#x27;钢琴&#x27;,&#x27;书法&#x27;);-- 3、查询雇员表中所有姓名中第二个字为“丽”字的雇员的姓名和出生日期。select 姓名,出生年月 from 雇员表 where 姓名 like &#x27;_丽%&#x27;;-- 4、在订单表p_order中，查询产品ID、数量和订货日期，并按订货数量降序给产品排序。select 产品ID,数量,订货日期 from 订单表 order by 数量 desc;-- 5、在产品表中查询平均价格超过10元的产品的种类(多种方法)select 类别名 from 类别表 where 类别ID in (select 类别ID  from 产品表 group by 类别ID having avg(单价)&gt;10);select 类别名 from 类别表 a join 产品表 b using(类别ID) group by 类别ID having avg(单价)&gt;10;-- 6、查询所有订购了“鼠标”产品的公司的公司名称和联系方式。(多种方法)select 公司名称,联系方式 from 客户表 where 客户ID in (select 客户ID from 订单表 where 产品ID in (select 产品ID from 产品表 where 产品名=&#x27;鼠标&#x27;));select 公司名称,联系方式 from 客户表 a join 订单表 b using(客户ID) where 产品ID in (select 产品ID from 产品表 where 产品名=&#x27;鼠标&#x27;);select 公司名称,联系方式 from 客户表 a join 订单表 b using(客户ID) join 产品表 c using(产品ID) where 产品名=&#x27;鼠标&#x27;;SELECT 公司名称,联系方式 from `产品表` a,`订单表` b, `客户表` c where a.产品ID = b.产品ID and b.客户ID=c.客户ID and a.产品名 = &#x27;鼠标&#x27;;-- 7、查询已订购了产品的公司的公司名称、联系人姓名和所订产品的产品ID和数量(多种方法)select 公司名称,联系人姓名,产品ID,数量 from 客户表 a join 订单表 b using(客户ID);SELECT 公司名称,联系人姓名,产品ID,数量 from `客户表` a, `订单表` b where a.`客户ID`=b.`客户ID`;-- 8、使用左外连接查询产品表 表中凡是有类别信息的所有产品信息。SELECT * from 产品表 a left JOIN `类别表` b on a.`类别ID`=b.`类别ID` where a.类别ID is not null;\n数据视图\n练习\n-- 数据视图实训-- 1、在schooldb数据库上创建视图v_score，包括所有男同学的学号,姓名，民族以及其选修的课程名和成绩create view v_score asselect 学号,姓名,民族,课程名,成绩 from student a join score b using(学号) join course c using(课程号) where 性别=&#x27;男&#x27;;-- 2、在视图v_score中查找少数民族学生的学号，姓名以及选修的课程名和成绩select 学号,姓名,课程名,成绩 from v_score where 民族 != &#x27;汉&#x27;;-- 3、创建视图v_avg，包括学号（在视图中列名为name）和平均成绩（在视图中列名为score_avg）create view v_avg(name,score_avg) asselect 学号,avg(成绩) from score group by 学号;-- 4、使用视图v_avg，查找平均成绩在80分以上的学生的学号和平均成绩select name,score_avg from v_avg where score_avg &gt; 80;-- 5、创建视图v_student视图中包含所有汉族学生的学生信息，并向v_student视图中插入一条记录“2020410001,李牧，男，1998-10-21，广东，汉，null”create view v_student asselect * from student where 民族=&#x27;汉&#x27; with check option;insert into v_student values(&#x27;2020410001&#x27;,&#x27;李牧&#x27;,&#x27;男&#x27;,&#x27;1998-10-21&#x27;,&#x27;广东&#x27;,&#x27;汉&#x27;,null);-- 6、删除v_student中女同学的记录delete from v_student where 性别=&#x27;女&#x27;;-- 7、创建视图v_term4查询第4学期所有课程信息,并要求添加with check option 子句（注意添加该子句的作用）create view v_term4 asselect * from course where 学期 = 4 with check option;-- 8、向v_term4视图插入一门新课，具体课程信息自定insert into v_term4 values(&#x27;21007&#x27;,&#x27;Linux操作系统&#x27;,4,64,4,&#x27;21001&#x27;);-- 9、通过视图v_term4创建v_term4new视图，查询第4学期课程数和总课时数。create view v_term4new(课程数,总课时数) asselect count(课程号),sum(学时) from v_term4;-- 10、删除v_term4new视图drop view v_term4new;\nMySQL索引\n练习\n-- /*MySQL索引习题*/-- /*二、*/-- /*1. */对schooldb数据库course表“课程名”列上的前3个字符建立一个升序的索引“I_kc”create index I_kc        on course(课程名(3) ASC);\t\t\t -- /*2.*/在class表的院系列和年级列上建立一个复合索引I_CXalter table classadd index I_cx(院系,年级);-- /*3. */在student表的姓名列上创建一个唯一索引alter table student     add unique (姓名);\t\t -- /*4.*/为course表创建主键索引（假设course表中主键未设定）alter table classadd primary key (课程号);-- /*5.*/创建score表学号和课程号的联合主键（假设score表中主键未设定）,并在成绩列创建普通索引alter table score    add primary key(学号,课程号),    add index (成绩);-- /*6.*/删除course表的主键alter table course drop primary key ;\n数据控制语言—DCL\n练习\n/*数据库管理习题*//*二、*/-- 1.创建用户king1,king2，密码分别为ken1，ken2”CREATE USERking1@localhost IDENTIFIED BY &#x27;ken1&#x27;, king2@localhost IDENTIFIED BY &#x27;ken2&#x27;;-- 2.授予用户king1在schooldb数据库student表上的select权限  GRANT SELECT    ON  schooldb.student         TO king1@localhost;\t\t\t\t-- 3.授予用户king2在schooldb数据库class表上的select，update权限  GRANT SELECT,update    ON  schooldb.class         TO king2@localhost;\t\t\t\t-- 4.授予用户king1在schooldb数据库所有表上的select权限  GRANT SELECT    ON  schooldb.*         TO king1@localhost;\t\t\t\t-- 5.授予用户king2在schooldb数据库所有表上的所有权限  GRANT ALL    ON  schooldb.*         TO king2@localhost;\t\t\t\t-- 6.收回king2在schooldb数据库class表上的select权限 REVOKE  select    ON  schooldb.class        FROM  king2@localhost;        \n\n文章作者: [Blue Eagle]\n文章链接: [https://yjh021.github.io/2024/12/08/MySQL课程笔记/]\n版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 [Blue Eagle]\n\n","categories":["数据库","MySQL"],"tags":["SQL","数据库管理","学习笔记"]}]