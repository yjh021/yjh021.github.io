[{"title":"MySQL的安装和使用","url":"/2024/10/22/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/","content":"MySQL的安装和使用\n安装方式\nMySQL的安装有两种方式：\n\n解压配置方式\n\n\n\n步骤安装方式\n\n\n安装包下载-解压版\n下载地址：https://downloads.mysql.com/archives/community/\n\n解压软件包\n将MySQL软件包解压在没有中文和空格的目录下\n\n设置配置文件\n在解压目录创建my.ini文件并添加内容如下：\n\n\n[mysqld]# 设置3306端口port=3306# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8\n配置系统环境\n①在【我的电脑】右键\n②选择【高级系统设置】\n③选择【高级】-》【环境变量】\n\n④将MYSQL_HOME添加到PATH环境变量\n\n服务操作\n使用管理员权限进入DOS，在cmd中，进入解压目录下的bin目录依次执行以下命令：\n# ①对mysql进行初始化，请注意，这里会生产一个临时密码，后边要使用这个临时密码  mysqld --initialize --user=mysql --console# ②安装mysql服务    mysqld --install# ③启动mysql服务   net start mysql# ④登录mysql，这里需要使用之前生成的临时密码 mysql -uroot -p# ⑤修改root用户密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;# ⑤修改root用户权限create user &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;\n\n安装包下载-安装版\n下载地址：https://downloads.mysql.com/archives/installer/\n\n按照步骤安装\n第一步：\n\n第二步：此后按照流程安装即可，遇到Next（下一步）直接点击即可：\n\n第三步：点击Execute后需要等待几分钟。\n\n第四步：当所有的状态都变成Complete之后，点击 Next：\n\n第五步：\n\n第六步：\n\n第七步：\n\n第八步：此处输入密码务必记住，用于之后登陆数据库，建议将密码设置为：123456\n\n第九步：再按照  安装包下载-解压版  中的方法添加环境变量，步骤均为一样。\n\n以上两个安装方法，都可以在以管理员运行的 cmd 窗口中使用：mysql -uroot -p   来验证是否安装成功 。\n本篇文章的目的为了方便查阅和学习。\n\n文章作者: [Blue Eagle]\n文章链接: [https://yjh021.github.io/2024/10/04/MySQL的安装和使用/]\n版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 [Blue Eagle]\n\n","categories":["数据库","MySQL"],"tags":["SQL","数据库管理","博客"]},{"title":"我的第一篇文章","url":"/2024/10/04/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","content":"欢迎阅读我的第一篇文章\n这是我的第一篇使用Hexo撰写的博客文章。在这里，我将分享一些关于如何使用Hexo创建和管理博客的经验。\n使用Hexo的好处\n\n简单易用：Hexo的安装和使用都非常简单，适合初学者。\n强大的生态系统：Hexo有丰富的主题和插件，可以满足各种需求。\n快速生成：Hexo可以非常快速地生成静态页面，适合大型博客。\n\n如何开始\n\n安装Node.js：确保您的计算机上安装了Node.js。\n安装Hexo：使用npm安装Hexo。\n创建站点：使用Hexo命令创建一个新的站点。\n编写文章：使用Markdown编写文章，并配置好元数据。\n生成和部署：生成静态页面并部署到服务器。\n\n希望这篇文章对您有所帮助！\n\n文章作者: [Blue Eagle]\n文章链接: [https://yjh021.github.io/2024/10/04/我的第一篇文章/]\n版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 [Blue Eagle]\n\n","categories":["技术","博客"],"tags":["Hexo","Markdown","写作"]},{"title":"Hello World","url":"/2024/10/08/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n\n文章作者: [Blue Eagle]\n文章链接: [https://yjh021.github.io/2024/10/08/hello-world/]\n版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 [Blue Eagle]\n\n"},{"title":"MySQL上课笔记整理","url":"/2024/10/04/MySQL%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/","content":"MySQL上课笔记整理\n范式\nx`➡️y\n存在：部分函数依赖\n不存在：完全\n传递函数：\nx➡️y\ny➡️z\nx➡️z\n反过来不成立\n第一范式：不存在可分割项\n第二范式：需先满足第一范式，找到候选码，再去掉部分函数依赖\n第三范式：每一个非主属性都不传递函数依赖\n6\n解决之道：分解\n\n文章作者: [Blue Eagle]\n文章链接: [https://yjh021.github.io/2024/10/04/MySQL笔记整理/]\n版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 [Blue Eagle]\n\n","categories":["技术","博客"],"tags":["Hexo","Markdown","写作"]},{"title":"MySQL学习代码","url":"/2024/10/04/MySQL/","content":"MySQL学习代码\nSQL\n\n全称 Structured Query Language, 结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准。\n\nSQL通用语法\n\n在学习具体的SQL语句之前，先来了解一下SQL语言的通用语法。\n\nSQL语句可以单行或多行书写,以分号结尾。\nSQL语句可以使用空格/缩进来增强语句的可读性。\nMySQL数据库的SQL语句不区分大小写，关键字建议使用大写。\n注释:\n单行注释:-- 注释内容 或 # 注释内容\n多行注释:/** 注释内容*  */\n\n\nSQL分类\nSQL 语句，根据其功能，主要分为四类:DDL、DML、DQL、DCL 。\n\n\n\n分类\n全称\n说明\n\n\n\n\nDDL\nData Definition Language\n数据定义语言，用来定义数据库对象（数据库，表，字段)\n\n\nDML\nData Manipulation Language\n数据操作语言，用来对数据库表中的数据进行增删改\n\n\nDQL\nData Query Language\n数据查询语言，用来查询数据库中表的记录\n\n\nDCL\nData Control Language\n数据控制语言，用来创建数据库用户、控制数据库的访问权限\n\n\n\nMySQL数据库基本操作—DDL\n\nDDL：（Data Definition Language）,数据定义语言，该语言部分包括以下内容：\n\n\n对数据库的常用操作\n对表结构的常用操作\n修改表结构\n\n\n\n数据库操作\n-- 查看所有的数据库（结尾一定要加英文[;]，表示语句结束）show databases;-- 创建数据库（其中 [if not exists] 为可选参数,表示如果不存在再创建，存在不会创建；[charset=utf8] 为编码方式，可选）create database [if not exists] mydb1 [charset=utf8];-- 切换（选择要操作的）数据库(mydb1为数据库名)use mydb1;-- 删除数据库（[if exists] 表示如果有再删除，可选）drop database [if exists] mydb1;-- 修改数据库编码（不常用）alter database mydb1 character set utf8;\n表创建—格式\n\n创建表是构建一张空表，指定这个表的名字，这个表有几列，每一列叫什么名字，以及每一列存储的数据类型。\n\n-- 创建表格式create table [if not exists] 表名 (    字段名1 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;],    字段名2 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;],    字段名3 类型[(宽度)] [约束条件] [comment &#x27;字段说明&#x27;])[表的一些设置];-- 列如：-- 选择表（数据库）use mydb1;-- 创建表create table if not exists student (\tsid int,    name varchar(20),    gender varchar(10),    age int,    birth date,\taddress varchar(30),\t\t    score double);\n数据类型—数值类型(数字类型)\n\n1、数据类型\n\n数据类型是指在创建表的时候为表中字段指定数据类型，只有数据符合类型要求才能存储起来，使用数据类型的原则是够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间.\n\n\n\n数值类型\n\n\n\n\n\n数据类型—字符串类型\n\n数据类型—日期和时间类型\n\n还有 null 类型\n\n\n没有值，未知\n不要使用NULL值进行计算\n\n\n数据库的字段属性\n\nUnSigned\n\n\n没有值，未知\n不要使用NULL值进行计算\n\n\nZEROFILL\n\n\n0填充的\n不足位数的用0来填充 , 如int(3),5则为005\n\n\nAuto_InCrement\n\n\n通常理解为自增，自动在上一条记录的基础上默认+1\n通常用来设计唯一的主键，必须是整数类型\n可定义起始值和步长\n\n\n\n当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表\nSET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局)\n\n\n\n\n\n\nNULL 和 NOT NULL\n\n\n默认为NULL , 即没有插入该列的数值\n如果设置为NOT NULL , 则该列必须有值\n\n\nDEFAULT\n\n\n默认的\n用于设置默认值\n例如,性别字段,默认为&quot;男&quot; , 否则为 “女” ; 若无指定该列的值 , 则默认值为&quot;男&quot;的值\n\n\n\n-- 例子：执行 desc 表名; 后会出现以下结果CREATE TABLE IF NOT EXISTS `student`(\t`id` INT(4)\tNOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,\t`name` VARCHAR(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,\t`pwd` VARCHAR(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;,\t`sex` VARCHAR(2) NOT NULL DEFAULT &#x27;女&#x27; COMMENT &#x27;性别&#x27;,\t`birthday` DATETIME DEFAULT NULL COMMENT &#x27;出生日期&#x27;,\t`address` VARCHAR(100) DEFAULT NULL COMMENT &#x27;家庭住址&#x27;,\t`email` VARCHAR(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,\tPRIMARY KEY (`id`))ENGINE=INNODB DEFAULT CHARSET=utf8\n表的其他操作\n-- 查看当前数据库的所有表名称show tables;-- 查看指定某个表的创建语句show create table 表名;-- 查看表结构desc 表名;-- 删除表drop table 表名;\n修改表结构\n修改表添加列（字段）\n-- 为表添加新列（字段）alter table 表名 add 列名 类型(长度) [约束];-- 例子：为student表添加一个新的字段为：系别 dept 类型为 varchar(20)alter table student add dept varchar(20);\n修改列名和类型\n-- 语法格式alter table 表名 change 旧列名 新列名 类型(长度) [约束];-- 例子：为student表的 dept 字段更换为 department varchar(30)alter table student change dept department varchar(30);\n修改表删除列\n-- 语法格式alter table 表名 drop 列名;-- 例如：删除student表中department这列alter table student drop department;\n修改表名\n-- 语法格式rename table 表名 to 新表名;-- 例子：将表student改名成sturename table student to stu;\nMySQL数据库基本操作—DML\nDML基本介绍\n\nDML是指数据操作语言，英文全称是Data Manipulation Language，用来对数据库中表的数据记录进行更新（增删改）。\n关键字：\n\n\n插入insert\n删除delete\n更新update\n\n\n\n数据插入\n-- 语法格式-- 向表中插入某些（列和值要相互对应）insert into 表(列名1，列名2，列名3...) values(值1，值2，值3...)；-- 向表中插入所有列insert into 表 values(值1，值2，值3...);-- 例子：insert into student(sid,name,gender,age,birth,address,score) values(1001,&#x27;张三&#x27;,&#x27;男&#x27;,18,&#x27;1996-12-23&#x27;,&#x27;北京&#x27;,83.5);insert into student values(1001,&#x27;张三&#x27;,&#x27;男&#x27;,18,&#x27;1996-12-23&#x27;,&#x27;北京&#x27;,83.5);-- 一次添加多行数据insert into student values(1001,&#x27;张三&#x27;,&#x27;男&#x27;,18,&#x27;1996-12-23&#x27;,&#x27;北京&#x27;,83.5),\t\t\t\t\t\t(1002,&#x27;李四&#x27;,&#x27;男&#x27;,19,&#x27;1997-12-23&#x27;,&#x27;北京&#x27;,85.5);\n数据修改\n-- 语法格式update 表名 set 字段名 = 值,字段名 = 值...;update 表名 set 字段名 = 值,字段名 = 值... where 条件;-- 例子：-- 将所有学生的地址修改为重庆update student set address = &#x27;重庆&#x27;;-- 将sid为1004的学生的地址修改为北京update student set address = &#x27;北京&#x27; where sid = 1004;-- 将sid大于1004的学生的地址修改为上海update student set address = &#x27;北京&#x27; where sid &gt; 1004;-- 将sid为1005的学生的地址修改为北京，成绩修改为100update student set address = &#x27;北京&#x27;,score = 100 where sid = 1005;\n数据删除\n-- 语法格式（delete 不加条件会清空该表所有数据）delete from 表名 [where 条件];truncate table 表名 或者 truncate 表名;-- 例子-- 1.删除sid为1004的学生数据delete from student where sid = 1004;-- 2.删除表所有数据delete from student;-- 3.清空表数据-- 方式一truncate table student;-- 方式二truncate student;-- 注意：delete 和 truncate 原理不同，delete 只删除内容，而 truncate 类似于 drop table，可以理解为是将整个表删除，然后再创建该表；\nMySQL约束\n简介\n概念：\n\n约束英文：constraint\n约束实际上就是表中数据的限制条件。\n\n作用\n\n表在设计的时候加入约束的目的就是为了保证表中的记录完整性和有效性，比如用户表有些列的值(手机号）不能为空，有些列的值（身份证号)不能重复。\n\n分类\n\n\n主键约束(primary key) PK\n自增长约束(auto_increment)\n非空约束(not null)\n唯一性约束(unique)\n默认约束(default)\n零填充约束(zerofill)\n外键约束(foreign key) FK\n检查约束(8.0.16版本之后) (check)\n\n\n主键约束*\n概念：\n\n\nMySQL主键约束是一个列或者多个列的组合，其值能唯一地标识表中的每一行,方便在RDBMS中尽快的找到某一行。\n主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。\n每个表最多只允许一个主键。\n主键约束的关键字是：primary key\n当创建主键的约束时，系统默认会在所在的列和列组合上建立对应的唯一索引。\n\n\n操作\n\n\n添加单列主键\n\n创建单列主键有两种方式，一种是在定义字段的同时指定主键，一种是定义完字段之后指定主键。\n\n-- 方式1——语法：\t-- 在 create table 语句中，通过 primary key 关键字来指定主键。\t-- 在定义字段的同时指定主键，语法格式如下：create table 表名 (\t...    &lt;字段名&gt; &lt;数据类型&gt; primary key,    ...);-- 方式1——实现：create table emp1 (\teid int primay key,    name varchar(20),    deptId int,    salary double);-- 方式2——语法：\t-- 在定义字段的同时指定主键，语法格式如下：create table 表名 (\t...    [constraint &lt;约束名&gt;] primary key [字段名]);-- 方式2——实现：create table emp2 (\teid int,    name varchar(20),    deptId int,    salary double,    constraint pk1 primary key(eid));\n\n\n添加多列联合主键\n\n所谓的联合主键，就是这个主键是由一张表中多个字段组成的。\n注意：\n\t1. 当主键是由多个字段组成时，不能直接在字段名后面声明主键约束。\n\t2. 一张表只能有一个主键，联合主键也是一个主键。\n\t3. 联合主键各列不能为空。\n\n\n-- 语法：create table 表名 (\t...    primary key(字段1，字段2，...，字段n));-- 实现：create table emp3 (\tname varchar(20),    deptId int,    salary double,    primary key(name, deptId));\n\n\n\n通过修改表结构添加主键\n主键约束不仅可以在创建表的同时创建，也可以在修改表时添加。\n\n\n\n-- 语法：create table 表名 (\t...);alter table &lt;表名&gt; add primary key (字段列表)；-- 实现：-- 添加单列主键create table emp4 (\teid int,    name varchar(20),    deptId int,    salary double);alter table emp4 add primary key (eid);-- 添加多列主键(联合)create table emp5 (\teid int,    name varchar(20),    deptId int,    salary double);alter table emp5 add primary key (eid, deptId);\n\n\n删除主键约束\n\n一个表中不需要主键约束时，就需要从表中将其删除。删除主键约束的方法要比创建主键约束容易的多。\n\n-- 格式alter table &lt;数据库名&gt; drop primary key;-- 实现-- 删除单列主键alter table emp1 drop primary key;-- 删除联合主键alter table emp5 drop primary key;\n自增长约束(auto_increment)\n概念：\n\n在MySQL中，当主键定义为自增长后，这个主键的值就不再需要用户输入数据了，而由数据库系统根据定义自动赋值。每增加一条记录，主键会自动以相同的步长进行增长。\n通过给字段添加 auto_increment 属性来实现主键自增长。\n一般搭配主键使用，提高健壮性。\n\n-- 语法字段名 数据类型 auto_increment;-- 操作create table t_user1 (\tid int primary key auto_increment，    name varchar(20));\n\n\n\n特点：\n\n\n默认情况下，auto_increment的初始值是 1，每新增一条记录，字段值自动加 1。\n\n\n一个表中只能有一个字段使用 auto_increment约束，且该字段必须有唯一索引，以避免序号重复(即为主键或主键的一部分)。\n\n\nauto_increment约束的字段必须具备 NOT NULL 属性。\n\n\nauto_increment约束的字段只能是整数类型(TINYINT、SMALLINT、INT、BIGINT )等。\n\n\nauto_increment约束字段的最大值受该字段的数据类型约束，如果达到上限，auto_increment就会失效。\n\n\n\n\n\n指定自增字段初始值\n\n\n如果第一条记录设置了该字段的初始值，那么新增加的记录就从这个初始值开始自增。例如，如果表中插入的第一条记录的id值设置为5，那么再插入记录时，id值就会从5开始往上增加。\n\n\n-- 方式1，创建表时指定create table t_user2 (\tid int primary key auto_increment,    name varchar(20))auto_increment = 100;-- 方式2，创建表之后指定create table t_user2 (\tid int primary key auto_increment,    name varchar(20));alter table t_user2 auto_increment = 200;\n\n注意：delete 和 truncate 在删除后自增列的变化：\n\ndelete数据之后自动增长从断点开始\ntruncate数据之后自动增长从默认起始值开始\n\n\n-- 格式delete from &lt;表名&gt;;truncate &lt;表名&gt;;-- 实现delete from t_user1;truncate t_user2;\n非空约束(not null)\n概念\n\nMySQL非空约束（not null）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。\n\n-- 语法：-- 方式1：&lt;字段名&gt; &lt;数据类型&gt; not null;-- 方式2：alter table 表名 modify 字段 类型 not null;-- 添加非空约束——方式1-- 方式1，创建表时指定create table t_user6 (\tid int,    name varchar(20) not null,    address varchar(20) not null);-- 添加非空约束——方式2-- 方式2，创建表之后指定create table t_user7 (\tid int,    name varchar(20),    address varchar(20));alter table t_user7 modify name varchar(20) not null;alter table t_user7 modify address varchar(20) not null;-- 实例（插入数据）：insert into t_user6(id) values(1001);  -- 不可以（name，address不能为空）insert into t_user6(id,name,address) values(1001,NULL,NULL);  -- 不可以（同上）insert into t_user6(id,name,address) values(1001,&#x27;NULL&#x27;,&#x27;NULL&#x27;); -- 可以（字符串NULL）insert into t_user6(id,name,address) values(1001,&#x27;&#x27;,&#x27;&#x27;); -- 可以（空串）-- 删除非空约束(可以叫修改)-- alter table 表名 modify 字段 类型;alter table t_user7 modify name varchar(20);alter table t_user7 modify address varchar(20);\n唯一约束(unique)\n概念\n\n唯一约束(Unique)， 是指所有记录中字段的值不能重复出现。例如，为 id 字段加上唯一性约束后，每条记录的 id 值都是唯一的，不能出现重复的情况，但可以为NULL，并且可以有多个NULL。\n\n-- 语法：-- 方式1：&lt;字段名&gt; &lt;数据类型&gt; unique;-- 方式2：alter table 表名 add constraint 约束名 unique(列);-- 添加唯一约束——方式1：-- 创建表时指定create table t_user8 (\tid int,    name varchar(20),    phone_number varchar(20) unique  -- 指定唯一约束);-- 添加唯一约束——方式2：-- 方式2，创建表之后指定create table t_user9 (\tid int,    name varchar(20),    phone_number varchar(20)  -- 指定唯一约束);alter table t_user9 add constraint unique_pn unique(phone_number);-- 删除唯一约束alter table &lt;表名&gt; drop index &lt;唯一约束名&gt;;-- 实例：（如果通过方式1添加的唯一约束，则index后面加上所在列名就行）alter table t_user9 drop index unique_pn;\n默认约束(default)\n概念\n\nMySQL默认值约束用来指定某列的默认值。\n\n-- 语法：-- 方式1：&lt;字段名&gt; &lt;数据类型&gt; default &lt;默认值&gt;;-- 方式2：alter table 表名 modify 列名 类型 default 默认值;-- 添加默认约束——方式1：-- 创建表时指定create table t_user10 (\tid int,    name varchar(20),    address varchar(20) default &#x27;北京&#x27;  -- 指定默认约束);-- 插入数据（未给定地址时，它会默认是北京）insert into t_user10(id,name) values(1001,&#x27;张三&#x27;);insert into t_user10(id,name) values(1002,&#x27;李四&#x27;,&#x27;上海&#x27;);  -- 地址会成为上海insert into t_user10 values(1003,&#x27;王五&#x27;,NULL);   -- 地址会为 NULL-- 添加默认约束——方式2：-- 创建表之后指定create table t_user11 (\tid int,    name varchar(20),    address varchar(20));-- 格式：alter table 表名 modify 列名 类型 default 默认值;alter table t_user11 modify address varchar(20) default &#x27;北京&#x27;;-- 删除默认约束(删除默认约束就是把设置的默认值设置为null)-- alter table &lt;表名&gt; change column &lt;字段名&gt; &lt;类型&gt; default NULL;alter table t_user11 modify address varchar(20) default NULL;\n零填充约束(zerofill)\n概念\n\n插入数据时，当该字段的值的长度小于定义的长度时，会在该值的前面补上相应的0；\nzerofill 默认为 int(10)；\n当使用 zerofill 时，默认会自动加 unsigned（无符号）属性，使用 unsigned 属性后，数值范围时原值的2倍，例如，有符号为 -128~+127，无符号为 0~256.\n\n操作\n-- 语法&lt;字段名&gt; &lt;数据类型&gt; zerofill;create table t_user12 (\tid int zerofill,  -- 零填充约束    name varchar(20));insert into t_user12 values(123,&#x27;张三&#x27;); -- 固定10位，会在前面加7个0insert into t_user12 values(1,&#x27;李四&#x27;);  -- 固定10位，会在前面加9个0-- 删除-- 格式：alter table &lt;表名&gt; modify &lt;字段名&gt; &lt;数据类型&gt;;alter table t_user12 modify id int;\nMySQL数据库基本操作—DQL\n基本介绍\n概念\n\n\n数据库管理系统一个重要功能就是数据查询，数据查询不应只是简单返回数据库中存储的数据，还应该根据需要对数据进行筛选以及确定数据以什么样的格式显示。\nMySQL提供了功能强大、灵活的语句来实现这些操作。\nMySQL数据库使用select语句来查询数据。\n\n\n语法\n-- 格式select  [all|distinct]  &lt;目标列的表达式1&gt; [别名],  &lt;目标列的表达式2&gt; [别名]...from &lt;表名或视图名&gt; [别名], &lt;表名或视图名&gt; [别名]...[where&lt;条件表达式&gt;][group by &lt;列名&gt;[having &lt;条件表达式&gt;]][order by &lt;列名&gt; [asc|desc]][limit &lt;数字或者列表&gt;];-- 解释以上SELECT\t字段列表FROM\t表名列表WHERE\t条件列表GROUP BY\t分组字段列表HAVING\t分组后条件列表ORDER BY\t排序字段列表LIMIT\t分页参数-- 简化版语法select *| 列名 from 表 where 条件;\t\n我们在讲解这部分内容的时候，会将上面的完整语法进行拆分，分为以下几个部分：\n\n基本查询（不带任何条件）\n条件查询（WHERE）\n聚合函数（count、max、min、avg、sum）\n分组查询（group by）\n排序查询（order by）\n分页查询（limit）\n\n基本查询—数据准备\n以下是一个基础例子：\n\n\n创建数据库和表（商品表）：\n-- 创建数据库create database if not exists mydb2;use mydb2;-- 创建商品表：create table product (\tpid int primary key auto_increment,  -- 商品编号    pname varchar(20) not null,  -- 商品名称    price double,  -- 商品价格    category_id varchar(20)  -- 商品所属分类);\n\n\n添加数据：\n-- 电器类（c001）：insert into product values(null,&#x27;海尔洗衣机&#x27;,5000,&#x27;c001&#x27;);insert into product values(null,&#x27;美的冰箱&#x27;,3000,&#x27;c001&#x27;);insert into product values(null,&#x27;格力空调&#x27;,5000,&#x27;c001&#x27;);insert into product values(null,&#x27;九阳电饭煲&#x27;,5000,&#x27;c001&#x27;);-- 服装类（c002）：insert into product values(null,&#x27;啄木鸟衬衣&#x27;,300,&#x27;c002&#x27;);insert into product values(null,&#x27;恒源祥西裤&#x27;,800,&#x27;c002&#x27;);insert into product values(null,&#x27;花花公子夹克&#x27;,440,&#x27;c002&#x27;);insert into product values(null,&#x27;劲霸休闲裤&#x27;,266,&#x27;c002&#x27;);insert into product values(null,&#x27;海澜之家卫衣&#x27;,180,&#x27;c002&#x27;);insert into product values(null,&#x27;杰克琼斯运动裤&#x27;,430,&#x27;c002&#x27;);-- 护肤品类（c003）：insert into product values(null,&#x27;兰蔻面霜&#x27;,300,&#x27;c003&#x27;);insert into product values(null,&#x27;雅诗兰黛精华水&#x27;,200,&#x27;c003&#x27;);insert into product values(null,&#x27;香奈儿香水&#x27;,350,&#x27;c003&#x27;);insert into product values(null,&#x27;SK-II神仙水&#x27;,350,&#x27;c003&#x27;);insert into product values(null,&#x27;资生堂粉底液&#x27;,180,&#x27;c003&#x27;);-- 食品类（c004）：insert into product values(null,&#x27;老北京方便面&#x27;,56,&#x27;c004&#x27;);insert into product values(null,&#x27;良品铺子海带丝&#x27;,17,&#x27;c004&#x27;);insert into product values(null,&#x27;三只松鼠坚果&#x27;,88,&#x27;c004&#x27;);\n\n\n基本查询—简单查询\n-- 1.查询所有的商品select * from product;-- 2.查询商品名和商品价格select pname,price from product;-- 3.别名查询.使用的关键字是as（as可以省略的）-- 3.1表别名：select * from product as p;-- 别名在多表查询时可以起到简化作用，例如：select p.id,u.id from product as p, user1 as u;-- 3.2列别名（商品名）：select pname as pn from product;-- 4.去掉重复值（商品价格）select distinct price from product;-- 5.查询结果是表达式（运算查询）：将商品名和所有商品的价格+10元进行显示select pname,price+10 from product;\n基本查询—运算符\n简介\n数据库中的表结构确立后，表中的数据代表的意义就已经确定。通过MySQL运算符进行运算，就可以获取到表结构以外的另一种数据。\n例如，学生表中存在一个birth字段，这个字段表示学生的出 年份。 运 MySQL的算术运算符用当前的年份减学生出生的年份，那么得到的就是这个学生的实际年龄数据。\n\nMySQL支持4种运算符\n\n算术运算符\n比较运算符\n逻辑运算符\n位运算符\n\n\n算术运算符\n\n\n\n算术运算符\n说明\n\n\n\n\n+\n加法运算\n\n\n-\n减法运算\n\n\n*\n乘法运算\n\n\n/ 或 DIV\n除法运算，返回商\n\n\n% 或 MOD\n求余运算，返回余数\n\n\n\n比较运算符\n\n\n\n比较运算符\n说明\n\n\n\n\n=\n等于\n\n\n&lt; 和 &lt;=\n小于和小于等于\n\n\n&gt; 和 &gt;=\n大于和大于等于\n\n\n&lt;=&gt;\n完全的等于，两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0\n\n\n&lt;&gt; 或 !=\n不等于\n\n\nIS NULL 或 ISNULL\n判断一个值是否为NULL\n\n\nIS NOT NULL\n判断一个值是否不为NULL\n\n\nLEAST\n当有两个或多个参数时，返回最小值\n\n\nGREATEST\n当有两个或多个参数时，返回最大值\n\n\nBETWEEN AND\n判断一个值是否落在两个值之间\n\n\nIN\n判断一个值是IN列表中的任意一个值\n\n\nNOT IN\n判断一个值不是IN列表中的任意一个值\n\n\nLIKE\n通配符匹配(包括 % 和 _ ，%表示多个匹配，_ 表示单个匹配)\n\n\nREGEXP\n正则表达式匹配\n\n\n\n逻辑运算符\n\n\n\n逻辑运算符\n说明\n\n\n\n\nNOT 或者 !\n逻辑非\n\n\nAND 或者 &amp;&amp;\n逻辑与\n\n\nOR 或者 ||\n逻辑或\n\n\nXOR\n逻辑异或\n\n\n\n位运算符\n\n\n\n位运算符\n说明\n\n\n\n\n!\n按位或\n\n\n&amp;\n按位与\n\n\n^\n按位异或\n\n\n&lt;&lt;\n按位左移\n\n\n&gt;&gt;\n按位右移\n\n\n~\n按位取反，反转所有比特\n\n\n\n\n位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。\n\n运算符操作\n算术运算符\nuse mydb2;select 6 + 2;select 6 - 2;select 6 * 2;select 6 / 2;select 6 % 2;-- 将每件商品的价格加10select name,price + 10 as new_price from product;-- 将所有商品的价格上调10%select pname,price * 1.1 as new_price from product;\n比较运算符\n-- 更新pid为18的category_id为nullupdate product set category_id = null where pid = 18;-- 比较运算符——条件查询-- 查询商品名称为“海尔洗衣机”的商品所有信息：select * from product where pname = &#x27;海尔洗衣机&#x27;;-- 查询价格为800的商品select * from product where price = 800;-- 查询价格不是800的所有商品(三种方法)select * from product where price != 800;select * from product where price &lt;&gt; 800;select * from product where not(price = 800);-- 查询商品价格大于60元的所有商品信息select * from product where price &gt; 60;-- 查询商品价格在200到1000之间所有商品(三种方法)select * from product where price &gt;= 200 and price &lt;= 1000;select * from product where price &gt;= 200 &amp;&amp; price &lt;= 1000;select * from product where price between 200 and 1000;-- 查询商品价格是200或800的所有商品(三种方法)select * from product where price = 200 or price = 800;select * from product where price = 200 || price = 800;select * from product where price in(200, 800);-- 查询含有‘裤&#x27;字的所有商品select * from product where pname like &#x27;%裤%&#x27;;-- 查询以&#x27;海&#x27;开头的所有商品select * from product where pname like &#x27;海%&#x27;;-- 查询第二个字为&#x27;蔻&#x27;的所有商品select * from product where pname like &#x27;_蔻%&#x27;;-- 查询category_id为null的商品select * from product where category_id is null;-- 查询category_id不为null分类的商品select * from product where category_id is not null;-- 使用least求最小值(可以结合表来查询)select least(10, 20, 30) as small_number; -- 10select least(10, null , 30); -- null -- 使用greatest求最大值select greatest(10, 20, 30) as big_number;  -- 30select greatest(10, null, 30); -- null\n位运算符（了解）\n\n位运算符是在二进制数上进行计算的运算符。位运算会先将操作数变成二进制数，进行位运算。然后再将计算结果从二进制数变回十进制数。\n\nselect 3 &amp; 5;  -- 位与select 3 | 5;  -- 位或select 3 ^ 5;  -- 位异或select 3 &gt;&gt; 1;  -- 位右移select 3 &lt;&lt; 1;  -- 位左移select ~ 3;   -- 位取反\n基本查询—排序查询\n介绍\n\n如果我们需要对读取的数据进行排序，我们就可以使用MySQL的 order by 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。\n\n-- 语法格式：select \t字段名1, 字段名2, ……from 表名order by 字段名1 [asc|desc], 字段名2[asc|desc] ……;\n特点\n\n\nasc代表升序，desc代表降序，如果不写默认升序；\norder by用于子句中可以支持单个字段，多个字段，表达式，函数，别名；\norder by子句，放在查询语句的最后面。LIMIT子句除外。\n\n\n操作\n-- 1.使用价格排序（降序）select * from product order by price desc;-- 2.在价格排序（降序）的基础上，以分类排序（降序）select * from product order by price desc, category_id desc;-- 3.显示商品的价格（去重复），并排序（降序）select distinct price from product order by price desc;\n基本查询—聚合查询\n简介\n之前我们做的查询都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，它是对一列的值进行计算，然后返回一个单一的值；另外聚合函数会忽略空值。\n\n\n\n聚合函数\n作用\n\n\n\n\ncount()\n统计指定列不为NULL的记录行数；\n\n\nsum()\n计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；\n\n\nmax()\n计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；\n\n\nmin()\n计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；\n\n\navg()\n计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0\n\n\n\n操作\n-- 1 查询商品的总条数select count(*) from product;-- 2 查询价格大于200商品的总条数select count(*) from product where price &gt; 200;-- 3 查询分类为&#x27;c001&#x27;的所有商品的总和select sum(price) from product where category_id = &#x27;c001&#x27;;-- 4 查询商品的最大价格select max(price) from product;-- 5 查询商品的最小价格select min(price) from product;-- 6 查询分类为&#x27;c002&#x27;所有商品的平均价格select avg(price) from product where category_id = &#x27;c002&#x27;;-- 7 查询商品的最大和最小价格,并分别命名为 max_price 和 min_price :select max(price) max_price, min(price) min_price from product;\nNULL值的处理\n介绍\n\n\n\ncount函数对null值的处理：\n如果count函数的参数为星号（*），则统计所有记录的个数。而如果参数为某字段，不统计含null值的记录个数。\n\n\nsum和avg函数对null值的处理：\n这两个函数忽略null值的存在，就好像该条记录不存在一样。\n\n\nmax和min函数对null值的处理：\nmax和min两个函数同样忽略null值的存在。\n\n\n\n操作\n-- 创建表create table test_null (\tc1 varchar(20),    c2 int);-- 插入数据insert into test_null values(&#x27;aaa&#x27;,3);insert into test_null values(&#x27;bbb&#x27;,3);insert into test_null values(&#x27;ccc&#x27;,null);insert into test_null values(&#x27;ddd&#x27;,6);-- 测试-- SELECT COUNT(*)和 SELECT COUNT(1)  是一个意思select count(*), count(1), count(c2) from test_null;select sum(c2),max(c2),min(c2),avg(c2) from test_null;\n基本查询—分组查询—group by\n简介\n\n分组查询是指使用group by字句对查询信息进行分组。\n\n-- 格式：select 字段1，字段2…… from 表名 group by 分组字段 having 分组条件;-- 操作-- 1、统计各个分类商品的个数(注意：分组之后select的后边只能写分组字段和聚合函数)select category_id,count(*) from product group by category_id;-- group by可以指定多个分组字段；假如有三个分组字段，则筛选时必须三个分组字段一致才会分到一起（不分先后）。-- 例如：学生表，有： 学号  名字  年龄  省  市  县；（分组字段可不分先后）select from product group by 市, 省, 县;  -- 筛查结果为同一个省市县的分到一起并统计个数\n\n如果要进行分组的话，则select子句之后，只能出现分组的字段和统计函数，其他的字段不能出现；\n\n分组之后的条件筛选—having\n\n\n分组之后对统计结果进行筛选的话必须使用having，不能使用where；\nwhere子句用来筛选FROM子句中指定的操作所产生的行；\ngroup by 子句用来分组where子句的输出；\nhaving 子句用来从分组的结果中筛选行。\n\n\n-- 格式select 字段1, 字段2… from 表名 group by 分组字段 having 分组条件;-- 操作-- 2.统计各个分类商品的个数，且只显示个数大于4的信息select category_id, count(*) from product group by category_id having count(*) &gt; 4;\n基本查询—分页查询—limit\n简介\n分页查询在项目开发中常见，由于数据量很大，显示屏长度有限，因此对数据需要采取分页显示方式。例如数据共有30条，每页显示5条，第一页显示1-5条，第二页显示6-10条。\n格式\n-- 方式1——显示前n条select 字段1, 字段2… from 表名 limit n;-- 方式2——分页显示select 字段1, 字段2… from 表名 limit m,n;m：整数，表示从第几条索引开始，计算方式（当前页-1）*每页显示条数n：整数，表示查询多少条数据\n操作\n-- 查询product表的前5条记录select * from product limit 5;-- 从第4条开始显示，显示5条select * from product limit 3,5;\n基本查询—INSERT INTO SELECT语句\n简介\n\n将一张表的数据导入到另一张表中，可以使用INSERT INTO SELECT语句 。\n\n格式\ninsert into Table2(field1, field2) select value1, value2,… from Table1;或者：insert into Table2 select * from Table1;注意：要求目标表Table2必须存在\n操作\n-- 实例-- 创建表名为product2的表(要与表1中的字段名一致)create table product2 (\tpname varchar(20),    price double);-- 从表1将数据插入到表2（pname，price）insert into product2(pname,price) select pname,price from product;-- 检查是否成功插入select * from product2;\nSELECT INTO FROM语句\n简介\n\n将一张表的数据导入到另一张表中，有两种选择 SELECT INTO 和 INSERT INTO SELECT 。\n\n格式\nselect value1, value2 into Table2 from Table1;\n\n注意： 要求目标表Table2不存在，因为在插入时会自动创建表Table2，并将Table1中指定字段数据复制到Table2中。\n\n操作\nselect pname,price into product3 from product;\n练习1\n-- 选择数据库use mydb2;-- 创建学生表create table student (\tid int,    name varchar(20),    gender varchar(20),    chinese int,    english int,    math int);-- 插入数据insert into student(id,name,gender,chinese,english,math) values(1,&#x27;张明&#x27;,&#x27;男&#x27;,89,78,90);insert into student(id,name,gender,chinese,english,math) values(2,&#x27;李进&#x27;,&#x27;男&#x27;,67,53,95);insert into student(id,name,gender,chinese,english,math) values(3,&#x27;王五&#x27;,&#x27;女&#x27;,87,78,77);insert into student(id,name,gender,chinese,english,math) values(4,&#x27;李一&#x27;,&#x27;女&#x27;,88,98,92);insert into student(id,name,gender,chinese,english,math) values(5,&#x27;李财&#x27;,&#x27;男&#x27;,82,84,67);insert into student(id,name,gender,chinese,english,math) values(6,&#x27;张宝&#x27;,&#x27;男&#x27;,55,85,45);insert into student(id,name,gender,chinese,english,math) values(7,&#x27;黄蓉&#x27;,&#x27;女&#x27;,75,65,30);insert into student(id,name,gender,chinese,english,math) values(7,&#x27;黄蓉&#x27;,&#x27;女&#x27;,75,65,30);-- 查询数据-- 1.查询表中所有学生的信息。select * from student;-- 2.查询表中所有学生的姓名和对应的英语成绩。select name,english from student;-- 3.过滤表中重复数据。select distinct * from student;-- 4.统计每个学生的总分。select name,(chinese + english + math) as total_score from student;-- 5.在所有学生总分数上加10分特长分。select name,(chinese + english + math)+10 as total_score from student;-- 6.使用别名表示学生分数。select name,chinese &#x27;语文成绩&#x27;, english &#x27;英语成绩&#x27;, math &#x27;数学成绩&#x27; from student;-- 7.查询英语成绩大于90分的同学。select * from student where english &gt; 90;-- 8.查询总分大于200分的所有同学。select *,(chinese + english + math) as total_score from student where (chinese + english + math) &gt; 200;-- 9.查询英语分数在80-90之间的同学。(两种方法)select * from student where english between 80 and 90;select * from student where english &gt;= 80 and english &lt;= 90;-- 10.查询英语成绩不在80-90之间的同学。(四种方法)select * from student where not (english between 80 and 90);select * from student where english not between 80 and 90;select * from student where not (english &gt;= 80 and english &lt;= 90);select * from student where english &lt; 80 || english &gt; 90;-- 11.查询数学分数为89,90,91的同学。select * from student where math in(89,90,91);-- 12.查询数学分数不为89,90,91的同学。select * from student where math not in(89,90,91);select * from student where not math in(89,90,91);-- 13.查询所有姓李的学生英语成绩。select name,english from student where name like &#x27;李%&#x27;;-- 14.查询数学分80并且语文分80的同学。select * from student where math = 80 and chinese = 80;-- 15.查询英语80或者总分200的同学。select * from student where english = 80 or (chinese + english + math) = 200;-- 16.对数学成绩降序排序后输出。select * from student order by math desc;-- 17.对总分排序后输出，然后再按从高到低的顺序输出。select *,(chinese + english + math) as total_score from student order by (chinese + english + math) desc;-- 18.对姓李的学生总分成绩降序排序输出。select *,(chinese + english + math) as total_score from student where name like &#x27;李%&#x27; order by (chinese + english + math) desc;-- 19.查询男生和女生分别有多少人，并将人数降序排序输出。select gender,count(*) as total_count from student group by gender order by total_count desc;-- 20.查询男生和女生分别有多少人，并将人数降序排序输出,查询出人数大于等于4的性别人数信息。select gender,count(*) as total_count from student group by gender having total_count &gt;= 4 order by total_count desc;\n练习2\n-- 选择mydb2数据库use mydb2;-- 创建工资表create table emp (\tempno int,     -- 员工编号    ename varchar(50),  -- 员工名字    job varchar(50),  -- 工作名字    mgr int,     -- 上级领导编号    hiredate date,  -- 入职日期    sal int,       -- 薪资    comm int,      -- 奖金    deptno int     -- 部门编号);-- 插入数据insert into emp values(7369,&#x27;SMITH&#x27;,&#x27;CLERK&#x27;,7902,&#x27;1980-12-17&#x27;,800,NULL,20);insert into emp values(7499,&#x27;ALLEN&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-02-20&#x27;,1600,300,30);insert into emp values(7521,&#x27;WARD&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-02-22&#x27;,1250,500,30);insert into emp values(7566,&#x27;JONES&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-04-02&#x27;,2975,NULL,20);insert into emp values(7654,&#x27;MARTIN&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-09-28&#x27;,1250,1400,30);insert into emp values(7698,&#x27;BLAKE&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-05-01&#x27;,2850,NULL,30);insert into emp values(7782,&#x27;CLARK&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-06-09&#x27;,2450,NULL,10);insert into emp values(7788,&#x27;SCOTT&#x27;,&#x27;ANALYST&#x27;,7566,&#x27;1987-04-19&#x27;,3000,NULL,20);insert into emp values(7839,&#x27;KING&#x27;,&#x27;PRESIDENT&#x27;,NULL,&#x27;1981-11-17&#x27;,5000,NULL,10);insert into emp values(7844,&#x27;TURNER&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-09-08&#x27;,1500,0,30);insert into emp values(7876,&#x27;ADAMS&#x27;,&#x27;CLERK&#x27;,7788,&#x27;1987-05-23&#x27;,1100,NULL,20);insert into emp values(7900,&#x27;JAMES&#x27;,&#x27;CLERK&#x27;,7698,&#x27;1981-12-03&#x27;,950,NULL,30);insert into emp values(7902,&#x27;FORD&#x27;,&#x27;ANALYST&#x27;,7566,&#x27;1981-12-03&#x27;,3000,NULL,20);insert into emp values(7934,&#x27;MTLLER&#x27;,&#x27;CLERK&#x27;,7782,&#x27;1982-1-23&#x27;,1300,NULL,10);-- 查询数据-- 1、按员工编号升序排列不在10号部门工作的员工信息。（两种方法）select * from emp where deptno not in(10) order by empno;select * from emp where deptno != 10 order by empno;-- 2、查询姓名第二个字母不是“A”且薪水大于1000元的员工信息，按年薪降序排列。select *,(sal * 12 + ifnull(comm,0)) yearly from emp where ename not  like &#x27;_A%&#x27; and sal &gt; 1000 order by (sal * 12 + ifnull(comm,0)) desc;-- 3、求每个部门的平均薪水,并按平均薪水降序排序。select deptno,avg(sal) as avg_sal from emp group by deptno order by avg_sal desc;-- 4、求各个部门的最高薪水。select deptno,max(sal) as max_sal from emp group by deptno;-- 5、求每个部门每个岗位的最高薪水并按部门排序。select deptno,job,max(sal) from emp group by deptno,job order by deptno;-- 6、求平均薪水大于2000的部门编号。select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000;-- 7、将部门平均薪水大于1500的部门编号列出来，按部门平均薪水降序排列。select deptno,avg(sal) avg_sal from emp group by deptno having avg(sal) &gt; 1500 order by avg_sal desc;-- 8、选择公司中有奖金的员工姓名，工资。select ename,sal,comm from emp where comm is not null;-- 9、查询员工最高工资和最低工资的差距。select max(sal) - min(sal) &#x27;薪资差距&#x27; from emp;\n正则表达式\n介绍\n\n​\t正则表达式(regular expression)描述了一种字符串匹配的规则，正则表达式本身就是一个字符串，使用这个字符串来描述、用来定义匹配规则，匹配一系列符合某个句法规则的字符串。在开发中，正则表达式通常被用来检索、替换那些符合某个规则的文本。\n​\tMySQL通过REGEXP关键字支持正则表达式进行字符串匹配。\n\n格式\n\n\n\n模式\n描述\n\n\n\n\n^\n匹配输入字符串的开始位置。\n\n\n$\n匹配输入字符串的结束位置。\n\n\n.\n匹配除&quot;\\n&quot;之外的任何某个字符。\n\n\n[…]\n字符集合。匹配所包含的任意一个字符。例如，'[abc]‘可以匹配&quot;plain&quot;中的’a’。\n\n\n[^…]\n负值字符集合。匹配未包含的任意字符。例如，'[^abc]‘可以匹配&quot;plain&quot;中的’p’。\n\n\np1|p2|p3\n匹配p1或p2或p3。例如，‘z|food’能匹配&quot;z&quot;或&quot;food&quot;。’(z|f)ood’则匹配&quot;zood&quot;或&quot;food&quot;。\n\n\n*\n匹配前面的子表达式零次或多次。例如，&quot;zo*“能匹配&quot;z&quot;以及&quot;zoo”。 * 等价于{0,}。\n\n\n+\n匹配前面的子表达式一次或多次。例如，“zo+“能匹配&quot;zo&quot;以及&quot;zoo”，但不能匹配&quot;z”。+ 等价于 {1,}。\n\n\n{n}\nn 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。\n\n\n{n,m}\nm 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。\n\n\n\n正则表达式匹配查询\n操作上\n-- ^ 在字符串开始处进行匹配SELECT  &#x27;abc&#x27; REGEXP &#x27;^a&#x27;; -- $ 在字符串末尾开始匹配SELECT  &#x27;abc&#x27; REGEXP &#x27;a$&#x27;;SELECT  &#x27;abc&#x27; REGEXP &#x27;c$&#x27;;-- . 匹配任意字符SELECT  &#x27;abc&#x27; REGEXP &#x27;.b&#x27;;SELECT  &#x27;abc&#x27; REGEXP &#x27;.c&#x27;;SELECT  &#x27;abc&#x27; REGEXP &#x27;a.&#x27;; -- [...] 匹配括号内的任意单个字符SELECT  &#x27;abc&#x27; REGEXP &#x27;[xyz]&#x27;;SELECT  &#x27;abc&#x27; REGEXP &#x27;[xaz]&#x27;;-- [^...] 注意^符合只有在[]内才是取反的意思，在别的地方都是表示开始处匹配SELECT  &#x27;a&#x27; REGEXP &#x27;[^abc]&#x27;;SELECT  &#x27;x&#x27; REGEXP &#x27;[^abc]&#x27;;SELECT  &#x27;abc&#x27; REGEXP &#x27;[^a]&#x27;; -- a* 匹配0个或多个a,包括空字符串。 可以作为占位符使用.有没有指定字符都可以匹配到数据 SELECT &#x27;stab&#x27; REGEXP &#x27;.ta*b&#x27;;SELECT &#x27;stb&#x27; REGEXP &#x27;.ta*b&#x27;;SELECT &#x27;&#x27; REGEXP &#x27;a*&#x27;; -- a+  匹配1个或者多个a,但是不包括空字符SELECT &#x27;stab&#x27; REGEXP &#x27;.ta+b&#x27;;SELECT &#x27;stb&#x27; REGEXP &#x27;.ta+b&#x27;;\n操作下\n-- a?  匹配0个或者1个aSELECT &#x27;stb&#x27; REGEXP &#x27;.ta?b&#x27;;SELECT &#x27;stab&#x27; REGEXP &#x27;.ta?b&#x27;;SELECT &#x27;staab&#x27; REGEXP &#x27;.ta?b&#x27;; -- a1|a2  匹配a1或者a2，SELECT &#x27;a&#x27; REGEXP &#x27;a|b&#x27;;SELECT &#x27;b&#x27; REGEXP &#x27;a|b&#x27;;SELECT &#x27;b&#x27; REGEXP &#x27;^(a|b)&#x27;;SELECT &#x27;a&#x27; REGEXP &#x27;^(a|b)&#x27;;SELECT &#x27;c&#x27; REGEXP &#x27;^(a|b)&#x27;; -- a&#123;m&#125; 匹配m个aSELECT &#x27;auuuuc&#x27; REGEXP &#x27;au&#123;4&#125;c&#x27;;SELECT &#x27;auuuuc&#x27; REGEXP &#x27;au&#123;3&#125;c&#x27;; -- a&#123;m,n&#125; 匹配m到n个a,包含m和nSELECT &#x27;auuuuc&#x27; REGEXP &#x27;au&#123;3,5&#125;c&#x27;;SELECT &#x27;auuuuc&#x27; REGEXP &#x27;au&#123;4,5&#125;c&#x27;;SELECT &#x27;auuuuc&#x27; REGEXP &#x27;au&#123;5,10&#125;c&#x27;; -- (abc) abc作为一个序列匹配，不用括号括起来都是用单个字符去匹配，如果要把多个字符作为一个整体去匹配就需要用到括号，所以括号适合上面的所有情况。SELECT &#x27;xababy&#x27; REGEXP &#x27;x(abab)y&#x27;;SELECT &#x27;xababy&#x27; REGEXP &#x27;x(ab)*y&#x27;;SELECT &#x27;xababy&#x27; REGEXP &#x27;x(ab)&#123;1,2&#125;y&#x27;;\n多表操作\n介绍\n\n​\t实际开发中，一个项目通常需要很多张表才能完成。例如：一个商城项目就需要分类表(category)、商品表(products)、订单表(orders)等多张表。且这些表的数据之间存在一定的关系，接下来我们将在单表的基础上，一起学习多表方面的知识。\n\n多表关系\n\nMySQL多表之间的关系可以概括为：一对一、一对多/多对一关系，多对多\n\n一对一关系\n\n\n一个学生只有一张身份证；一张身份证只能对应一学生。\n在任一表中添加唯一外键，指向另一方主键，确保一对一关系。\n一般一对一关系很少见，遇到一对一关系的表最好是合并表。\n\n\n\n一对多/多对一关系\n\n\n部门和员工：\n分析：一个部门有多个员工，一个员工只能对应一个部门；\n实现原则：在多的一方建立外键，指向一的一方的主键。\n\n\n\n多对多关系\n\n\n学生和课程：\n分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择；\n原则：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，将多对多的关系，拆成一对多的关系，中间表至少要有两个外键，这两个外键分别指向原来的那两张表的主键。\n​\t注：多对多的关系需要一个中间表作为桥梁\n\n\n\n外键约束—概念\n介绍\n\nMySQL 外键约束（FOREIGN KEY）是表的一个特殊字段，经常与主键约束一起使用。对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）。\n外键用来建立主表与从表的关联关系，为两个表的数据建立连接，约束两个表中数据的一致性和完整性。比如，一个水果摊，只有苹果、桃子、李子、西瓜等 4 种水果，那么，你来到水果摊要买水果就只能选择苹果、桃子、李子和西瓜，其它的水果都是不能购买的。\n\n\n特点\n\n定义一个外键时，需要遵守下列规则：\n\n\n主表必须已经存在于数据库中，或者是当前正在创建的表。\n\n\n必须为主表定义主键。\n\n\n​    主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这 个外键的内容就是正确的。\n\n\n在主表的表名后面指定列名或列名的组合。这个列或列的组合必须是主表的主键或候选键。\n\n\n外键中列的数目必须和主表的主键中列的数目相同。\n\n\n外键中列的数据类型必须和主表主键中对应列的数据类型相同。\n\n\n\n外键约束—一对多关系\n操作-创建外键约束\n方式1-在创建表时设置外键约束\n在 create table 语句中，通过 foreign key 关键字来指定外键，具体的语法格式如下：\n[constraint &lt;外键名&gt;] foreign key 字段名 [，字段名2，…] references &lt;主表名&gt; 主键列1 [，主键列2，…];\n实现：\ncreate database mydb3; use mydb3;-- 创建部门表create table if not exists dept(  deptno varchar(20) primary key,  -- 部门号  name varchar(20) -- 部门名字);-- 创建员工表create table if not exists emp(  eid varchar(20) primary key , -- 员工编号  ename varchar(20), -- 员工名字  age int,  -- 员工年龄  dept_id varchar(20),  -- 员工所属部门  constraint emp_fk foreign key (dept_id) references dept (deptno)         -- 外键约束);\n\n方式2-在创建表时设置外键约束\n\n外键约束也可以在修改表时添加，但是添加外键约束的前提是：从表中外键列中的数据必须与主表中主键列中的数据一致或者是没有数据。\n\nalter table &lt;数据表名&gt; add constraint &lt;外键名&gt; foreign key(&lt;列名&gt;) references &lt;主表名&gt; (&lt;列名&gt;);\n实现：\n-- 创建部门表create table if not exists dept2(  deptno varchar(20) primary key ,  -- 部门号  name varchar(20) -- 部门名字);-- 创建员工表create table if not exists emp2(  eid varchar(20) primary key , -- 员工编号  ename varchar(20), -- 员工名字  age int,  -- 员工年龄  dept_id varchar(20)  -- 员工所属部门);-- 创建外键约束alter table emp2 add constraint dept_id_fk foreign key(dept_id) references dept2 (deptno);\n\n操作-在外键约束下的数据操作\n验证外键约束的作用\n1、数据插入\n-- 1、添加主表数据 -- 注意必须先给主表添加数据insert into dept values(&#x27;1001&#x27;,&#x27;研发部&#x27;);insert into dept values(&#x27;1002&#x27;,&#x27;销售部&#x27;);insert into dept values(&#x27;1003&#x27;,&#x27;财务部&#x27;);insert into dept values(&#x27;1004&#x27;,&#x27;人事部&#x27;);-- 2、添加从表数据  -- 注意给从表添加数据时，外键列的值不能随便写，必须依赖主表的主键列insert into emp values(&#x27;1&#x27;,&#x27;乔峰&#x27;,20, &#x27;1001&#x27;);insert into emp values(&#x27;2&#x27;,&#x27;段誉&#x27;,21, &#x27;1001&#x27;);insert into emp values(&#x27;3&#x27;,&#x27;虚竹&#x27;,23, &#x27;1001&#x27;);insert into emp values(&#x27;4&#x27;,&#x27;阿紫&#x27;,18, &#x27;1002&#x27;);insert into emp values(&#x27;5&#x27;,&#x27;扫地僧&#x27;,35, &#x27;1002&#x27;);insert into emp values(&#x27;6&#x27;,&#x27;李秋水&#x27;,33, &#x27;1003&#x27;);insert into emp values(&#x27;7&#x27;,&#x27;鸠摩智&#x27;,50, &#x27;1003&#x27;); insert into emp values(&#x27;8&#x27;,&#x27;天山童姥&#x27;,60, &#x27;1005&#x27;);  -- 不可以\n2、删除数据\n-- 3、删除数据 /*   注意：       1：主表的数据被从表依赖时，不能删除，否则可以删除       2: 从表的数据可以随便删除 */delete from dept where deptno = &#x27;1001&#x27;; -- 不可以删除delete from dept where deptno = &#x27;1004&#x27;; -- 可以删除delete from emp where eid = &#x27;7&#x27;; -- 可以删除\n操作-删除外键约束\n\n当一个表中不需要外键约束时，就需要从表中将其删除。外键一旦删除，就会解除主表和从表间的关联关系\n\n格式：\nalter table &lt;表名&gt; drop foreign key &lt;外键约束名&gt;;\n实现：\nalter table emp2 drop foreign key dept_id_fk;\n外键约束-多对多关系\n介绍\n\n在多对多关系中，A表的一行对应B的多行，B表的一行对应A表的多行，我们要新增加一个中间表，来建立多对多关系。\n\n\n操作\n-- 选择mydb3数据库use mydb3;-- 学生表和课程表(多对多)  -- 1 创建学生表student(左侧主表)   create table if not exists student(    sid int primary key auto_increment,    name varchar(20),    age int,    gender varchar(20)   );  -- 2 创建课程表course(右侧主表)  create table course(   cid  int primary key auto_increment,   cidname varchar(20)  );-- 3创建中间表student_course/score(从表)  create table score(    sid int,    cid int,    score double  );    -- 4建立外键约束(2次) alter table score add foreign key(sid) references student(sid);alter table score add foreign key(cid) references course(cid); -- 5给学生表添加数据insert into student values(1,&#x27;小龙女&#x27;,18,&#x27;女&#x27;),(2,&#x27;阿紫&#x27;,19,&#x27;女&#x27;),(3,&#x27;周芷若&#x27;,20,&#x27;男&#x27;);-- 6给课程表添加数据insert into course values(1,&#x27;语文&#x27;),(2,&#x27;数学&#x27;),(3,&#x27;英语&#x27;);-- 7给中间表添加数据insert into score values(1,1,78),(1,2,75),(2,1,88),(2,3,90),(3,2,80),(3,3,65);\n\n注意：修改和删除时，中间从表可以随便删除和修改，但是两边的主表受从表依赖的数据不能删除或者修改。\n\n多表联合查询\n介绍\n\n多表查询就是同时查询两个或两个以上的表，因为有的时候用户在查看数据的时候,需要显示的数据来自多张表。\n\n多表查询有以下分类：\n交叉连接查询 [产生笛卡尔积，了解]      语法：select * from A,B;  内连接查询(使用的关键字 inner join  -- inner可以省略)    隐式内连接（SQL92标准）：select * from A,B where 条件;    显示内连接（SQL99标准）：select * from A inner join B on 条件;外连接查询(使用的关键字 outer join -- outer可以省略)        左外连接：left outer join            select * from A left outer join B on 条件;        右外连接：right outer join            select * from A right outer join B on 条件;        满外连接: full outer join             select * from A full outer join B on 条件;子查询       select的嵌套表自关联：       将一张表当成多张表来用\n\n准备查询数据\n\n接下来准备多表查询需要数据，注意，外键约束对多表查询并无影响。\n\nuse mydb3;-- 创建部门表create table if not exists dept3(  deptno varchar(20) primary key ,  -- 部门号  name varchar(20) -- 部门名字); -- 创建员工表create table if not exists emp3(  eid varchar(20) primary key , -- 员工编号  ename varchar(20), -- 员工名字  age int,  -- 员工年龄  dept_id varchar(20)  -- 员工所属部门);-- 给dept3表添加数据insert into dept3 values(&#x27;1001&#x27;,&#x27;研发部&#x27;);insert into dept3 values(&#x27;1002&#x27;,&#x27;销售部&#x27;);insert into dept3 values(&#x27;1003&#x27;,&#x27;财务部&#x27;);insert into dept3 values(&#x27;1004&#x27;,&#x27;人事部&#x27;);-- 给emp表添加数据insert into emp3 values(&#x27;1&#x27;,&#x27;乔峰&#x27;,20, &#x27;1001&#x27;);insert into emp3 values(&#x27;2&#x27;,&#x27;段誉&#x27;,21, &#x27;1001&#x27;);insert into emp3 values(&#x27;3&#x27;,&#x27;虚竹&#x27;,23, &#x27;1001&#x27;);insert into emp3 values(&#x27;4&#x27;,&#x27;阿紫&#x27;,18, &#x27;1001&#x27;);insert into emp3 values(&#x27;5&#x27;,&#x27;扫地僧&#x27;,85, &#x27;1002&#x27;);insert into emp3 values(&#x27;6&#x27;,&#x27;李秋水&#x27;,33, &#x27;1002&#x27;);insert into emp3 values(&#x27;7&#x27;,&#x27;鸠摩智&#x27;,50, &#x27;1002&#x27;); insert into emp3 values(&#x27;8&#x27;,&#x27;天山童姥&#x27;,60, &#x27;1003&#x27;);insert into emp3 values(&#x27;9&#x27;,&#x27;慕容博&#x27;,58, &#x27;1003&#x27;);insert into emp3 values(&#x27;10&#x27;,&#x27;丁春秋&#x27;,71, &#x27;1005&#x27;);\n多表联合查询—交叉连接查询\n\n\n交叉连接查询返回被连接的两个表所有数据行的笛卡尔积\n笛卡尔积可以理解为一张表的每一行去和另外一张表的任意一行进行匹配\n假如A表有m行数据，B表有n行数据，则返回m*n行数据\n笛卡尔积会产生很多冗余的数据，后期的其他查询可以在该集合的基础上进行条件筛选\n\n\n格式：\nselect * from 表1,表2,表3….;\n实现：\n-- 交叉连接查询select * from dept3,emp3;\n结果：\n\n多表联合查询—内连接查询\n内连接查询求多张表的交集\n格式\n隐式内连接（SQL92标准）：select * from A,B where 条件; 显示内连接（SQL99标准）：select * from A inner join B on 条件;\n操作\n-- 查询每个部门的所属员工select * from dept3,emp3 where dept3.deptno = emp3.dept_id;select * from dept3 inner join emp3 on dept3.deptno = emp3.dept_id;-- 查询研发部和销售部的所属员工select * from dept3,emp3 where dept3.deptno = emp3.dept_id and name in( &#x27;研发部&#x27;,&#x27;销售部&#x27;);select * from dept3 join emp3 on dept3.deptno = emp3.dept_id and name in( &#x27;研发部&#x27;,&#x27;销售部&#x27;); -- 查询每个部门的员工数,并升序排序select deptno,count(1) as total_cnt from dept3,emp3 where dept3.deptno = emp3.dept_id group by deptno order by total_cnt; select deptno,count(1) as total_cnt from dept3 join emp3 on dept3.deptno = emp3.dept_id group by deptno order by total_cnt;-- 查询人数大于等于3的部门，并按照人数降序排序select deptno,count(1) as total_cnt from dept3,emp3 where dept3.deptno = emp3.dept_id group by deptno having total_cnt &gt;= 3 order by total_cnt desc; select deptno,count(1) as total_cnt from dept3 join emp3 on dept3.deptno = emp3.dept_id group by deptno having total_cnt &gt;= 3 order by total_cnt desc;\n外连接查询\n\n\n外连接分为左外连接（left outer join）、右外连接(right outer join)，满外连接(full outer join)。\n注意：oracle里面有full join,可是在mysql对full join支持的不好。我们可以使用union来达到目的。\n\n\n格式\n左外连接：left outer join            select * from A left outer join B on 条件;  右外连接：right outer join            select * from A right outer join B on 条件;  满外连接: full outer join             select * from A full outer join B on 条件;\n操作\n-- 外连接查询-- 查询哪些部门有员工，哪些部门没有员工use mydb3;select * from dept3 left outer join emp3 on dept3.deptno = emp3.dept_id; -- 查询哪些员工有对应的部门，哪些没有select * from dept3 right outer join emp3 on dept3.deptno = emp3.dept_id;  -- 使用union关键字实现左外连接和右外连接的并集（union后使用all代表不去重，不用代表去重）select * from dept3 left outer join emp3 on dept3.deptno = emp3.dept_idunion select * from dept3 right outer join emp3 on dept3.deptno = emp3.dept_id;\n子查询\n介绍\n\n子查询就是指的在一个完整的查询语句之中，嵌套若干个不同功能的小查询，从而一起完成复杂查询的一种编写形式，通俗一点就是包含select嵌套的查询。\n\n特点\n\n子查询可以返回的数据类型一共分为四种：\n\n单行单列：返回的是一个具体列的内容，可以理解为一个单值数据；\n单行多列：返回一行数据中多个列的内容；\n多行单列：返回多行记录之中同一列的内容，相当于给出了一个操作范围；\n多行多列：查询返回的结果是一张临时表\n\n\n操作\n-- 查询年龄最大的员工信息，显示信息包含员工号、员工名字，员工年龄-- 1：查询最大年龄：select max(age) from emp3;-- 2：让每一个员工的年龄和最大年龄进行比较，相等则满足条件(嵌套查询也称子查询)select eid,ename,age from emp3 where age = (select max(age) from emp3);  -- 单行单列，可以作为一个值来用 -- 查询年研发部和销售部的员工信息，包含员工号、员工名字-- 方式1-关联查询select * from dept3 a join emp3 b on a.deptno = b.dept_id and (name = &#x27;研发部&#x27; or name = &#x27;销售部&#x27;);-- 方式2-子查询-- 2.1 先查询研发部和销售部的部门号：deptno 1001 和 1002select deptno from dept3 where name = &#x27;研发部&#x27; or name = &#x27;销售部&#x27;;-- 2.2 查询哪个员工的部门号是1001 或者 1002select * from emp3 where dept_id in (select deptno from dept3 where name = &#x27;研发部&#x27; or name = &#x27;销售部&#x27;);  -- 多行单列，多个值 -- 查询研发部20岁以下的员工信息,包括员工号、员工名字，部门名字-- 方式1-关联查询select * from dept3 a join emp3 b on a.deptno = b.dept_id and (name = &#x27;研发部&#x27; and age &lt; 20);-- 方式2-子查询-- 2.1 在部门表中查询研发部信息select * from dept3 where name = &#x27;研发部&#x27;;  -- 单行多列-- 2.2 在员工表中查询年龄小于20岁的员工信息select * from emp3 where age &lt; 20;-- 2.3 将以上两个查询的结果进行关联查询select * from (select * from dept3 where name = &#x27;研发部&#x27;) t1 join (select * from emp3 where age &lt;20) t2 on t1.deptno = t2.dept_id;  -- 多行多列\n子查询关键字\n介绍\n\n在子查询中，有一些常用的逻辑关键字，这些关键字可以给我们提供更丰富的查询功能，主要关键字如下：\n\nALL关键字\nANY关键字\nSOME关键字\nIN关键字\nEXISTS关键字\n\n\n子查询关键字—ALL\n格式\nselect …from …where c &gt; all(查询语句)-- 等价于：select ...from ... where c &gt; result1 and c &gt; result2 and c &gt; result3\n特点\n\n\nALL: 与子查询返回的所有值比较为true则返回true\nALL可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的所有数据。\nALL表示指定列中的值必须要大于子查询集的每一个值，即必须要大于子查询集的最大值；如果是小于号即小于子查询集的最小值。同理可以推出其它的比较运算符的情况。\n\n\n操作\n-- 1.查询年龄大于‘1003’部门所有年龄的员工信息select * from emp3 where age &gt; all(select age from emp3 where dept_id = &#x27;1003&#x27;);-- 2.查询不属于任何一个部门的员工信息select * from emp3 where dept_id != all(select deptno from dept3);\n子查询关键字-ANY和SOME\n格式\nselect …from …where c &gt; any(查询语句)--等价于：select ...from ... where c &gt; result1 or c &gt; result2 or c &gt; result3\n特点\n\n\nANY:与子查询返回的任何值比较为true 则返回true\nANY可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的任何一个数据。\n表示制定列中的值要大于子查询中的任意一个值，即必须要大于子查询集中的最小值。同理可以推出其它的比较运算符的情况。\nSOME和ANY的作用一样，SOME可以理解为ANY的别名\n\n\n操作\n-- 查询年龄大于‘1003’部门任意一个员工年龄的员工信息select * from emp3 where age &gt; any(select age from emp3 where dept_id = &#x27;1003&#x27;);  -- 去掉自己后面加：and dept_id != &#x27;1003&#x27;  即可。-- 使用some(和any用处一样)select * from emp3 where age &gt; some(select age from emp3 where dept_id = &#x27;1003&#x27;) and dept_id != &#x27;1003&#x27;;\n子查询关键字-IN\n格式\nselect …from …where c in(查询语句)--等价于：select ...from ... where c = result1 or c = result2 or c = result3\n特点\n\n\nIN关键字，用于判断某个记录的值，是否在指定的集合中\n在IN关键字前边加上not可以将条件反过来\n\n\n操作\n-- 查询研发部和销售部的员工信息，包含员工号、员工名字select eid,ename from emp3 where dept_id in (select deptno from dept3 where name = &#x27;研发部&#x27; or name = &#x27;销售部&#x27;) ;\n子查询关键字-EXISTS\n格式\nselect …from …where exists(查询语句)\n特点\n\n\n该子查询如果“有数据结果”(至少返回一行数据)， 则该EXISTS() 的结果为“true”，外层查询执行\n该子查询如果“没有数据结果”（没有任何数据返回），则该EXISTS()的结果为“false”，外层查询不执行\nEXISTS后面的子查询不返回任何实际数据，只返回真或假，当返回真时 where条件成立\n注意，EXISTS关键字，比IN关键字的运算效率高，因此，在实际开发中，特别是大数据量时，推荐使用EXISTS关键字\n有exists的时候是从外向内查询（在exists中判断），而其他的都是从内向外查询\n\n\n操作\n-- 查询公司是否有大于60岁的员工，有则输出select * from emp3 a where exists(select * from emp3 b where a.age &gt; 60);-- 也可以使用 in 替换 select * from emp3 a where eid in(select eid from emp3 b where a.age &gt; 60);-- 查询有所属部门的员工信息select * from emp3 a where exists(select * from dept3 b where a.dept_id = b.deptno);-- 也可以使用 in 替换 select * from emp3 a where dept_id in(select deptno from dept3 b where a.dept_id = b.deptno);\n自关联查询\n概念\n\nMySQL有时在信息查询时需要进行对表自身进行关联查询，即一张表自己和自己关联，一张表当成多张表来用。注意自关联时表必须给表起别名。\n\n格式\nselect 字段列表 from 表1 a , 表1 b where 条件;或者 select 字段列表 from 表1 a [left] join 表1 b on 条件;\n操作\n-- 创建表,并建立自关联约束create table t_sanguo(    eid int primary key ,    ename varchar(20),    manager_id int, foreign key (manager_id) references t_sanguo (eid)  -- 添加自关联约束);-- 添加数据 insert into t_sanguo values(1,&#x27;刘协&#x27;,NULL);insert into t_sanguo values(2,&#x27;刘备&#x27;,1);insert into t_sanguo values(3,&#x27;关羽&#x27;,2);insert into t_sanguo values(4,&#x27;张飞&#x27;,2);insert into t_sanguo values(5,&#x27;曹操&#x27;,1);insert into t_sanguo values(6,&#x27;许褚&#x27;,5);insert into t_sanguo values(7,&#x27;典韦&#x27;,5);insert into t_sanguo values(8,&#x27;孙权&#x27;,1);insert into t_sanguo values(9,&#x27;周瑜&#x27;,8);insert into t_sanguo values(10,&#x27;鲁肃&#x27;,8); -- 进行关联查询-- 1.查询每个三国人物及他的上级信息，如:  关羽  刘备 select * from t_sanguo a, t_sanguo b where a.manager_id = b.eid;-- 也可以是（显示内连接查询）：select * from t_sanguo a join t_sanguo b on a.manager_id = b.eid;-- 2.查询所有人物及上级(左外连接➕自关联)select * from t_sanguo a left join t_sanguo b on a.manager_id = b.eid;-- 仅显示名字select a.ename,b.ename from t_sanguo a left join t_sanguo b on a.manager_id = b.eid;-- 3.查询所以人物、上级，上上级 比如：张飞  刘备  刘协select * from t_sanguo a left join t_sanguo b on a.manager_id = b.eid left join t_sanguo c on b.manager_id = c.eid;-- 仅显示名字select a.ename,b.ename,c.ename from t_sanguo a left join t_sanguo b on a.manager_id = b.eid left join t_sanguo c on b.manager_id = c.eid;\n练习\n-- 创建test1数据库create database test1;-- 选择使用test1数据库use test1;-- 创建部门表create table dept (\tdeptno int primary key,   -- 部门编号\tdname varchar(14),    -- 部门名称\tloc varchar(13)   -- 部门地址);-- 插入数据（部门表）insert into dept values (10,&#x27;accounting&#x27;,&#x27;new york&#x27;);insert into dept values (20,&#x27;research&#x27;,&#x27;dallas&#x27;);insert into dept values (30,&#x27;sales&#x27;,&#x27;chicago&#x27;);insert into dept values (40,&#x27;operations&#x27;,&#x27;boston&#x27;);-- 创建员工表create table emp (\tempno int primary key,  -- 员工编号\tename varchar(10),  -- 员工姓名\tjob varchar(9),  -- 员工工作\tmgr int,  -- 员工直属领导编号\thiredate date,  -- 入职时间\tsal double,  -- 工资\tcomm double,  -- 奖金\tdeptno int  -- 对应dept表的外键);-- 添加 部门 和 员工 之间的主外键关系alter table emp add constraint foreign key emp(deptno) references dept(deptno);-- 插入数据（员工表）insert into emp values(7369,&#x27;smith&#x27;,&#x27;clerk&#x27;,7902,&#x27;1980-12-17&#x27;,800,null,20);insert into emp values(7499,&#x27;allen&#x27;,&#x27;salesman&#x27;,7698,&#x27;1981-02-20&#x27;,1600,300,30);insert into emp values(7521,&#x27;ward&#x27;,&#x27;salesman&#x27;,7698,&#x27;1981-02-22&#x27;,1250,500,30);insert into emp values(7566,&#x27;jones&#x27;,&#x27;manager&#x27;,7839,&#x27;1981-04-02&#x27;,2975,null,20);insert into emp values(7654,&#x27;martin&#x27;,&#x27;salesman&#x27;,7698,&#x27;1981-09-28&#x27;,1250,1400,30);insert into emp values(7698,&#x27;blake&#x27;,&#x27;manager&#x27;,7839,&#x27;1981-05-01&#x27;,2850,null,30);insert into emp values(7782,&#x27;clark&#x27;,&#x27;manager&#x27;,7839,&#x27;1981-06-09&#x27;,2450,null,10);insert into emp values(7788,&#x27;scott&#x27;,&#x27;analyst&#x27;,7566,&#x27;1987-07-03&#x27;,3000,null,20);insert into emp values(7839,&#x27;king&#x27;,&#x27;president&#x27;,null,&#x27;1981-11-17&#x27;,5000,null,10);insert into emp values(7844,&#x27;turner&#x27;,&#x27;salesman&#x27;,7698,&#x27;1981-09-08&#x27;,1500,0,30);insert into emp values(7876,&#x27;adams&#x27;,&#x27;clerk&#x27;,7788,&#x27;1987-07-13&#x27;,1100,null,20);insert into emp values(7900,&#x27;james&#x27;,&#x27;clerk&#x27;,7698,&#x27;1981-12-03&#x27;,950,null,30);insert into emp values(7902,&#x27;ford&#x27;,&#x27;analyst&#x27;,7566,&#x27;1981-12-03&#x27;,3000,null,20);insert into emp values(7934,&#x27;miller&#x27;,&#x27;clerk&#x27;,7782,&#x27;1981-01-23&#x27;,1300,null,10);-- 创建工资等级表create table salgrade (\tgrade int,  -- 等级\tlosal double,  -- 最低工资\thisal double  -- 最高工资);-- 插入数据（工资等级表）insert into salgrade values (1,700,1200);insert into salgrade values (2,1201,1400);insert into salgrade values (3,1401,2000);insert into salgrade values (4,2001,3000);insert into salgrade values (5,3001,9999);-- 练习：-- 1、返回拥有员工的部门名、部门号。select distinct d.dname,d.deptno from dept d join emp e on d.deptno = e.deptno;-- 2、工资水平多于smith的员工信息。select * from emp where sal &gt; all(select sal from emp where ename = &#x27;smith&#x27;);-- 3、返回员工和所属经理的姓名。select a.ename,b.ename from emp a join emp b on a.mgr = b.empno;-- 4、返回雇员的雇佣日期早于其经理雇佣日期的员工及其经理姓名。select a.ename,a.hiredate,b.ename,b.hiredate from emp a join emp b on a.mgr = b.empno and a.hiredate &lt; b.hiredate;-- 5、返回员工姓名及其所在的部门名称。select a.ename,b.dname from emp a join dept b on a.deptno = b.deptno;-- 6、返回从事clerk工作的员工姓名和所在部门名称。select a.ename,b.dname,a.job from emp a join dept b on a.deptno = b.deptno and job = &#x27;clerk&#x27;;-- 7、返回部门号及其本部门的最低工资。select deptno,min(sal) from emp group by deptno;-- 8、返回销售部(sales)所有员工的姓名。select a.ename from emp a join dept b on a.deptno = b.deptno and b.dname = &#x27;sales&#x27;;-- 9、返回工资水平多于平均工资的员工。select * from emp where sal &gt; (select avg(sal) from emp);-- 10、返回与scott从事相同工作的员工。select * from emp where job = (select job from emp where ename = &#x27;scott&#x27;) and ename != &#x27;scott&#x27;;  -- and 以后是为了去掉自己-- 11、返回与30部门员工工资水平相同的员工姓名与工资。select * from emp where sal &gt; all(select sal from emp where deptno = 30);-- 12、返回员工工作及其从事此工作的最低工资。select job,min(sal) from emp group by job;-- 13、计算出员工的年薪，并且以年薪排序。select *,(sal * 12 + ifnull(comm,0)) year_sal from emp order by year_sal desc;-- 14、返回工资处于第四级别的员工的姓名。select * from emp where sal between (select losal from salgrade where grade = 4) and (select hisal from salgrade where grade = 4);-- 15、返回工资为二等级的职员名字、部门所在地。（select 后面可以按照题目写： c.grade,b.ename,a.loc）-- 显示内连接select * from dept a join emp b on a.deptno = b.deptno join salgrade c on c.grade = 2 and b.sal between c.losal and c.hisal;-- 隐式内连接select * from dept a,emp b,salgrade c where a.deptno = b.deptno and c.grade = 2 and b.sal between c.losal and c.hisal;\nMySQL函数\n基本介绍\n概述\n\n在MySQL中，为了提高代码重用性和隐藏实现细节，MySQL提供了很多函数。函数可以理解为别人封装好的模板代码。\n\n分类\n\n在MySQL中，函数非常多，主要可以分为以下几类:\n\n聚合函数\n数学函数\n字符串函数\n日期函数\n控制流函数\n窗口函数\n\n\n聚合函数\n概述\n\n在MySQL中，聚合函数主要由：count, sum, min, max, avg, 这些聚合函数我们之前都学过，不再重复。这里我们学习另外一个函数: group_concat(），该函数用户实现行的合并。\ngroup_concat()函数首先根据group by指定的列进行分组，并且用分隔符分隔，将同一个分组中的值连接起来，返回一个字符串结果。\n\n格式\ngroup_concat([distinct] 字段名 [order by 排序字段 asc/desc] [separator &#x27;分隔符&#x27;])\n\n说明：\n（1）使用distinct可以排除重复值；\n（2）如果需要对结果中的值进行排序，可以使用order by子句；\n（3）separator是一个字符串值，默认为逗号。\n\n操作\n-- 创建并选择mydb4create database mydb4;use mydb4;  -- 建表empcreate table emp(    emp_id int primary key auto_increment comment &#x27;编号&#x27;,    emp_name char(20) not null default &#x27;&#x27; comment &#x27;姓名&#x27;,    salary decimal(10,2) not null default 0 comment &#x27;工资&#x27;,    department char(20) not null default &#x27;&#x27; comment &#x27;部门&#x27;);  -- 插入数据insert into emp(emp_name,salary,department) values(&#x27;张晶晶&#x27;,5000,&#x27;财务部&#x27;),(&#x27;王飞飞&#x27;,5800,&#x27;财务部&#x27;),(&#x27;赵刚&#x27;,6200,&#x27;财务部&#x27;),(&#x27;刘小贝&#x27;,5700,&#x27;人事部&#x27;),(&#x27;王大鹏&#x27;,6700,&#x27;人事部&#x27;),(&#x27;张小斐&#x27;,5200,&#x27;人事部&#x27;),(&#x27;刘云云&#x27;,7500,&#x27;销售部&#x27;),(&#x27;刘云鹏&#x27;,7200,&#x27;销售部&#x27;),(&#x27;刘云鹏&#x27;,7800,&#x27;销售部&#x27;);\n-- 将所有员工的名字合并成一行 select group_concat(emp_name) from emp;\n\n-- 指定分隔符合并 select department,group_concat(emp_name separator &#x27;;&#x27; ) from emp group by department; \n\n-- 指定排序方式和分隔符 select department,group_concat(emp_name order by salary desc separator &#x27;;&#x27; ) from emp group by department;\n\n数学函数\n函数名\n由于表格行数有限，也为了方便查看，以下分为三张表来展示(加粗代表常用)：\n\n\n\n函数名\n描述\n实例\n\n\n\n\nABS(x)\n返回 x 的绝对值\n返回 -1 的绝对值：SELECT ABS(-1) – 返回1\n\n\nCEIL(x)\n返回大于或等于 x 的最小整数(向上取整)\nSELECT CEIL(1.5) – 返回2\n\n\nFLOOR(x)\n返回小于或等于 x 的最大整数(向下取整)\n小于或等于 1.5 的整数：SELECT FLOOR(1.5) – 返回1\n\n\nGREATEST(expr1, expr2, expr3, …)\n返回列表中的最大值\n返回以下数字列表中的最大值：SELECT GREATEST(3, 12, 34, 8, 25); – 34返回以下字符串列表中的最大值：SELECT GREATEST(“Google”, “Runoob”, “Apple”);   – Runoob\n\n\nLEAST(expr1, expr2, expr3, …)\n返回列表中的最小值\n返回以下数字列表中的最小值：SELECT LEAST(3, 12, 34, 8, 25); – 3返回以下字符串列表中的最小值：SELECT LEAST(“Google”, “Runoob”, “Apple”);   – Apple\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nMAX(expression)\n返回字段 expression 中的最大值\n返回数据表 Products 中字段 Price 的最大值：SELECT MAX(Price) AS LargestPrice FROM Products;\n\n\nMIN(expression)\n返回字段 expression 中的最小值\n返回数据表 Products 中字段 Price 的最小值：SELECT MIN(Price) AS MinPrice FROM Products;\n\n\nMOD(x,y)\n返回 x 除以 y 以后的余数\n5 除于 2 的余数：SELECT MOD(5,2) – 1\n\n\nPI()\n返回圆周率(3.141593）\nSELECT PI() --3.141593\n\n\nPOW(x,y)\n返回 x 的 y 次方\n2 的 3 次方：SELECT POW(2,3) – 8\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nRAND()\n返回 0 到 1 的随机数\nSELECT RAND() --0.93099315644334\n\n\nROUND(x)\n返回离 x 最近的整数（遵循四舍五入）\nSELECT ROUND(1.23456) --1\n\n\nROUND(x,y)\n返回指定位数的小数（遵循四舍五入）\nSELECT ROUND(1.23456,3) –1.235\n\n\nTRUNCATE(x,y)\n返回数值 x 保留到小数点后 y 位的值（与 ROUND 最大的区别是不会进行四舍五入）\nSELECT TRUNCATE(1.23456,3) – 1.234\n\n\n\n操作\n-- 案例：通过数据库的函数，生成一个六位数的随机验证码。select lpad(round(rand()*1000000,0),6,&#x27;0&#x27;);-- 四舍五入平均价格，保留两位小数。use mydb2;select category_id,round(avg(price),2) from product group by category_id;\n字符串函数\n字符串等的位置：从1开始；索引：从0开始。两者都是描述位置的，但是计数起点不同。\n函数名\n\n\n\n函数\n描述\n实例\n\n\n\n\nCHAR_LENGTH(s)\n返回字符串 s 的字符数\n返回字符串 RUNOOB 的字符数SELECT CHAR_LENGTH(“RUNOOB”) AS LengthOfString;\n\n\nLENGTH(s)\n返回字符串 s 的字节数\nSELECT LENGTH(“明天”) AS LengthOfString;   – 6（utf-8 一个汉字为3个字节）\n\n\nCHARACTER_LENGTH(s)\n返回字符串 s 的字符数\n返回字符串 RUNOOB 的字符数SELECT CHARACTER_LENGTH(“RUNOOB”) AS LengthOfString;\n\n\nCONCAT(s1,s2…sn)\n字符串 s1,s2 等多个字符串合并为一个字符串\n合并多个字符串SELECT CONCAT(&quot;SQL &quot;, &quot;Runoob &quot;, &quot;Gooogle &quot;, “Facebook”) AS ConcatenatedString;\n\n\nCONCAT_WS(x, s1,s2…sn)\n同 CONCAT(s1,s2,…) 函数，但是每个字符串之间要加上 x，x 可以是分隔符\n合并多个字符串，并添加分隔符：SELECT CONCAT_WS(“-”, “SQL”, “Tutorial”, “is”, “fun!”)AS ConcatenatedString;\n\n\nFIELD(s,s1,s2…)\n返回第一个字符串 s 在字符串列表(s1,s2…)中的位置\n返回字符串 c 在列表值中的位置：SELECT FIELD(“c”, “a”, “b”, “c”, “d”, “e”,“c”);  后面重复的’c’就不会输出位置，只能输出第一个查到的‘c’\n\n\n\n\n\n\n函数\n描述\n实例\n\n\n\n\nLTRIM(s)\n去掉字符串 s 开始处的空格\n去掉字符串 RUNOOB开始处的空格：SELECT LTRIM(&quot;    RUNOOB&quot;) AS LeftTrimmedString;-- RUNOOB\n\n\nRTRIM(s)\n去掉字符串 s 结尾处的空格\n去掉字符串 RUNOOB结尾处的空格：SELECT RTRIM(&quot;      RUNOOB    &quot;) AS LeftTrimmedString;-- RUNOOB\n\n\nMID(s,n,len)\n从字符串 s 的 n 位置截取长度为 len 的子字符串，同 SUBSTRING(s,n,len)\n从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：SELECT MID(“RUNOOB”, 2, 3) AS ExtractString; – UNO\n\n\nPOSITION(s1 IN s)\n从字符串 s 中获取 s1 的开始位置\n返回字符串 abc 中 b 的位置：SELECT POSITION(‘b’ in ‘abc’) – 2\n\n\nREPLACE(s,s1,s2)\n将字符串 s2 替代字符串 s 中的字符串 s1\n将字符串 abc 中的字符 a 替换为字符 x：SELECT REPLACE(‘abca’,‘a’,‘x’) --xbcx\n\n\nREVERSE(s)\n将字符串s的顺序反过来\n将字符串 abc 的顺序反过来：SELECT REVERSE(‘abc’) – cba\n\n\n\n\n\n\n函数\n描述\n实例\n\n\n\n\nLEFT(s,n)\n返回字符串 s 的前 n 个字符\n返回字符串 runoob 的前两个字符：SELECT left(‘runoob’,2) – ru\n\n\nRIGHT(s,n)\n返回字符串 s 的后 n 个字符\n返回字符串 runoob 的后两个字符：SELECT RIGHT(‘runoob’,2) – ob\n\n\nSTRCMP(s1,s2)\n比较字符串 s1 和 s2，如果 s1 与 s2 相等返回 0 ，如果 s1&gt;s2 返回 1，如果 s1&lt;s2 返回 -1\n比较字符串：SELECT STRCMP(“runoob”, “runoob”);  – 0\n\n\nSUBSTR(s, start, length)\n从字符串 s 的 start 位置截取长度为 length 的子字符串\n从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：SELECT SUBSTR(“RUNOOB”, 2, 3) AS ExtractString; – UNO\n\n\nSUBSTRING(s, start, length)\n从字符串 s 的 start 位置截取长度为 length 的子字符串\n从字符串 RUNOOB 中的第 2 个位置截取 3个 字符：SELECT SUBSTRING(“RUNOOB”, 2, 3) AS ExtractString; – UNO\n\n\n\n\n\n\n函数\n描述\n实例\n\n\n\n\nTRIM(s)\n去掉字符串 s 开始和结尾处的空格\n去掉字符串 RUNOOB 的首尾空格：SELECT TRIM(’    RUNOOB    ') AS TrimmedString;\n\n\nUCASE(s)\n将字符串转换为大写\n将字符串 runoob 转换为大写：SELECT UCASE(“runoob”); – RUNOOB\n\n\nUPPER(s)\n将字符串转换为大写\n将字符串 runoob 转换为大写：SELECT UPPER(“runoob”); – RUNOOB\n\n\nLCASE(s)\n将字符串 s 的所有字母变成小写字母\n字符串 RUNOOB 转换为小写：SELECT LCASE(‘RUNOOB’) – runoob\n\n\nLOWER(s)\n将字符串 s 的所有字母变成小写字母\n字符串 RUNOOB 转换为小写：SELECT LOWER(‘RUNOOB’) – runoob\n\n\nLPAD(str,n,pad)\n左填充，用字符串pad对str的左边进行填充，达到n个字符串长度\n左填充：select lpad(‘01’,5,‘-’);\n\n\nRPAD(str,n,pad)\n右填充，用字符串pad对str的右边进行填充，达到n个字符串长度\n右填充：select rpad(‘01’,5,‘-’);\n\n\n\n操作\n-- 案例：由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0，比如：1号员工的工号应该为00001update emp set workno = lpad(&#x27;1&#x27;,5,&#x27;0&#x27;);\n日期函数\n函数名\n\n\n\n函数名\n描述\n实例\n\n\n\n\nUNIX_TIMESTAMP()\n返回从1970-01-01 00:00:00到当前毫秒值(时间戳)\nselect UNIX_TIMESTAMP() -&gt; 1632729059\n\n\nUNIX_TIMESTAMP(DATE_STRING)\n将制定日期转为毫秒值时间戳\nSELECT UNIX_TIMESTAMP(‘2011-12-07 13:01:03’);\n\n\nFROM_UNIXTIME(BIGINT UNIXTIME[, STRING FORMAT])\n将毫秒值时间戳转为指定格式日期\nSELECT FROM_UNIXTIME(1598079966,‘%Y-%m-%d %H:%i:%s’); (1598079966,‘%Y-%m-%d %H:%i:%s’); -&gt; 2020-08-22 15-06-06\n\n\nCURDATE()\n返回当前日期\nSELECT CURDATE();-&gt; 2018-09-19\n\n\nCURRENT_DATE()\n返回当前日期\nSELECT CURRENT_DATE();-&gt; 2018-09-19\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nCURRENT_TIME\n返回当前时间\nSELECT CURRENT_TIME();-&gt; 19:59:02\n\n\nCURTIME()\n返回当前时间\nSELECT CURTIME();-&gt; 19:59:02\n\n\nCURRENT_TIMESTAMP()\n返回当前日期和时间\nSELECT CURRENT_TIMESTAMP()-&gt; 2018-09-19 20:57:43\n\n\nDATE()\n从日期或日期时间表达式中提取日期值\nSELECT DATE(“2017-06-15”);    -&gt; 2017-06-15\n\n\nDATEDIFF(d1,d2)\n计算日期 d1-&gt;d2 之间相隔的天数\nSELECT DATEDIFF(‘2001-01-01’,‘2001-02-02’)-&gt; -32\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nTIMEDIFF(time1, time2)\n计算时间差值\nSELECT TIMEDIFF(“13:10:11”, “13:10:10”);-&gt; 00:00:01\n\n\nDATE_FORMAT(d,f)\n按表达式 f的要求显示日期 d\nSELECT DATE_FORMAT(‘2011-11-11 11:11:11’,‘%Y-%m-%d %r’)-&gt; 2011-11-11 11:11:11 AM\n\n\nSTR_TO_DATE(string, format_mask)\n将字符串转变为日期\nSELECT STR_TO_DATE(“August 10 2017”, “%M %d %Y”);-&gt; 2017-08-10\n\n\nDATE_SUB(date,INTERVAL expr type)\n函数从日期减去指定的时间间隔。\nOrders 表中 OrderDate 字段减去 2 天：SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 2 DAY) AS OrderPayDate FROM Orders;\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nADDDATE/DATE_ADD(d，INTERVAL expr type)\n计算起始日期 d 加上一个时间段后的日期，type 值可以是：MICROSECONDSECONDMINUTEHOURDAYWEEKMONTHQUARTERYEARDAY_MINUTEDAY_HOURYEAR_MONTH\nSELECT DATE_ADD(“2017-06-15”, INTERVAL 10 DAY); -&gt; 2017-06-25SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL 15 MINUTE); -&gt; 2017-06-15 09:49:21SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 HOUR); -&gt;2017-06-15 06:34:21SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 HOUR); -&gt;2017-04-15\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nDATE_ADD(d，INTERVAL expr type)\n计算起始日期 d 加上一个时间段后的日期，type 值可以是：SECOND_MICROSECONDMINUTE_MICROSECONDMINUTE_SECONDHOUR_MICROSECONDHOUR_SECONDHOUR_MINUTEDAY_MICROSECONDDAY_SECONDDAY_MINUTEDAY_HOURYEAR_MONTH\nSELECT DATE_ADD(“2017-06-15”, INTERVAL 10 DAY);  -&gt; 2017-06-25SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL 15 MINUTE);  -&gt; 2017-06-15 09:49:21SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 HOUR);  -&gt;2017-06-15 06:34:21SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 HOUR);  -&gt;2017-04-15\n\n\n\n\n\n\n\n\n\n\n\n\n\nEXTRACT(type FROM d)\n从日期 d 中获取指定的值，type 指定返回的值。type可取值为：MICROSECONDSECONDMINUTEHOUR    ……\nSELECT EXTRACT(MINUTE FROM ‘2011-11-11 11:11:11’) -&gt; 11\n\n\nLAST_DAY(d)\n返回给给定日期的那一月份的最后一天\nSELECT LAST_DAY(“2017-06-20”);-&gt; 2017-06-30\n\n\nMAKEDATE(year, day-of-year)\n基于给定参数年份 year 和所在年中的天数序号 day-of-year 返回一个日期\nSELECT MAKEDATE(2017, 3);-&gt; 2017-01-03\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nYEAR(d)\n返回年份\nSELECT YEAR(“2017-06-15”);-&gt; 2017\n\n\nMONTH(d)\n返回日期d中的月份值，1 到 12\nSELECT MONTH(‘2011-11-11 11:11:11’)-&gt;11\n\n\nDAY(d)\n返回日期值 d 的日期部分\nSELECT DAY(“2017-06-15”);  -&gt; 15\n\n\nHOUR(t)\n返回 t 中的小时值\nSELECT HOUR(‘1:2:3’)-&gt; 1\n\n\nMINUTE(t)\n返回 t 中的分钟值\nSELECT MINUTE(‘1:2:3’)-&gt; 2\n\n\nSECOND(t)\n返回 t 中的秒钟值\nSELECT SECOND(‘1:2:3’)-&gt; 3\n\n\nQUARTER(d)\n返回日期d是第几季节，返回 1 到 4\nSELECT QUARTER(‘2011-11-11 11:11:11’)-&gt; 4\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nMONTHNAME(d)\n返回日期当中的月份名称，如 November\nSELECT MONTHNAME(‘2011-11-11 11:11:11’)-&gt; November\n\n\nDAYNAME(d)\n返回日期 d 是星期几，如 Monday,Tuesday\nSELECT DAYNAME(‘2011-11-11 11:11:11’)-&gt;Friday\n\n\nDAYOFMONTH(d)\n计算日期 d 是本月的第几天\nSELECT DAYOFMONTH(‘2011-11-11 11:11:11’)-&gt;11\n\n\nDAYOFWEEK(d)\n日期 d 今天是星期几，1 星期日，2 星期一，以此类推\nSELECT DAYOFWEEK(‘2011-11-11 11:11:11’)-&gt;6\n\n\nDAYOFYEAR(d)\n计算日期 d 是本年的第几天\nSELECT DAYOFYEAR(‘2011-11-11 11:11:11’)-&gt;315\n\n\n\n\n\n\n函数名\n描述\n实例\n\n\n\n\nWEEK(d)\n计算日期 d 是本年的第几个星期，范围是 0 到 53\nSELECT WEEK(‘2011-11-11 11:11:11’)-&gt; 45\n\n\nWEEKDAY(d)\n日期 d 是星期几，0 表示星期一，1 表示星期二\nSELECT WEEKDAY(“2017-06-15”);-&gt; 3\n\n\nWEEKOFYEAR(d)\n计算日期 d 是本年的第几个星期，范围是 0 到 53\nSELECT WEEKOFYEAR(‘2011-11-11 11:11:11’)-&gt; 45\n\n\nYEARWEEK(date, mode)\n返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推\nSELECT YEARWEEK(“2017-06-15”);-&gt; 201724\n\n\nNOW()\n返回当前日期和时间\nSELECT NOW()-&gt; 2018-09-19 20:57:43\n\n\n\n操作\n-- 案例：查询所有员工的入职天数，并根据入职天数倒序排序。select ename, datediff(curdate(), hiredate) hiredays from emp order by hiredays desc;\n控制流函数\nif逻辑判断语句\n\n\n\n格式\n解释\n案例\n\n\n\n\nIF(expr,v1,v2)\n如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。\nSELECT IF(1 &gt; 0,‘正确’,‘错误’)    -&gt;正确\n\n\nIFNULL(v1,v2)\n如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。\nSELECT IFNULL(null,‘Hello Word’)  -&gt;Hello Word\n\n\nISNULL(expression)\n判断表达式是否为 NULL\nSELECT ISNULL(NULL);  -&gt;1\n\n\nNULLIF(expr1, expr2)\n比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1\nSELECT NULLIF(25, 25);  -&gt;null\n\n\n\ncase when语句\n\n\n\n格式\n解释\n操作\n\n\n\n\nCASE expression    WHEN condition1 THEN result1    WHEN condition2 THEN result2   …    WHEN conditionN THEN resultN    ELSE resultEND\nCASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。\nselect case 100 when 50 then ‘tom’ when 100 then ‘mary’else ‘tim’ end ;select case when 1=2 then ‘tom’ when 2=2 then ‘mary’ else’tim’ end ;\n\n\n\n案例\n-- 案例1：use mydb4;-- 创建订单表create table orders(\toid int primary key,  -- 订单id\tprice double,  -- 订单价格\tpayType int  -- 支付类型(1:微信支付 2:支付宝支付 3:银行卡支付 4:其他));-- 插入数据insert into orders values(1,1200,1);insert into orders values(2,1000,2);insert into orders values(3,200,3);insert into orders values(4,3000,1);insert into orders values(5,1500,2);-- 操作-- 方式1select \t*,\tcase payType \t\twhen 1 then &#x27;微信支付&#x27; \t\twhen 2 then &#x27;支付宝支付&#x27;\t\twhen 3 then &#x27;银行卡支付&#x27;\t\telse \t\t\t&#x27;其他支付方式&#x27; \tend as payTypeStrfrom orders;-- 方式2select \t*,\tcase  \t\twhen payType=1 then &#x27;微信支付&#x27; \t\twhen payType=2 then &#x27;支付宝支付&#x27;\t\twhen payType=3 then &#x27;银行卡支付&#x27;\t\telse \t\t\t&#x27;其他支付方式&#x27; \tend as payTypeStrfrom orders;-- 案例2：统计班级各个学员的成绩，展示的规则如下：-- &gt;= 85，展示优秀-- &gt;= 60，展示及格-- 否则，展示不及格use mydb4;-- 创建表并插入数据create table score(\tid int comment &#x27;ID&#x27;,\tname varchar(20) comment &#x27;姓名&#x27;,\tmath int comment &#x27;数学&#x27;,\tenglish int comment &#x27;英语&#x27;,\tchinese int comment &#x27;语文&#x27;) comment &#x27;学员成绩表&#x27;;insert into score(id,name,math,english,chinese) values(1,&#x27;Tom&#x27;,67,88,95),(2,&#x27;Rose&#x27;,23,66,90),(3,&#x27;Jack&#x27;,56,98,76);-- 操作select \tid,\tname,\tcase when math &gt;= 85 then &#x27;优秀&#x27; when math &gt;=60 then &#x27;及格&#x27; else &#x27;不及格&#x27; end &#x27;数学&#x27;,\tcase when english &gt;= 85 then &#x27;优秀&#x27; when english &gt;=60 then &#x27;及格&#x27; else &#x27;不及格&#x27; end &#x27;英语&#x27;,\tcase when chinese &gt;= 85 then &#x27;优秀&#x27; when chinese &gt;=60 then &#x27;及格&#x27; else &#x27;不及格&#x27; end &#x27;语文&#x27;from score;\n窗口函数\n介绍\n\n\nMySQL 8.0 新增窗口函数 ,窗口函数又被称为开窗函数，与Oracle 窗口函数类似，属于MySQL的一大特点。\n非聚合窗口函数是相对于聚函数来说的。聚合函数是对一组数据计算后返回单个值（即分组），非聚合函数一次只会处理一行数据。窗口聚合函数在行记录上计算某个字段的结果时，可将窗口范围内的数据输入到聚合函数中，并不改变行数。\n\n\n\n分类\n\n另外还有开窗聚合函数: SUM,AVG,MIN,MAX\n语法结构\nwindow_function ( expr ) OVER (   PARTITION BY ...   ORDER BY ...   frame_clause )\n\n其中，window_function 是窗口函数的名称；expr 是参数，有些函数不需要参数；OVER子句包含三个选项：\n\n\n分区（PARTITION BY）:\n\nPARTITION BY选项用于将数据行拆分成多个分区（组），它的作用类似于GROUP BY分组。如果省略了 PARTITION BY，所有的数据作为一个组进行计算\n\n排序（ORDER BY）:\n\nOVER 子句中的ORDER BY选项用于指定分区内的排序方式，与 ORDER BY 子句的作用类似\n\n以及窗口大小（frame_clause）:\n\nframe_clause选项用于在当前分区内指定一个计算窗口，也就是一个与当前行相关的数据子集。\n\n\n序号函数\n序号函数有三个：ROW_NUMBER()、RANK()、DENSE_RANK()，可以用来实现分组排序，并添加序号。\n格式\nrow_number()|rank()|dense_rank() over (   partition by ...   order by ... ) \n操作\nuse mydb4; create table employee(    dname varchar(20), -- 部门名    eid varchar(20),    ename varchar(20),    hiredate date, -- 入职日期    salary double -- 薪资); -- 插入数据insert into employee values(&#x27;研发部&#x27;,&#x27;1001&#x27;,&#x27;刘备&#x27;,&#x27;2021-11-01&#x27;,3000);insert into employee values(&#x27;研发部&#x27;,&#x27;1002&#x27;,&#x27;关羽&#x27;,&#x27;2021-11-02&#x27;,5000);insert into employee values(&#x27;研发部&#x27;,&#x27;1003&#x27;,&#x27;张飞&#x27;,&#x27;2021-11-03&#x27;,7000);insert into employee values(&#x27;研发部&#x27;,&#x27;1004&#x27;,&#x27;赵云&#x27;,&#x27;2021-11-04&#x27;,7000);insert into employee values(&#x27;研发部&#x27;,&#x27;1005&#x27;,&#x27;马超&#x27;,&#x27;2021-11-05&#x27;,4000);insert into employee values(&#x27;研发部&#x27;,&#x27;1006&#x27;,&#x27;黄忠&#x27;,&#x27;2021-11-06&#x27;,4000); insert into employee values(&#x27;销售部&#x27;,&#x27;1007&#x27;,&#x27;曹操&#x27;,&#x27;2021-11-01&#x27;,2000);insert into employee values(&#x27;销售部&#x27;,&#x27;1008&#x27;,&#x27;许褚&#x27;,&#x27;2021-11-02&#x27;,3000);insert into employee values(&#x27;销售部&#x27;,&#x27;1009&#x27;,&#x27;典韦&#x27;,&#x27;2021-11-03&#x27;,5000);insert into employee values(&#x27;销售部&#x27;,&#x27;1010&#x27;,&#x27;张辽&#x27;,&#x27;2021-11-04&#x27;,6000);insert into employee values(&#x27;销售部&#x27;,&#x27;1011&#x27;,&#x27;徐晃&#x27;,&#x27;2021-11-05&#x27;,9000);insert into employee values(&#x27;销售部&#x27;,&#x27;1012&#x27;,&#x27;曹洪&#x27;,&#x27;2021-11-06&#x27;,6000);\nrow_number()\n-- 对每个部门的员工按照薪资降序排序，并给出排名select dname,ename,salary,row_number() over(partition by dname order by salary desc) as rn from employee;\n\nrank()\n-- 对每个部门的员工按照薪资排序，并给出排名 rankselect dname,ename,salary,rank() over(partition by dname order by salary desc) as rn from employee;\n\ndense_rank()\n-- 对每个部门的员工按照薪资排序，并给出排名 dense-rankselect dname,ename,salary,dense_rank() over(partition by dname order by salary desc) as rn from employee;\n\n--求出每个部门薪资排在前三名的员工- 分组求TOPNselect * from (    select      dname,     ename,     salary,     dense_rank() over(partition by dname order by salary desc)  as rn    from employee)twhere t.rn &lt;= 3\n\n-- 对所有员工进行全局排序（不分组）-- 不加partition by表示全局排序select      dname,     ename,     salary,     dense_rank() over( order by salary desc)  as rnfrom employee;\n\n开窗聚合函数- SUM,AVG,MIN,MAX\n概念\n\n在窗口中每条记录动态地应用聚合函数（SUM()、AVG()、MAX()、MIN()、COUNT()），可以动态计算在指定的窗口内的各种聚合函数值。\n\n操作\n-- 开窗聚合函数select   dname, ename, salary, sum(salary) over(partition by dname order by hiredate) as pv1 from employee; select  dname, ename, salary, sum(salary) over(partition by dname) as pv3from employee;  -- 如果没有order  by排序语句  默认把分组内的所有数据进行sum操作select   dname, ename, salary, sum(salary) over(partition by dname order by hiredate  rows between unbounded preceding and current row) as c1 from employee;    -- rows代表行，between从哪里到哪里，unbounded preceding代表 从开头 开始 到当前行current row 结束 select   dname, ename, salary, sum(salary) over(partition by dname order by hiredate   rows between 3 preceding and current row) as c1 from employee;   -- rows代表行，between从哪里到哪里，3 preceding代表 从当前行向上三行 开始 到当前行current row 结束select   dname, ename, salary, sum(salary) over(partition by dname order by hiredate   rows between 3 preceding and 1 following) as c1 from employee; -- rows代表行，between从哪里到哪里，3 preceding代表 从当前行向上三行 开始 到当前行下一行 1 following 结束select   dname, ename, salary, sum(salary) over(partition by dname order by hiredate   rows between current row and unbounded following) as c1 from employee;    -- rows代表行，between从哪里到哪里，current row代表 从当前行 开始 到最后 unbounded following 结束 \n分布函数-(CUME_DIST)\n介绍\n\n\n用途：分组内小于、等于当前rank值的行数 / 分组内总行数\n应用场景：查询小于等于当前薪资（salary）的比例\n\n\n操作\nselect   dname, ename, salary, cume_dist() over(order by salary) as rn1, -- 没有partition语句 所有的数据位于一组 cume_dist() over(partition by dname order by salary) as rn2 from employee;/*rn1: 没有partition,所有数据均为1组，总行数为12，     第一行：小于等于3000的行数为3，因此，3/12=0.25     第二行：小于等于4000的行数为5，因此，5/12=0.4166666666666667rn2: 按照部门分组，dname=&#x27;研发部&#x27;的行数为6,     第一行：研发部小于等于3000的行数为1，因此，1/6=0.16666666666666666*/\n\n分布函数-(PERCENT_RANK)\n介绍\n\n\n用途：每行按照公式(rank-1) / (rows-1)进行计算。其中，rank为RANK()函数产生的序号，rows为当前窗口的记录总行数；\n应用场景：不常用。\n\n\n操作\nselect  dname, ename, salary, rank() over(partition by dname order by salary desc ) as rn, percent_rank() over(partition by dname order by salary desc ) as rn2from employee;/* rn2:  第一行: (1 - 1) / (6 - 1) = 0  第二行: (1 - 1) / (6 - 1) = 0  第三行: (3 - 1) / (6 - 1) = 0.4*/\n\n前后函数-LAG和LEAD\n介绍\n\n\n用途：返回位于当前行的前n行（LAG(expr,n)）或后n行（LEAD(expr,n)）的expr的值\n应用场景：查询前1名同学的成绩和当前同学成绩的差值\n\n\n操作\n-- lag的用法select  dname, ename, salary, hiredate, lag(hiredate,1,&#x27;2000-01-01&#x27;) over(partition by dname order by hiredate) as last_1_time, lag(hiredate,2) over(partition by dname order by hiredate) as last_2_time from employee;/*last_1_time: 指定了往上第1行的值，default为&#x27;2000-01-01&#x27;                           第一行，往上1行为null,因此取默认值 &#x27;2000-01-01&#x27;                         第二行，往上1行值为第一行值，2021-11-01                          第三行，往上1行值为第二行值，2021-11-02 last_2_time: 指定了往上第2行的值，为指定默认值                         第一行，往上2行为null                         第二行，往上2行为null                         第四行，往上2行为第二行值，2021-11-01                          第七行，往上2行为第五行值，2021-11-02 */-- lead的用法select  dname, ename, salary, hiredate, lead(hiredate,1,&#x27;2000-01-01&#x27;) over(partition by dname order by hiredate) as last_1_time, lead(hiredate,2) over(partition by dname order by hiredate) as last_2_time from employee;\nLAG(expr,n)：\n\nLEAD(expr,n)：\n\n头尾函数-FIRST_VALUE和LAST_VALUE\n介绍\n用途：返回第一个（FIRST_VALUE(expr)）或最后一个（LAST_VALUE(expr)）expr的值\n应用场景：截止到当前，按照日期排序查询第1个入职和最后1个入职员工的薪资\n操作\n-- 注意,  如果不指定ORDER BY，则进行排序混乱，会出现错误的结果select  dname,  ename,  hiredate,  salary,  first_value(salary) over(partition by dname order by hiredate) as first,  last_value(salary) over(partition by dname order by  hiredate) as last from  employee;\n\n其他函数-NTH_VALUE(expr, n)、NTILE(n)\n介绍-NTH_VALUE(expr,n)\n\n\n用途：返回窗口中第n个expr的值。expr可以是表达式，也可以是列名\n应用场景：截止到当前薪资，显示每个员工的薪资中排名第2或者第3的薪资\n\n\n操作\n-- 查询每个部门截止目前薪资排在第二和第三的员工信息select   dname,  ename,  hiredate,  salary,  nth_value(salary,2) over(partition by dname order by hiredate) as second_score,  nth_value(salary,3) over(partition by dname order by hiredate) as third_scorefrom employee;\n\n介绍-NTILE(n)\n\n\n用途：将分区中的有序数据分为n个等级，记录等级数\n应用场景：将每个部门员工按照入职日期分成3组\n\n\n操作\n-- 根据入职日期将每个部门的员工分成3组select   dname,  ename,  hiredate,  salary,ntile(3) over(partition by dname order by  hiredate  ) as rn from employee;\n\n练习\n-- 取出每个部门的第一组员工select*from(    SELECT         dname,        ename,        hiredate,        salary,    NTILE(3) OVER(PARTITION BY dname ORDER BY  hiredate  ) AS rn     FROM employee)twhere t.rn = 1;\n\nMySQL的视图\n介绍\n\n\n视图（view）是一个虚拟表，非真实存在，其本质是根据SQL语句获取动态的数据集，并为其命名，用户使用时只需使用视图名称即可获取结果集，并可以将其当作表来使用。(就是原表的一个映射)\n数据库中只存放了视图的定义，而并没有存放视图中的数据。这些数据存放在原来的表中。\n使用视图查询数据时，数据库系统会从原来的表中取出对应的数据。因此，视图中的数据是依赖于原来的表中的数据的。一旦表中的数据发生改变，显示在视图中的数据也会发生改变。\n\n\n作用\n\n\n简化代码，可以把重复使用的查询封装成视图重复使用，同时可以使复杂的查询易于理解和使用。\n安全原因，如果一张表中有很多数据，很多信息不希望让所有人看到，此时可以使用视图视，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，可以对不同的用户，设定不同的视图。\n\n\n视图的创建\n格式\n创建视图的语法为：\ncreate [or replace] [algorithm = &#123;undefined | merge | temptable&#125;] view view_name [(column_list)] as select_statement [with [cascaded | local] check option]参数说明：（1）algorithm：可选项，表示视图选择的算法。（2）view_name ：表示要创建的视图名称。（3）column_list：可选项，指定视图中各个属性的名词，默认情况下与SELECT语句中的查询的属性相同。（4）select_statement  ：表示一个完整的查询语句，将查询记录导入视图中。（5）[with [cascaded | local] check option] ：可选项，表示更新视图时要保证在该视图的权限范围之内。\n数据准备\n创建 数据库mydb6_view,然后在该数据库下执行sql脚本view_data.sql 导入数据\ncreate database mydb6_view;-- 创建部门表并插入数据create table dept(\tdeptno int primary key,  dname varchar(20),\tloc varchar(20));insert into dept values(10, &#x27;教研部&#x27;,&#x27;北京&#x27;),(20, &#x27;学工部&#x27;,&#x27;上海&#x27;),(30, &#x27;销售部&#x27;,&#x27;广州&#x27;),(40, &#x27;财务部&#x27;,&#x27;武汉&#x27;);-- 创建员工表并插入数据create table emp(\tempno int primary key,\tename varchar(20),\tjob varchar(20),\tmgr int,\thiredate date,\tsal numeric(8,2),\tcomm numeric(8, 2),\tdeptno int,-- \tFOREIGN KEY (mgr) REFERENCES emp(empno),\tFOREIGN KEY (deptno) REFERENCES dept(deptno) ON DELETE SET NULL ON UPDATE CASCADE);INSERT INTO emp VALUES(1001, &#x27;甘宁&#x27;, &#x27;文员&#x27;, 1013, &#x27;2000-12-17&#x27;, 8000.00, NULL, 20),(1002, &#x27;黛绮丝&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-02-20&#x27;, 16000.00, 3000.00, 30),(1003, &#x27;殷天正&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-02-22&#x27;, 12500.00, 5000.00, 30),(1004, &#x27;刘备&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-4-02&#x27;, 29750.00, NULL, 20),(1005, &#x27;谢逊&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-9-28&#x27;, 12500.00, 14000.00, 30),(1006, &#x27;关羽&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-05-01&#x27;, 28500.00, NULL, 30),(1007, &#x27;张飞&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-09-01&#x27;, 24500.00, NULL, 10),(1008, &#x27;诸葛亮&#x27;, &#x27;分析师&#x27;, 1004, &#x27;2007-04-19&#x27;, 30000.00, NULL, 20),(1009, &#x27;曾阿牛&#x27;, &#x27;董事长&#x27;, NULL, &#x27;2001-11-17&#x27;, 50000.00, NULL, 10),(1010, &#x27;韦一笑&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-09-08&#x27;, 15000.00, 0.00, 30),(1011, &#x27;周泰&#x27;, &#x27;文员&#x27;, 1008, &#x27;2007-05-23&#x27;, 11000.00, NULL, 20),(1012, &#x27;程普&#x27;, &#x27;文员&#x27;, 1006, &#x27;2001-12-03&#x27;, 9500.00, NULL, 30),(1013, &#x27;庞统&#x27;, &#x27;分析师&#x27;, 1004, &#x27;2001-12-03&#x27;, 30000.00, NULL, 20),(1014, &#x27;黄盖&#x27;, &#x27;文员&#x27;, 1007, &#x27;2002-01-23&#x27;, 13000.00, NULL, 10);-- 创建工资等级表并插入数据create table salgrade (\tgrade int,  -- 等级\tlosal double,  -- 最低工资\thisal double  -- 最高工资);-- 插入数据insert into salgrade values (1,7000,12000);insert into salgrade values (2,12010,14000);insert into salgrade values (3,14010,20000);insert into salgrade values (4,20010,30000);insert into salgrade values (5,30010,99990);\n操作\n-- 创建视图create or replace view view1_empas select ename,job from emp; -- 查看表和视图 show full tables;\n修改视图\n修改视图是指修改数据库中已存在的表的定义。当基本表的某些字段发生改变时，可以通过修改视图来保持视图和基本表之间一致。MySQL中通过CREATE OR REPLACE VIEW语句来创建视图和ALTER VIEW语句来修改视图。\n格式\nalter view 视图名 as select语句\n操作\nalter view view1_empas select a.deptno,a.dname,a.loc,b.ename,b.sal from dept a, emp b where a.deptno = b.deptno;\n更新视图\n介绍\n\n某些视图是可更新的。也就是说，可以在UPDATE、DELETE或INSERT等语句中使用它们，以更新基表的内容。对于可更新的视图，在视图中的行和基表中的行之间必须具有一对一的关系。如果视图包含下述结构中的任何一种，那么它就是不可更新的：\n\n\n聚合函数（SUM(), MIN(), MAX(), COUNT()等）\nDISTINCT\nGROUP BY\nHAVING\nUNION或UNION ALL\n位于选择列表中的子查询\nJOIN\nFROM子句中的不可更新视图\nWHERE子句中的子查询，引用FROM子句中的表。\n仅引用文字值（在该情况下，没有要更新的基本表）\n\n\n\n视图中虽然可以更新数据，但是有很多的限制。一般情况下，最好将视图作为查询数据的虚拟表，而不要通过视图更新数据。因为，使用视图更新数据时，如果没有全面考虑在视图中更新数据的限制，就可能会造成数据更新失败。\n操作\n--  ---------更新视图-------create or replace view view1_empas select ename,job from emp; update view1_emp set ename = &#x27;周瑜&#x27; where ename = &#x27;鲁肃&#x27;;  -- 可以修改insert into view1_emp values(&#x27;孙权&#x27;,&#x27;文员&#x27;);  -- 不可以插入-- ----------视图包含聚合函数不可更新--------------create or replace view view2_empas select count(*) cnt from emp; insert into view2_emp values(100);update view2_emp set cnt = 100; -- ----------视图包含distinct不可更新---------create or replace view view3_empas select distinct job from emp; insert into view3_emp values(&#x27;财务&#x27;); -- ----------视图包含goup by 、having不可更新------------------ create or replace view view4_empas select deptno ,count(*) cnt from emp group by deptno having  cnt &gt; 2; insert into view4_emp values(30,100);-- ----------------视图包含union或者union all不可更新----------------create or replace view view5_empas select empno,ename from emp where empno &lt;= 1005union select empno,ename from emp where empno &gt; 1005; insert into view5_emp values(1015,&#x27;韦小宝&#x27;);-- -------------------视图包含子查询不可更新--------------------create or replace view view6_empas select empno,ename,sal from emp where sal = (select max(sal) from emp); insert into view6_emp values(1015,&#x27;韦小宝&#x27;,30000);-- ----------------------视图包含join不可更新-----------------create or replace view view7_empas select dname,ename,sal from emp a join  dept b  on a.deptno = b.deptno; insert into view7_emp(dname,ename,sal) values(&#x27;行政部&#x27;,&#x27;韦小宝&#x27;,30000); -- --------------------视图包含常量文字值不可更新-------------------create or replace view view8_empas select &#x27;行政部&#x27; dname,&#x27;杨过&#x27;  ename; insert into view8_emp values(&#x27;行政部&#x27;,&#x27;韦小宝&#x27;);\n其他操作\n重命名视图\n-- rename table 视图名 to 新视图名; rename table view1_emp to my_view1\n删除视图\n-- drop view 视图名[,视图名…];drop view if exists view_student;\n删除视图时，只能删除视图的定义，不会删除数据。\n练习\n-- 1：查询部门平均薪水最高的部门名称-- 方式一：视图create view avg_sal as select deptno,avg(sal) from emp group by deptno order by avg(sal) desc limit 1;select dname from dept  a ,avg_sal b where a.deptno = b.deptno;   -- 方式二：子查询select dname from dept  a ,(select deptno,avg(sal) from emp group by deptno order by avg(sal) desc limit 1) b where a.deptno = b.deptno;    -- 2：查询员工比所属领导薪资高的部门名、员工名、员工领导编号select * from dept x,(select a.ename aname ,a.sal asal,b.ename bname,b.sal bsal,a.deptnofrom emp a, emp b where a.mgr = b.empno and a.sal &gt; b.sal) ywhere x.deptno = y.deptno;-- 3：查询工资等级为4级，2000年以后入职的工作地点为北京的员工编号、姓名和工资，并查询出薪资在前三名的员工信息create view xxxas       SELECT e.empno,e.ename,e.sal,e.hiredateFROM emp e,dept d,salgrade sWHERE (e.sal BETWEEN  losal AND hisal) AND s.GRADE = 4AND year(e.hiredate) &gt; &#x27;2000&#x27;AND d.loc = &#x27;北京&#x27;; select * from (select  *, dense_rank() over(order by sal desc ) rnfrom xxx) twhere t.rn &lt;=3;\nMySQL的存储过程\n介绍\n\n\n什么是存储过程\n\n\nMySQL 5.0 版本开始支持存储过程。\n简单的说，存储过程就是一组SQL语句集，功能强大，可以实现一些比较复杂的逻辑功能，类似于JAVA语言中的方法；\n存储过就是数据库 SQL 语言层面的代码封装与重用。\n\n\n\n\n有哪些特性\n\n\n有输入输出参数，可以声明变量，有if/else, case,while等控制语句，通过编写存储过程，可以实现复杂的逻辑功能；\n函数的普遍特性：模块化，封装，代码复用；\n速度快，只有首次执行需经过编译和优化步骤，后续被调用可以直接执行，省去以上步骤；\n\n\n入门案例\n格式\ndelimiter 自定义结束符号create procedure 储存名([ in ,out ,inout ] 参数名 数据类形...)begin  sql语句end 自定义的结束符合delimiter ;\n操作-数据准备\n-- 1：创建数据库和表 create database mydb7_procedure; -- 选择mydb7_procedure数据库use mydb7_procedure;-- 创建部门表并插入数据create table dept(\tdeptno int primary key,  dname varchar(20),\tloc varchar(20));insert into dept values(10, &#x27;教研部&#x27;,&#x27;北京&#x27;),(20, &#x27;学工部&#x27;,&#x27;上海&#x27;),(30, &#x27;销售部&#x27;,&#x27;广州&#x27;),(40, &#x27;财务部&#x27;,&#x27;武汉&#x27;);-- 创建员工表并插入数据create table emp(\tempno int primary key,\tename varchar(20),\tjob varchar(20),\tmgr int,\thiredate date,\tsal numeric(8,2),\tcomm numeric(8, 2),\tdeptno int,-- \tFOREIGN KEY (mgr) REFERENCES emp(empno),\tFOREIGN KEY (deptno) REFERENCES dept(deptno) ON DELETE SET NULL ON UPDATE CASCADE);INSERT INTO emp VALUES(1001, &#x27;甘宁&#x27;, &#x27;文员&#x27;, 1013, &#x27;2000-12-17&#x27;, 8000.00, NULL, 20),(1002, &#x27;黛绮丝&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-02-20&#x27;, 16000.00, 3000.00, 30),(1003, &#x27;殷天正&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-02-22&#x27;, 12500.00, 5000.00, 30),(1004, &#x27;刘备&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-4-02&#x27;, 29750.00, NULL, 20),(1005, &#x27;谢逊&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-9-28&#x27;, 12500.00, 14000.00, 30),(1006, &#x27;关羽&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-05-01&#x27;, 28500.00, NULL, 30),(1007, &#x27;张飞&#x27;, &#x27;经理&#x27;, 1009, &#x27;2001-09-01&#x27;, 24500.00, NULL, 10),(1008, &#x27;诸葛亮&#x27;, &#x27;分析师&#x27;, 1004, &#x27;2007-04-19&#x27;, 30000.00, NULL, 20),(1009, &#x27;曾阿牛&#x27;, &#x27;董事长&#x27;, NULL, &#x27;2001-11-17&#x27;, 50000.00, NULL, 10),(1010, &#x27;韦一笑&#x27;, &#x27;销售员&#x27;, 1006, &#x27;2001-09-08&#x27;, 15000.00, 0.00, 30),(1011, &#x27;周泰&#x27;, &#x27;文员&#x27;, 1008, &#x27;2007-05-23&#x27;, 11000.00, NULL, 20),(1012, &#x27;程普&#x27;, &#x27;文员&#x27;, 1006, &#x27;2001-12-03&#x27;, 9500.00, NULL, 30),(1013, &#x27;庞统&#x27;, &#x27;分析师&#x27;, 1004, &#x27;2001-12-03&#x27;, 30000.00, NULL, 20),(1014, &#x27;黄盖&#x27;, &#x27;文员&#x27;, 1007, &#x27;2002-01-23&#x27;, 13000.00, NULL, 10);-- 创建工资等级表并插入数据create table salgrade (\tgrade int,  -- 等级\tlosal double,  -- 最低工资\thisal double  -- 最高工资);-- 插入数据insert into salgrade values (1,7000,12000);insert into salgrade values (2,12010,14000);insert into salgrade values (3,14010,20000);insert into salgrade values (4,20010,30000);insert into salgrade values (5,30010,99990);-- 2：创建存储过程delimiter $$create procedure proc01()begin  select empno,ename from emp; end  $$delimiter ;-- 调用存储过程call proc01(); \nMySQL操作-变量定义\n局部变量\n格式\n\n用户自定义，在begin/end块中有效\n\n语法： 声明变量 declare var_name type [default var_value]; 举例：declare nickname varchar(32);\n操作\n-- 定义局部变量delimiter $$create procedure proc02()begin    declare var_name01 varchar(20) default &#x27;aaa&#x27;;  -- 定义局部变量    set var_name01 = &#x27;zhangsan&#x27;;   -- 给变量赋值    select var_name01;   -- 输出变量的值end $$delimiter ;-- 调用存储过程call proc02();\n\nMySQL 中还可以使用 SELECT…INTO 语句为变量赋值。其基本语法如下：\n\n-- 格式select col_name [...] into var_name[,...] from table_name wehre condition 其中：col_name 参数表示查询的字段名称；var_name 参数是变量的名称；table_name 参数指表的名称；condition 参数指查询条件。🌟注意：当将查询结果赋值给变量时，该查询语句的返回结果只能是单行单列。-- 例子delimiter $$create procedure proc03()begin  declare my_ename varchar(20) ;  select ename into my_ename from emp where empno=1001;  select my_ename;end $$delimiter ;-- 调用存储过程call proc03();\n用户变量\n格式\n\n用户自定义，当前会话（连接）有效。类比java的成员变量\n\n语法： @var_name不需要提前声明，使用即声明\n操作\ndelimiter $$create procedure proc04()begin    set @var_name01  = &#x27;ZS&#x27;;end $$delimiter;call proc04() ;select @var_name01  ;  --可以看到结果\n系统变量\n介绍\n\n\n系统变量又分为全局变量与会话变量。\n全局变量在MYSQL启动的时候由服务器自动将它们初始化为默认值，这些默认值可以通过更改my.ini这个文件来更改。\n会话变量在每次建立一个新的连接的时候，由MYSQL来初始化。MYSQL会将当前所有全局变量的值复制一份。来做为会话变量。\n也就是说，如果在建立会话以后，没有手动更改过会话变量与全局变量的值，那所有这些变量的值都是一样的。\n全局变量与会话变量的区别就在于，对全局变量的修改会影响到整个服务器，但是对会话变量的修改，只会影响到当前的会话（也就是当前的数据库连接）。\n有些系统变量的值是可以利用语句来动态进行更改的，但是有些系统变量的值却是只读的，对于那些可以更改的系统变量，我们可以利用set语句进行更改。\n\n\n系统变量-全局变量\n\n由系统提供，在整个数据库有效。\n\n格式\n语法：@@global.var_name\n操作\n-- 查看全局变量 show global variables; -- 查看某全局变量 select @@global.auto_increment_increment; -- 修改全局变量的值 set global sort_buffer_size = 40000; set @@global.sort_buffer_size = 40000;\n系统变量-会话变量\n\n由系统提供，当前会话（连接）有效\n\n格式\n语法：@@session.var_name\n操作\n-- 查看会话变量show session variables;-- 查看某会话变量 select @@session.auto_increment_increment;-- 修改会话变量的值set session sort_buffer_size = 50000; set @@session.sort_buffer_size = 50000 ;\n存储过程传参-in\n\nin 表示传入的参数， 可以传入数值或者变量，即使传入变量，并不会更改变量的值，可以内部更改，仅仅作用在函数范围内。\n\n-- 封装有参数的存储过程，传入员工编号，查找员工信息delimiter $$create procedure dec_param01(in param_empno varchar(20))begin        select * from emp where empno = param_empno;end $$ delimiter ;call dec_param01(&#x27;1001&#x27;);-- 案例-- 封装有参数的存储过程，可以通过传入部门名和薪资，查询指定部门，并且薪资大于指定值的员工信息delimiter $$create procedure dec_param0x(in dname varchar(50),in sal decimal(7,2))begin        select * from dept a, emp b where b.sal &gt; sal and a.dname = dname;end $$ delimiter ;call dec_param0x(&#x27;学工部&#x27;,20000);call dec_param0x(&#x27;教研部&#x27;,20000);\n存储过程传参-out\n\nout 表示从存储过程内部传值给调用者\n\n-- ---------传出参数：out---------------------------------use mydb7_procedure;-- 封装有参数的存储过程，传入员工编号，返回员工名字delimiter $$create procedure proc08(in empno int ,out out_ename varchar(50) )begin  select ename into out_ename from emp where emp.empno = empno;end $$ delimiter ; call proc08(1001, @o_ename);select @o_ename;-- 案例-- 封装有参数的存储过程，传入员工编号，返回员工名字和薪资delimiter $$create procedure proc09(in empno int ,out out_ename varchar(50) ,out out_sal decimal(7,2))begin  select ename,sal into out_ename,out_sal from emp where emp.empno = empno;end $$ delimiter ; call proc09(1001, @o_dname,@o_sal);select @o_dname;select @o_sal;\n存储过程传参-inout\n\ninout 表示从外部传入的参数经过修改后可以返回的变量，既可以使用传入变量的值也可以修改变量的值（即使函数执行完）\n\n-- 传入员工名，拼接部门号，传入薪资，求出年薪-- 关羽 ----&gt; 30_关羽delimiter $$create procedure proc10(inout inout_ename varchar(50),inout inout_sal int)begin  select  concat(deptno,&quot;_&quot;,inout_ename) into inout_ename from emp where ename = inout_ename;  set inout_sal = inout_sal * 12;  end $$delimiter ;set @inout_ename = &#x27;关羽&#x27;;set @inout_sal = 3000;call proc10(@inout_ename, @inout_sal) ;select @inout_ename ;select @inout_sal ;\n\n存储过程传参-in，out, inout\n总结\n\n\n\nin 输入参数，意思说你的参数要传到存过过程的过程里面去，在存储过程中修改该参数的值不能被返回\n\n\nout 输出参数:该值可在存储过程内部被改变，并向外输出\n\n\ninout 输入输出参数，既能输入一个值又能传出来一个值)\n\n\n\n流程控制-判断\n格式\n\nIF语句包含多个条件判断，根据结果为TRUE、FALSE执行语句，与编程语言中的if、else if、else语法类似，其语法格式如下：\n\n-- 语法if search_condition_1 then statement_list_1    [elseif search_condition_2 then statement_list_2] ...    [else statement_list_n]end if\n操作\n-- 输入学生的成绩，来判断成绩的级别：/*  score &lt; 60 :不及格  score &gt;= 60  , score &lt;80 :及格    score &gt;= 80 , score &lt; 90 :良好    score &gt;= 90 , score &lt;= 100 :优秀    score &gt; 100 :成绩错误*/delimiter  $$create procedure proc_12_if(in score int)begin  if score &lt; 60       then          select &#x27;不及格&#x27;;    elseif  score &lt; 80      then          select &#x27;及格&#x27; ;    elseif score &gt;= 80 and score &lt; 90       then            select &#x27;良好&#x27;;  elseif score &gt;= 90 and score &lt;= 100       then            select &#x27;优秀&#x27;;     else       select &#x27;成绩错误&#x27;;  end if;end $$delimiter  ;call proc_12_if(120)-- 输入员工的名字，判断工资的情况。delimiter $$create procedure proc12_if(in in_ename varchar(50))begin    declare result varchar(20);    declare var_sal decimal(7,2);        select sal into  var_sal from emp where ename = in_ename;    if var_sal &lt; 10000         then set result = &#x27;试用薪资&#x27;;    elseif var_sal &lt; 20000        then set result = &#x27;转正薪资&#x27;;    elseif var_sal &gt;= 20000        then set result = &#x27;元老薪资&#x27;;\t\telse \t\t\tset result = &#x27;查询名字不存在&#x27;;    end if;    select result;end$$delimiter ;call proc12_if(&#x27;庞统&#x27;);\n流程控制-case\n\nCASE是另一个条件判断的语句，类似于编程语言中的switch语法\n\n操作\n-- 语法一（类比java的switch）：case case_value    when when_value then statement_list    [when when_value then statement_list] ...    [else statement_list]end case-- 语法二：case    when search_condition then statement_list    [when search_condition then statement_list] ...    [else statement_list]end case-- 案例-- 语法一delimiter $$create procedure proc14_case(in pay_type int)begin  case pay_type        when  1           then               select &#x27;微信支付&#x27; ;        when  2 then select &#x27;支付宝支付&#x27; ;        when  3 then select &#x27;银行卡支付&#x27;;      else select &#x27;其他方式支付&#x27;;    end case ;end $$delimiter ; call proc14_case(2);call proc14_case(4);-- 语法二delimiter  $$create procedure proc_15_case(in score int)begin  case  when score &lt; 60       then          select &#x27;不及格&#x27;;    when  score &lt; 80      then          select &#x27;及格&#x27; ;    when score &gt;= 80 and score &lt; 90       then            select &#x27;良好&#x27;;  when score &gt;= 90 and score &lt;= 100       then            select &#x27;优秀&#x27;;     else       select &#x27;成绩错误&#x27;;  end case;end $$delimiter  ; call proc_15_case(88);\n流程控制-循环\n概述：\n\n\n循环是一段在程序中只出现一次,但可能会连续运行多次的代码。\n循环中的代码会运行特定的次数,或者是运行到特定条件成立时结束循环。\n\n\n循环分类：\n\n\nwhile\nrepeat\nloop\n\n\n循环控制：\n\n\nleave 类似于 break，跳出，结束当前所在的循环；\niterate类似于 continue，继续，结束本次循环，继续下一次。\n\n\n\n流程控制-循环-while\n格式\n【标签:】while 循环条件 do    循环体;end while【 标签】;\n操作\n-- 选择 mydb7_procedure 数据库use mydb7_procedure;-- 创建测试表create table user (    uid int primary key,    username varchar ( 50 ),    password varchar ( 50 ));-- 需求：向表中添加10条数据。-- -------存储过程-whiledelimiter $$create procedure proc16_while1(in insertcount int)begin    declare i int default 1;    label:while i&lt;=insertcount do        insert into user(uid,username,password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);        set i=i+1;    end while label;end $$delimiter ; call proc16_while1(10);-- -------存储过程-while + leavetruncate table user;delimiter $$create procedure proc16_while2(in insertcount int)begin    declare i int default 1;    label:while i&lt;=insertcount do        insert into user(uid,username,password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);        if i=5 then leave label;        end if;        set i=i+1;    end while label;end $$delimiter ; call proc16_while2(10);-- -------存储过程-while+iteratetruncate table user;delimiter $$create procedure proc16_while3(in insertcount int)begin    declare i int default 1;    label:while i&lt;=insertcount do        set i=i+1;        if i=5 then iterate label;        end if;        insert into user(uid,username,password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);    end while label;end $$delimiter ;call proc16_while3(10);\n流程控制-循环-repeat\n格式\n[标签:]repeat  循环体;until 条件表达式end repeat [标签];\n操作\n-- -------存储过程-循环控制-repeat use mydb7_procedure;truncate table user;  delimiter $$create procedure proc18_repeat(in insertCount int)begin     declare i int default 1;     label:repeat         insert into user(uid, username, password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);         set i = i + 1;         until  i  &gt; insertCount     end repeat label;     select &#x27;循环结束&#x27;;end $$delimiter ; call proc18_repeat(100);\n流程控制-循环-loop\n格式\n[标签:] loop  循环体;  if 条件表达式 then      leave [标签];   end if;end loop;\n操作\n-- -------存储过程-循环控制-looptruncate table user; delimiter $$create procedure proc19_loop(in insertCount int) begin     declare i int default 1;     label:loop         insert into user(uid, username, password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);         set i = i + 1;         if i &gt; 5           then            leave label;         end if;     end loop label;     select &#x27;循环结束&#x27;;end $$delimiter ; call proc19_loop(10);\n\n文章作者: [Blue Eagle]\n文章链接: [https://yjh021.github.io/2024/10/04/MySQL/]\n版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 [Blue Eagle]\n\n","categories":["数据库","MySQL"],"tags":["SQL","数据库管理","学习笔记"]}]